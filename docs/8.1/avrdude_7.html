<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on June 23, 2025 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>AVRDUDE: 2.4 Example Command Line Invocations</title>

<meta name="description" content="AVRDUDE: 2.4 Example Command Line Invocations">
<meta name="keywords" content="AVRDUDE: 2.4 Example Command Line Invocations">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body { background-color: #ffd; }
h1 { text-shadow: .05em .05em #ccc; }
table {
  border: 3px solid #ccf;
  background-color: white;
}
div.smallexample {
  background-color: #dfd;
  border: 3px solid #cfc;
}
div.example {
  background-color: #dfd;
  border: 3px solid #cfc;
}
samp {
  color: blue;
}
code {
  color: green;
}

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Example-Command-Line-Invocations"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="avrdude_6.html#Programmers-Accepting-Extended-Parameters" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_8.html#Terminal-Mode-Operation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude_3.html#Command-Line-Options" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_3.html#Command-Line-Options" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_8.html#Terminal-Mode-Operation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_51.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr size="1">
<a name="Example-Command-Line-Invocations-1"></a>
<h2 class="section">2.4 Example Command Line Invocations</h2>
<a name="index-Example-Command-line-invocations"></a>

<p>AVRDUDE error messages, warnings and progress reports are generally
written to stderr which can, in bash, be turned off by <code>2&gt;/dev/null</code>
or by using increasingly more <code>-q</code> options to suppress them. Terminal
output of commands or that of the <code>-U</code> command with an output file
named <code>-</code> are written to stdout. In some examples empty lines are
shown for clarity that are not printed by AVRDUDE or the shell.
</p>
<a name="index-flash-29"></a>
<p><strong>Write the file <code>diag.hex</code> to the ATmega128 chip</strong> using the
STK500 programmer connected to the default serial port:
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -p m128 -c stk500 -e -U flash:w:diag.hex

Reading 19278 bytes for flash from input file diag.hex
Writing 19278 bytes to flash
Writing | ################################################## | 100% 7.60 s
Reading | ################################################## | 100% 6.83 s
19278 bytes of flash verified

Avrdude done.  Thank you.
</pre></td></tr></table>
</td></tr></table>

<p>Same but in <strong>quell-progress-reporting (silent) mode <code>-qq</code>:</strong>
</p>
<a name="index-flash-30"></a>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -qq -p m128 -c stk500 -e -U flash:w:diag.hex
</pre></td></tr></table>
</td></tr></table>

<p><strong>Using <code>&amp;&amp;</code> to confirm that the silent AVRDUDE command went OK:</strong>
</p>
<a name="index-flash-31"></a>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -qq -p m128 -c stk500 -e -U flash:w:diag.hex &amp;&amp; echo OK
OK
</pre></td></tr></table>
</td></tr></table>

<a name="index-flash-32"></a>
<p><strong>Save flash memory in raw binary format to the file named <code>c:/diag flash.bin</code>:</strong>
</p>
<a name="index-flash-33"></a>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -p m128 -c stk500 -U flash:r:&quot;c:/diag flash.bin&quot;:r

Reading flash memory ...
Reading | ################################################## | 100% 6.90 s
Writing 19278 bytes to output file diag flash.bin

Avrdude done.  Thank you.
</pre></td></tr></table>
</td></tr></table>

<p><strong>Read the fuses and print their values in different formats (hexadecimal, binary and octal):</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -cusbasp -patmega128 -qq -Ulfuse:r:-:h -Uhfuse:r:-:b -Uefuse:r:-:o

0xbf
0b11000110
0377
</pre></td></tr></table>
</td></tr></table>



<a name="index-flash-34"></a>
<a name="index-eeprom-8"></a>
<p>Using the default programmer, write the file <code>diag.hex</code> to flash, the
file <code>eeprom.hex</code> to EEPROM, and <strong>set the extended, high, and
low fuse bytes</strong> to 0xff, 0x89, and 0x2e respectively:
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -p m128 -U flash:w:diag.hex    \
                  -U eeprom:w:eeprom.hex \
                  -U efuse:w:0xff:m      \
                  -U hfuse:w:0x89:m      \
                  -U lfuse:w:0x2e:m

Processing -U flash:w:diag.hex:i
Reading 19278 bytes for flash from input file diag.hex
Writing 19278 bytes to flash
Writing | ################################################## | 100% 7.60 s
Reading | ################################################## | 100% 6.81 s
19278 bytes of flash verified

Processing -U eeprom:w:eeprom.hex:i
Reading 3328 bytes for eeprom from input file eeprom.hex
Writing 3328 bytes to eeprom
Writing | ################################################## | 100% 1.20 s
Reading | ################################################## | 100% 0.70 s
3328 bytes of eeprom verified

Processing -U efuse:w:0xff:m
Reading 1 byte for efuse from input file 0xff
Writing 1 byte (0xFF) to efuse, 1 byte written, 1 verified

Processing -U hfuse:w:0x89:m
Reading 1 byte for hfuse from input file 0x89
Writing 1 byte (0x89) to hfuse, 1 byte written, 1 verified

Processing -U lfuse:w:0x2e:m
Reading 1 byte for lfuse from input file 0x2e
Writing 1 byte (0x2E) to lfuse, 1 byte written, 1 verified

Avrdude done.  Thank you.
</pre></td></tr></table>
</td></tr></table>

<p><strong>Write data from stdin (standard input) to EEPROM;</strong> no error output means all went fine:
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ echo 'The quick brown fox' | avrdude -c usbasp -p attiny13 -qq -U eeprom:w:-:r
</pre></td></tr></table>
</td></tr></table>


<p><strong>Execute multiple terminal mode commands separated by semicolons:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ echo 'write eeprom 0 &quot;Bonjour&quot;; write ee 0x18 0x12345678; dump eeprom 0 0x20' | \
  avrdude -qqcdryrun -patmega328p -t

0000  42 6f 6e 6a 6f 75 72 00  ff ff ff ff ff ff ff ff  |Bonjour.........|
0010  ff ff ff ff ff ff ff ff  78 56 34 12 ff ff ff ff  |........xV4.....|
</pre></td></tr></table>
</td></tr></table>


<p><strong>The same using -T:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -qqcdryrun -patmega328p \
  -T 'write eeprom 0 &quot;Bonjour&quot;; write ee 0x18 0x12345678; dump eeprom 0 0x20'

0000  42 6f 6e 6a 6f 75 72 00  ff ff ff ff ff ff ff ff  |Bonjour.........|
0010  ff ff ff ff ff ff ff ff  78 56 34 12 ff ff ff ff  |........xV4.....|
</pre></td></tr></table>
</td></tr></table>

<p><strong>Read EEPROM and write content to stdout (standard output):</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -qq -cusbasp -pattiny13 -Ueeprom:r:-:i

:20000000E2809954686520717569636B2062726F776E20666F78E280990AFFFFFFFFFFFFD3
:20002000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
:00000001FF
</pre></td></tr></table>
</td></tr></table>

<p><strong>Same but redirect stderr (standard error output) to <code>/dev/null</code> instead of using <code>-qq</code>:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -cusbasp -pattiny13 -Ueeprom:r:-:i 2&gt;/dev/null

:20000000E2809954686520717569636B2062726F776E20666F78E280990AFFFFFFFFFFFFD3
:20002000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
:00000001FF
</pre></td></tr></table>
</td></tr></table>

<a name="index-flash-35"></a>
<p><strong>Using the Avrdude output to print strings present in flash memory:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -pattiny13 -qq -U flash:r:-:r | strings

Main menu
Distance: %d cm
Exit
</pre></td></tr></table>
</td></tr></table>

<p><strong>List the serial numbers of all JTAG ICEs attached to USB;</strong> this is
done by specifying an invalid serial number, and increasing the
verbosity level:
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -c jtag2 -p m128 -P usb:xxx -v

Using port            : usb:xxx
Using programmer      : jtag2fast
Programmer baud rate  : 115200
Usbdev_open(): Found JTAG ICE, serno: 00A000001C6B
Usbdev_open(): Found JTAG ICE, serno: 00A000001C3A
Usbdev_open(): Found JTAG ICE, serno: 00A000001C30
Error: did not find any (matching) USB device usb:xxx (03eb:2103)
Error: unable to open port usb:xxx for programmer jtag2fast

Avrdude done.  Thank you.
</pre></td></tr></table>
</td></tr></table>


<p>Connect to the JTAG ICE mkII with a <strong>serial number ending in 1C37</strong>
via USB, <strong>enter interactive terminal mode</strong>, list all <strong>commands for
the connected part</strong> and quit:
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -c jtag2 -p m649 -P usb:1c:37 -t

avrdude&gt; help
Valid commands:
  dump    : display a memory section as hex dump
  read    : alias for dump
  disasm  : disassemble a memory section
  write   : write data to memory; flash and EEPROM are cached
  save    : save memory segments to file
  backup  : backup memories to file
  restore : restore memories from file
  verify  : compare memories with file
  flush   : synchronise flash and EEPROM cache with the device
  abort   : abort flash and EEPROM writes, ie, reset the r/w cache
  erase   : perform a chip or memory erase
  config  : change or show configuration properties of the part
  factory : reset part to factory state
  regfile : I/O register addresses and contents
  include : include contents of named file as if it was typed
  sig     : display device signature bytes
  part    : display the current part information
  send    : send a raw command to the programmer
  verbose : display or set -v verbosity level
  quell   : display or set -q quell level for progress bars
  help    : show help message
  ?       : same as help
  quit    : synchronise flash/EEPROM cache with device and quit
  q       : abbreviation for quit

For more details about a terminal command cmd type cmd -?

Other:
  !&lt;line&gt; : run the shell &lt;line&gt; in a subshell, eg, !ls *.hex
  # ...   : ignore rest of line (eg, used as comments in scripts)

Note that not all programmer derivatives support all commands. Flash and
EEPROM type memories are normally read and written using a cache via paged
read and write access; the cache is synchronised on quit or flush commands.
The part command displays valid memories for use with dump and write.

avrdude&gt; quit

Avrdude done.  Thank you.
</pre></td></tr></table>
</td></tr></table>


<p><strong>Factory fuse setting of a device:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -patmega328p/St | grep initval

.ptmm	ATmega328P	lfuse	initval	0x62
.ptmm	ATmega328P	hfuse	initval	0xd9
.ptmm	ATmega328P	efuse	initval	0xff
.ptmm	ATmega328P	lock	initval	0xff
</pre></td></tr></table>
</td></tr></table>

<p><strong>List of all parts known to AVRDUDE:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -p \*/d | cut -f2 -d&quot;'&quot;

ATtiny11
ATtiny12
ATtiny13
ATtiny13A
ATtiny15
AT89S51
[...]
AVR64EA48
LGT8F88P
LGT8F168P
LGT8F328P
</pre></td></tr></table>
</td></tr></table>

<p><strong>List of all modern AVR parts (with UPDI interface) known to AVRDUDE:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -p \*/Ud | cut -f2 -d&quot;'&quot;

ATtiny202
ATtiny204
ATtiny402
[...]
AVR64EA28
AVR64EA32
AVR64EA48
</pre></td></tr></table>
</td></tr></table>

<p><strong>List of all curently plugged-in serial devices known to the libserialport library:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -P \?s
Possible candidate serial ports are:
  -P /dev/ttyUSB0 or -P ft232r:A600K203
  -P /dev/ttyUSB1 or -P ft232r:MCU8
  -P /dev/ttyUSB3, -P ch340 or -P ch340-115k
Note that above ports might not be connected to a target board or an AVR programmer.
Also note there may be other direct serial ports not listed above.
</pre></td></tr></table>
</td></tr></table>


<p><strong>List of all serial adapters known to AVRDUDE, i.e., defined in avrdude.conf:</strong>
</p>
<table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -P \?sa

Valid serial adapters are:
  ch340   = [usbvid 0x1a86, usbpid 0x7523]
  ch341a  = [usbvid 0x1a86, usbpid 0x5512]
  ch342   = [usbvid 0x1a86, usbpid 0x55d2]
  ch343   = [usbvid 0x1a86, usbpid 0x55d3]
  ch344   = [usbvid 0x1a86, usbpid 0x55d5]
  ch347   = [usbvid 0x1a86, usbpid 0x55da 0x55db 0x55dd 0x55de]
  ch9102  = [usbvid 0x1a86, usbpid 0x55d4]
  ch9103  = [usbvid 0x1a86, usbpid 0x55d7]
  cp210x  = [usbvid 0x10c4, usbpid 0xea60 0xea70 0xea71]
  ft2232h = [usbvid 0x0403, usbpid 0x6010]
  ft231x  = [usbvid 0x0403, usbpid 0x6015]
  ft234x  = [usbvid 0x0403, usbpid 0x6015]
  ft230x  = [usbvid 0x0403, usbpid 0x6015]
  ft232h  = [usbvid 0x0403, usbpid 0x6014]
  ft232r  = [usbvid 0x0403, usbpid 0x6001]
  ft4232h = [usbvid 0x0403, usbpid 0x6011]
  pl2303  = [usbvid 0x067b, usbpid 0x2303 0x2304 0x23a3 0x23b3 0x23c3 0x23d3 0x23e3]
</pre></td></tr></table>
</td></tr></table>

<p><strong>Output a list of non-bootloader programmers that can be used for a part.</strong>
Note that 2&gt;&amp;1 folds stderr into stdout in a bash shell:
</p><table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ avrdude -c &quot;?&quot; -p 32ea32 2&gt;&amp;1 | grep -v bootloader

Valid programmers for part AVR32EA32 are:
  atmelice_updi           = Atmel-ICE (UPDI)
  dryrun                  = Emulates programming without a programmer (TPI, [...])
  jtag2updi               = JTAGv2 to UPDI bridge (UPDI)
  nanoevery               = JTAGv2 to UPDI bridge (UPDI)
  jtag3updi               = Atmel AVR JTAGICE3 (UPDI)
  pickit4_mplab_updi      = MPLAB(R) PICkit 4 (UPDI)
  pickit4_updi            = MPLAB(R) PICkit 4 (UPDI)
  pickit5_updi            = MPLAB(R) PICkit 5 (UPDI)
  pickit_basic_updi       = MPLAB(R) PICkit Basic (UPDI)
  pickit_basic_mplab_updi = MPLAB(R) PICkit Basic (UPDI)
  pkobn_updi              = Curiosity nano (nEDBG) (UPDI)
  powerdebugger_updi      = Atmel PowerDebugger (UPDI)
  serialupdi              = SerialUPDI (UPDI)
  snap_mplab_updi         = MPLAB(R) SNAP (UPDI)
  snap_updi               = MPLAB(R) SNAP (UPDI)
  xplainedmini_updi       = Atmel XplainedMini (UPDI)
  xplainedpro_updi        = Atmel XplainedPro (UPDI)
</pre></td></tr></table>
</td></tr></table>


<p><strong>Print programmer definition</strong> as understood by AVRDUDE:
</p><table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$avrdude -c linuxspi/s

#------------------------------------------------------------
# linuxspi
#------------------------------------------------------------

# This programmer uses the built in linux SPI bus devices to program an
# attached AVR. The reset pin must be attached to a GPIO pin that
# is otherwise unused (see gpioinfo(1)); the SPI bus CE pins are not
# suitable since they would release /RESET too early.
#

programmer # linuxspi
    id                     = &quot;linuxspi&quot;;
    desc                   = &quot;Use Linux SPI device in /dev/spidev*&quot;;
    type                   = &quot;linuxspi&quot;;
    prog_modes             = PM_TPI | PM_ISP;
    extra_features         = HAS_BITCLOCK_ADJ;
    connection_type        = spi;
    reset                  = 25;    # Pi GPIO number - this is J8:22
;
</pre></td></tr></table>
</td></tr></table>


<p><strong>Print filename of last stored sketch with its date stamp</strong> (only with urclock programmer):
</p><table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$avrdude -qq -curclock -P/dev/ttyUSB0 -pattiny13 -x showdate -x showfilename

2023-05-19 11.13 blink.hex
</pre></td></tr></table>
</td></tr></table>

<p><strong>AVRDUDE in a bash script creating terminal scripts that reset a part to factory settings:</strong>
</p><table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ cat make-init-scripts

#!/bin/bash
mkdir /tmp/factory
for part in $(avrdude -p\*/d | grep = | cut -f2 -d&quot;'&quot;); do
  echo $part
  avrdude -p$part/St | grep initval | cut -f3,5 | grep -ve-1 \
  | sed &quot;s/.*/write &amp;/&quot; &gt;/tmp/factory/$part.ini
done
</pre></td></tr></table>
</td></tr></table>

<p><strong>Run above script and use one of the created terminal scripts:</strong>
</p><table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample">$ ./make-init-scripts

$ cat /tmp/factory/ATmega328P.ini
write lfuse	0x62
write hfuse	0xd9
write efuse	0xff
write lock	0xff

$ avrdude -qq -cusbasp -pATmega328P -t &lt; /tmp/factory/ATmega328P.ini
</pre></td></tr></table>
</td></tr></table>


<p><strong>Create a bash function <code>avrdude-elf</code></strong> that takes an elf file as input,
with support for optional Avrdude flags at the end, and <strong>writes to all memories
specified in the elf file.</strong> In this example, the elf file did not contain any
EEPROM data:
</p><table><tr><td>&nbsp;</td><td><table class="cartouche" border="1"><tr><td>
<pre class="smallexample"># Show all writable memories present for the ATtiny13
$ echo $(avrdude -pattiny13/ot | grep write | cut -f3 | uniq)

eeprom flash lfuse hfuse lock

# Function that writes to all memories present in the elf file
</pre><pre class="verbatim">avrdude-elf() {
  avrdude -cusbasp -pattiny13 -U{eeprom,flash,{l,h}fuse,lock}:w:&quot;$1&quot;:e &quot;${@:2}&quot;
}
</pre><pre class="smallexample">
# Run function where -B8 and -V is appended to the Avrdude command
$ avrdude-elf blink.elf -B8 -V

Set SCK frequency to 93750 Hz

Processing -U eeprom:w:blink.elf:e
Reading 64 bytes for eeprom from input file blink.elf
Writing 64 bytes to eeprom
Writing | ################################################## | 100% 0.08 s
64 bytes of eeprom written

Processing -U flash:w:blink.elf:e
Reading 1024 bytes for flash from input file blink.elf
Writing 1024 bytes to flash
Writing | ################################################## | 100% 0.12 s
1024 bytes of flash written

Processing -U lfuse:w:blink.elf:e
Reading 1 byte for lfuse from input file blink.elf
Writing 1 byte (0x6A) to lfuse, 1 byte written

Processing -U hfuse:w:blink.elf:e
Reading 1 byte for hfuse from input file blink.elf
Writing 1 byte (0xFF) to hfuse, 1 byte written

Processing -U lock:w:blink.elf:e
Reading 1 byte for lock from input file blink.elf
Writing 1 byte (0xFF) to lock, 1 byte written

Avrdude done.  Thank you.
</pre></td></tr></table>
</td></tr></table>


<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="avrdude_6.html#Programmers-Accepting-Extended-Parameters" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_8.html#Terminal-Mode-Operation" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude_3.html#Command-Line-Options" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_3.html#Command-Line-Options" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_8.html#Terminal-Mode-Operation" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_51.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated on <i>June 23, 2025</i> using <a href="http://www.nongnu.org/texi2html/"><i>texi2html 1.82</i></a>.
 </font>
 <br>

</p>
</body>
</html>
