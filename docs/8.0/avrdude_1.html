<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on August 24, 2024 by texi2html 1.82
texi2html was written by: 
            Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>
-->
<head>
<title>AVRDUDE: 1. Introduction</title>

<meta name="description" content="AVRDUDE: 1. Introduction">
<meta name="keywords" content="AVRDUDE: 1. Introduction">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.82">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body { background-color: #ffd; }
h1 { text-shadow: .05em .05em #ccc; }
table {
  border: 3px solid #ccf;
  background-color: white;
}
div.smallexample {
  background-color: #dfd;
  border: 3px solid #cfc;
}
div.example {
  background-color: #dfd;
  border: 3px solid #cfc;
}
samp {
  color: blue;
}
code {
  color: green;
}

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Introduction"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="avrdude.html#Top" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_2.html#History" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[ &lt;&lt; ]</td>
<td valign="middle" align="left">[<a href="avrdude.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_3.html#Command-Line-Options" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_50.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr size="1">
<a name="Introduction-1"></a>
<h1 class="chapter">1. Introduction</h1>
<a name="index-Introduction"></a>

<p>AVRDUDE - AVR Downloader Uploader - is a program for downloading and
uploading the on-chip memories of Atmel&rsquo;s AVR microcontrollers. It can
program the Flash, EEPROM, and where supported by the  programmer,  lock
bits, fuses that hold the microcontroller&rsquo;s configuration and other
memories that the part might have.
</p>
<a name="index-calibration"></a>
<a name="index-signature"></a>
<a name="index-flash"></a>
<a name="index-eeprom"></a>
<p>AVRDUDE can be used via the command line to read or write chip memories
(eeprom, flash, fuses, lock bits) and read memories such as signature or
calibration bytes; the same can be achieved via an interactive terminal
mode. Using AVRDUDE from the command line works well for programming the
entire memory of the chip from the contents of a file, while interactive mode
is useful for exploring memory contents, modifying individual bytes of
eeprom, programming fuse/lock bits, etc.
</p>
<a name="index-Programmers-supported"></a>
<a name="index-Emulating-a-HW-programmer-_0028dryrun_0029"></a>
<a name="index-Emulating-a-bootloader-_0028dryboot_0029"></a>

<p>Programming a microcontroller either requires a physical programmer that
sits between the target chip and the PC running AVRDUDE, or a  bootloader
program on the target chip that is then directly connected to the PC to be
served by AVRDUDE. Currently, AVRDUDE knows about 356 parts
and 149 programmers, though not every programmer can
deal with every part. One noteworthy programmer is <code>dryrun</code>, which
allows one to explore the AVRDUDE command-line and terminal without
needing to have, or connect, a real physical programmer. Similarly,
<code>dryboot</code> allows exploring how to communicate with a bootloader
without connecting an AVR part.
</p>
<p>AVRDUDE supports the following basic programmer types: Atmel&rsquo;s STK500,
Atmel&rsquo;s AVRISP and AVRISP mkII devices,
Atmel&rsquo;s STK600,
Atmel&rsquo;s JTAG ICE (the original one, mkII, and 3), appnote
avr910, appnote avr109 (including the AVR Butterfly),
serial bit-bang adapters,
and the PPI (parallel port interface). PPI represents a class
of simple programmers where the programming lines are directly
connected to the PC parallel port. Several pin configurations exist
for several variations of the PPI programmers, and AVRDUDE can be
configured to work with them by either specifying the appropriate
programmer on the command line or by creating a new entry in its
configuration file. All that&rsquo;s usually required for a new entry is to
tell AVRDUDE which pins to use for each programming function.
</p>
<p>A number of equally simple bit-bang programming adapters that connect
to a serial port are supported as well, among them the popular
Ponyprog serial adapter, and the DASA and DASA3 adapters that used to
be supported by uisp(1).  Note that these adapters are meant to be
attached to a physical serial port.  Connecting to a serial port
emulated on top of USB is likely to not work at all, or to work
abysmally slow.
</p>
<p>If you happen to have a Linux system with at least 4 hardware GPIOs
available (like almost all embedded Linux boards) you can do without any
additional hardware - just connect them to the SDO, SDI, RESET and SCK
pins of the AVR&rsquo;s SPI interface and use the linuxgpio programmer
type. Older boards might use the labels MOSI for SDO and MISO for SDI. It bitbangs
the lines using the Linux sysfs GPIO interface. Of course, care should
be taken about voltage level compatibility. Also, although not strictly
required, it is strongly advisable to protect the GPIO pins from
overcurrent situations in some way. The simplest would be to just put
some resistors in series or better yet use a 3-state buffer driver like
the 74HC244. Have a look at
<a href="https://kolev.info/blog/2013/01/06/avrdude-linuxgpio/">https://kolev.info/blog/2013/01/06/avrdude-linuxgpio/</a> for a more
detailed tutorial about using this programmer type.
</p>
<p>Under a Linux installation with direct access to the SPI bus and GPIO
pins, such as would be found on a Raspberry Pi, the &ldquo;linuxspi&rdquo;
programmer type can be used to directly connect to and program a chip
using the built in interfaces on the computer. The requirements to use
this type are that an SPI interface is exposed along with one GPIO
pin. The GPIO serves as the reset output since the Linux SPI drivers
do not hold chip select down when a transfer is not occuring and thus
it cannot be used as the reset pin. A readily available level
translator should be used between the SPI bus/reset GPIO and the chip
to avoid potentially damaging the computer&rsquo;s SPI controller in the
event that the chip is running at 5V and the SPI runs at 3.3V. The
GPIO chosen for reset can be configured in the avrdude configuration
file using the <code>reset</code> entry under the linuxspi programmer, or
directly in the port specification. An external pull-up resistor
should be connected between the AVR&rsquo;s reset pin and Vcc. If Vcc is not
the same as the SPI voltage, this should be done on the AVR side of
the level translator to protect the hardware from damage.
</p>
<p>On a Raspberry Pi, header J8 provides access to the SPI and GPIO
lines.
</p>
<p>Typically, pins 19, 21, and 23 are SPI SDO, SDI, and SCK, while
pins 24 and 26 would serve as CE outputs. So, close to these pins
is pin 22 as GPIO25 which can be used as /RESET, and pin 25 can
be used as GND.
</p>
<p>A typical programming cable would then look like:
</p>
<table>
<tr><td width="15%"><code>J8 pin</code></td><td width="15%"><code>ISP pin</code></td><td width="30%"><code>Name</code></td></tr>
<tr><td width="15%"><code>21</code></td><td width="15%"><code>1</code></td><td width="30%"><code>SDI</code></td></tr>
<tr><td width="15%"><code>-</code></td><td width="15%"><code>2</code></td><td width="30%"><code>Vcc - leave open</code></td></tr>
<tr><td width="15%"><code>23</code></td><td width="15%"><code>3</code></td><td width="30%"><code>SCK</code></td></tr>
<tr><td width="15%"><code>19</code></td><td width="15%"><code>4</code></td><td width="30%"><code>SDO</code></td></tr>
<tr><td width="15%"><code>22</code></td><td width="15%"><code>5</code></td><td width="30%"><code>/RESET</code></td></tr>
<tr><td width="15%"><code>25</code></td><td width="15%"><code>6</code></td><td width="30%"><code>GND</code></td></tr>
</table>

<p>(Mind the 3.3 V voltage level of the Raspberry Pi!)
</p>
<p>The <code>-P <var>portname</var></code> option defaults to
<code>/dev/spidev0.0:/dev/gpiochip0</code> for this programmer.
</p>
<a name="index-Atmel-STK500"></a>
<a name="index-Atmel-JTAG-ICE-mkI"></a>
<a name="index-STK500"></a>
<a name="index-JTAG-ICE-mkI"></a>
<a name="index-butterfly"></a>
<p>The STK500, JTAG ICE, avr910, and avr109/butterfly use the serial port to communicate with the PC.
<a name="index-Atmel-STK600"></a>
<a name="index-Atmel-JTAG-ICE-mkII"></a>
<a name="index-Atmel-AVR-JTAGICE3"></a>
<a name="index-STK600"></a>
<a name="index-JTAG-ICE-mkII"></a>
<a name="index-AVR-JTAGICE3"></a>
<a name="index-JTAGICE3"></a>
<a name="index-USBasp-ISP-and-TPI-programmer"></a>
<a name="index-FT2232H_002fD-programmer"></a>
<a name="index-FT2232H-JTAG-programmer"></a>
<a name="index-FT2232H-with-buffer-and-LEDs"></a>
<a name="index-FT232H-JTAG-programmer"></a>
<a name="index-FT232H-programmer"></a>
<a name="index-FT232R-programmer"></a>
<a name="index-FT232R-Synchronous-BitBang"></a>
<a name="index-FT245R-programmer"></a>
<a name="index-FT4232H-programmer"></a>
<a name="index-FTDI-TTL232R_002d5V"></a>
<a name="index-USBtiny-simple-USB-programmer"></a>
The STK600, JTAG ICE mkII/3, AVRISP mkII, USBasp, avrftdi (and derivatives), and USBtinyISP
programmers communicate through the USB, using <code>libusb</code> as a
platform abstraction layer.
The avrftdi adds support for the FT2232C/D, FT2232H, and FT4232H devices. These all use
the MPSSE mode, which has a specific pin mapping. Bit 0 (the lsb of the byte in the config
file) is SCK. Bit 1 is SDO, and Bit 2 is SDI. Bit 3 usually reset. The 2232C/D parts
are only supported on interface A, but the H parts can be either A or B (specified by the
usbdev config parameter).
The STK500, STK600, JTAG ICE, and avr910 contain on-board logic to control the programming of the target
device.
<a name="index-Atmel-bootloader-_0028AVR109_002c-AVR911_0029"></a>
<a name="index-flash-1"></a>
The avr109 bootloader implements a protocol similar to avr910, but is
actually implemented in the boot area of the target&rsquo;s flash, as
opposed to being an external device.
The fundamental difference between the two types lies in the
protocol used to control the programmer. The avr910 protocol is very
simplistic and can easily be used as the basis for a simple, home made
programmer since the firmware is available online. On the other hand,
the STK500 protocol is more robust and complicated and the firmware is
not openly available.
The JTAG ICE also uses a serial communication protocol which is similar
to the STK500 firmware version 2 one.  However, as the JTAG ICE is
intended to allow on-chip debugging as well as memory programming, the
protocol is more sophisticated.
(The JTAG ICE mkII protocol can also be run on top of USB.)
Only the memory programming functionality of the JTAG ICE is supported
by AVRDUDE.
<a name="index-debugWIRE"></a>
<a name="index-ISP"></a>
<a name="index-PDI"></a>
<a name="index-JTAG"></a>
<a name="index-Atmel-JTAG-ICE-mkII-1"></a>
<a name="index-Atmel-AVR-JTAGICE3-1"></a>
<a name="index-JTAG-ICE-mkII-1"></a>
<a name="index-AVR-JTAGICE3-1"></a>
<a name="index-JTAGICE3-1"></a>
For the JTAG ICE mkII/3, JTAG, debugWIRE and ISP mode are supported, provided
it has a firmware revision of at least 4.14 (decimal).
See below for the limitations of debugWIRE.
For ATxmega devices, the JTAG ICE mkII/3 is supported in PDI mode (Xmega
parts), provided it has a revision 1 hardware and firmware version of at
least 5.37 (decimal).
</p>
<a name="index-Atmel_002dICE"></a>
<p>The Atmel-ICE (ARM/AVR) is supported (JTAG, PDI, debugWIRE, ISP, UPDI).
</p>
<a name="index-Atmel-XplainedPro"></a>
<a name="index-XplainedPro"></a>
<p>Atmel&rsquo;s XplainedPro boards, using EDBG protocol (CMSIS-DAP compliant), are
supported by the &ldquo;jtag3&rdquo; programmer type.
</p>
<a name="index-Atmel-XplainedMini"></a>
<a name="index-XplainedMini"></a>
<p>Atmel&rsquo;s XplainedMini boards, using mEDBG protocol, are also
supported by the &ldquo;jtag3&rdquo; programmer type.
</p>
<a name="index-Atmel-AVR-Dragon"></a>
<a name="index-AVR-Dragon"></a>
<a name="index-Dragon"></a>
<p>The AVR Dragon is supported in all modes (ISP, JTAG, PDI, HVSP, PP, debugWIRE).
When used in JTAG and debugWIRE mode, the AVR Dragon behaves similar to a
JTAG ICE mkII, so all device-specific comments for that device
will apply as well.
When used in ISP and PDI mode, the AVR Dragon behaves similar to an
AVRISP mkII (or JTAG ICE mkII in ISP mode), so all device-specific
comments will apply there.
In particular, the Dragon starts out with a rather fast ISP clock
frequency, so the <code>-B <var>bitclock</var></code>
option might be required to achieve a stable ISP communication.
For ATxmega devices, the AVR Dragon is supported in PDI mode, provided it
has a firmware version of at least 6.11 (decimal).
</p>
<a name="index-Wiring-bootloader"></a>
<p>Wiring boards (e.g. Arduino Mega 2560 Rev3) are supported, utilizing
STK500 V2.x protocol, but a simple DTR/RTS toggle to set the boards
into programming mode.  The programmer type is &ldquo;wiring&rdquo;. Note that
the <code>-D</code> option will likely be required in this case, because the
bootloader will rewrite the program memory, but no true chip erase can
be performed.
</p>
<a name="index-Arduino-bootloader"></a>
<p>Serial bootloaders that run a skeleton of the STK500 1.x protocol are supported via
their own programmer type specification &ldquo;arduino&rdquo;.  This programmer works for
the Arduino Uno Rev3 or any AVR that runs the Optiboot bootloader.
The number of connection retry attempts can be specified as an
extended parameter. See the section on
<em>extended parameters</em>
below for details.
</p>
<a name="index-Urboot-bootloader"></a>
<a name="index-Urclock-programmer"></a>
<a name="index-Urprotocol"></a>
<p>Urprotocol is a leaner version of the STK500 1.x protocol that is designed
to be backwards compatible with STK500 v1.x; it allows bootloaders to be
much smaller, e.g., as implemented in the urboot project
<a href="https://github.com/stefanrueger/urboot">https://github.com/stefanrueger/urboot</a>. The programmer type &ldquo;urclock&rdquo;
caters for these urboot bootloaders. Owing to its backward compatibility,
bootloaders that can be served by the arduino programmer can normally also
be served by the urclock programmer. This may require specifying the size
of (to AVRDUDE) <em>unknown</em> bootloaders in bytes using the <code>-x
bootsize=&lt;n&gt;</code> option, which is necessary for the urclock programmer to
enable it to protect the bootloader from being overwritten. If an unknown
bootloader has EEPROM read/write capability then the option <code>-x eepromrw</code>
informs <code>avrdude -c urclock</code> of that capability.
</p>
<a name="index-The-Bus-Pirate"></a>
<p>The BusPirate is a versatile tool that can also be used as an AVR programmer.
A single BusPirate can be connected to up to 3 independent AVRs. See
the section on
<em>extended parameters</em>
below for details.
</p>
<a name="index-CH341A-programmer"></a>
<p>The USBasp ISP, USBtinyISP and CH341A adapters are also supported, provided
AVRDUDE has been compiled with libusb support.
They former two feature simple firmware-only USB implementations, running on
an ATmega8 (or ATmega88), or ATtiny2313, respectively.
CH341A programmers connect directly to the AVR target. Their SPI bit clock
is approximately 1.7 MHz and cannot be changed. As a consequence, the
AVR target must have a CPU frequency of 6.8 MHz or more: factory-set
AVR parts, which typically run on an internal oscillator between 1 MHz and
1.6 MHz, cannot be programmed using <code>-c ch341a</code>.
</p>
<a name="index-FLIP-bootloader"></a>
<p>The Atmel DFU bootloader is supported in both, FLIP protocol version 1
(AT90USB* and ATmega*U* devices), as well as version 2 (Xmega devices).
See below for some hints about FLIP version 1 protocol behaviour.
</p>
<a name="index-MPLAB_0028R_0029-PICkit-4"></a>
<a name="index-MPLAB_0028R_0029-PICkit-5"></a>
<a name="index-MPLAB_0028R_0029-SNAP"></a>
<a name="index-PICkit-4"></a>
<a name="index-PICkit-5"></a>
<a name="index-SNAP"></a>
<p>The MPLAB(R) PICkit 4 and MPLAB(R) SNAP are supported in JTAG, TPI, ISP, PDI and UPDI mode.
<a name="index-Curiosity-nano"></a>
The Curiosity Nano board is supported in UPDI mode. It is dubbed &ldquo;PICkit on
Board&rdquo;, thus the name <code>pkobn_updi</code>.
The MPLAB(R) PICkit 5 is currently only supported in UPDI mode.
</p>
<a name="index-SerialUPDI"></a>
<p>SerialUPDI programmer implementation is based on Microchip&rsquo;s
<em>pymcuprog</em> (<a href="https://github.com/microchip-pic-avr-tools/pymcuprog">https://github.com/microchip-pic-avr-tools/pymcuprog</a>)
utility, but it also contains some performance improvements included in
Spence Konde&rsquo;s <em>DxCore</em> Arduino core (<a href="https://github.com/SpenceKonde/DxCore">https://github.com/SpenceKonde/DxCore</a>).
In a nutshell, this programmer consists of simple USB-to-UART adapter, diode
and couple of resistors. It uses serial connection to provide UPDI interface.
See section <a href="avrdude_22.html#SerialUPDI-Programmer">SerialUPDI Programmer</a> for more details and known issues.
</p>
<p>The jtag2updi programmer is supported,
and can program AVRs with a UPDI interface.
Jtag2updi is just a firmware that can be loaded onto an AVR,
which enables it to interface with avrdude using the jtagice mkii protocol
via a serial link (<a href="https://github.com/ElTangas/jtag2updi">https://github.com/ElTangas/jtag2updi</a>).
</p>
<a name="index-Micronucleus-bootloader"></a>
<a name="index-flash-2"></a>
<p>The Micronucleus bootloader is supported for both protocol version V1 and
V2. As the bootloader does not support reading from flash memory, use the
<code>-V</code> option to prevent AVRDUDE from verifying the flash memory. See
the section on <em>extended parameters</em> below for Micronucleus specific
options.
</p>
<a name="index-Teensy-bootloader"></a>
<a name="index-flash-3"></a>
<p>The Teensy bootloader is supported for all AVR boards.
As the bootloader does not support reading from flash memory,
use the <code>-V</code> option to prevent AVRDUDE from verifying the flash memory.
See the section on <em>extended parameters</em>
below for Teensy specific options.
</p>
<p><a href="avrdude_44.html#List-of-Programmers">List of Programmers</a> holds a full listing of known programmers.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="avrdude_2.html#History">1.1 History and Credits</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="avrdude.html#Top" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_2.html#History" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[ &lt;&lt; ]</td>
<td valign="middle" align="left">[<a href="avrdude.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="avrdude_3.html#Command-Line-Options" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="avrdude.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_50.html#Index" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="avrdude_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Stefan Rueger</em> on <em>August 24, 2024</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.82</em></a>.
 </font>
 <br>

</p>
</body>
</html>
