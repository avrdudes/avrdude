%% -*-texinfo-*-
\input texinfo

@c $Id$

@setfilename avrdude.info
@settitle AVRDUDE
@finalout

@include version.texi

@c
@c These are set in version.texi which is automatically generated by automake.
@c
@c @set UPDATED 26 Febuary 2003
@c @set EDITION 3.2.0
@c @set VERSION 3.2.0

@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.
@dircategory AVR Programming & development tools.
@direntry
* AvrDude: (avrdude).            AVR program downloader/uploader.
@end direntry

@ifinfo
This file documents the avrdude program.

For avrdude version @value{VERSION}, @value{UPDATED}.

Copyright @copyright{} 2003, 2005, 2006 Brian Dean

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end ifinfo

@titlepage
@title AVRDUDE
@subtitle A program for download/uploading AVR microcontroller flash and eeprom.
@subtitle For AVRDUDE, Version @value{VERSION}, @value{UPDATED}.
@author by Brian S. Dean

@page
Send comments on AVRDUDE to @w{@email{avrdude-dev@@nongnu.org}}.

Use @uref{http://savannah.nongnu.org/bugs/?group=avrdude} to report bugs.

Copyright @copyright{} 2003,2005 Brian S. Dean
@sp 2

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end titlepage

@contents

@c
@c Top Node
@c
@node Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up

@ifinfo
This file documents the avrdude program for downloading/uploading
programs to Atmel AVR microcontrollers.

For avrdude version @value{VERSION}, @value{UPDATED}.

Send comments on AVRDUDE to @w{@email{avrdude-dev@@nongnu.org}}.

Use @uref{http://savannah.nongnu.org/bugs/?group=avrdude} to report bugs.

Copyright @copyright{} 2003,2005 Brian S. Dean
@end ifinfo

@menu
* Introduction::                
* Command Line Options::
* Terminal Mode Operation::
* Configuration File::          
* Platform Dependent Information::
* Troubleshooting::
@end menu

@c
@c Node
@c
@node Introduction, Command Line Options, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction
@cindex introduction

AVRDUDE - AVR Downloader Uploader - is a program for downloading and
uploading the on-chip memories of Atmel's AVR microcontrollers. It can
program the Flash and EEPROM, and where supported by the serial
programming protocol, it can program fuse and lock bits. AVRDUDE also
supplies a direct instruction mode allowing one to issue any programming
instruction to the AVR chip regardless of whether AVRDUDE implements
that specific feature of a particular chip.

AVRDUDE can be used effectively via the command line to read or write
all chip memory types (eeprom, flash, fuse bits, lock bits, signature
bytes) or via an interactive (terminal) mode. Using AVRDUDE from the
command line works well for programming the entire memory of the chip
from the contents of a file, while interactive mode is useful for
exploring memory contents, modifing individual bytes of eeprom,
programming fuse/lock bits, etc.

AVRDUDE supports the following basic programmer types: Atmel's STK500,
Atmel's AVRISP and AVRISP mkII devices,
Atmel's JTAG ICE (both mkI and mkII), appnote
avr910, appnote avr109 (including the AVR Butterfly),
serial bit-bang adapters,
and the PPI (parallel port interface). PPI represents a class
of simple programmers where the programming lines are directly
connected to the PC parallel port. Several pin configurations exist
for several variations of the PPI programmers, and AVRDUDE can be be
configured to work with them by either specifying the appropriate
programmer on the command line or by creating a new entry in its
configuration file. All that's usually required for a new entry is to
tell AVRDUDE which pins to use for each programming function.

A number of equally simple bit-bang programming adapters that connect
to a serial port are supported as well, among them the popular
Ponyprog serial adapter, and the DASA and DASA3 adapters that used to
be supported by uisp(1).  Note that these adapters are meant to be
attached to a physical serial port.  Connecting to a serial port
emulated on top of USB is likely to not work at all, or to work
abysmally slow.

The STK500, JTAG ICE, avr910, and avr109/butterfly use the serial port to communicate with the PC.
The STK500, JTAG ICE, and avr910 contain on-board logic to control the programming of the target
device.
The avr109 bootloader implements a protocol similar to avr910, but is
actually implemented in the boot area of the target's flash ROM, as
opposed to being an external device.
The fundamental difference between the two types lies in the
protocol used to control the programmer. The avr910 protocol is very
simplistic and can easily be used as the basis for a simple, home made
programer since the firmware is available online. On the other hand,
the STK500 protocol is more robust and complicated and the firmware is
not openly available.
The JTAG ICE also uses a serial communication protocol which is similar
to the STK500 firmware version 2 one.  However, as the JTAG ICE is
intented to allow on-chip debugging as well as memory programming, the
protocol is more sophisticated.
(The JTAG ICE mkII protocol can also be run on top of USB.)
Only the memory programming functionality of the JTAG ICE is supported
by AVRDUDE.

@menu
* History::                     
@end menu

@c
@c Node
@c
@node History,  , Introduction, Introduction
@section History and Credits

AVRDUDE was written by Brian S. Dean under the name of AVRPROG to run on
the FreeBSD Operating System.  Brian renamed the software to be called
AVRDUDE when interest grew in a Windows port of the software so that the
name did not conflict with AVRPROG.EXE which is the name of Atmel's
Windows programming software.

The AVRDUDE source now resides in the public CVS repository on
savannah.gnu.org (@url{http://savannah.gnu.org/projects/avrdude/}),
where it continues to be enhanced and ported to other systems.  In
addition to FreeBSD, AVRDUDE now runs on Linux and Windows.  The
developers behind the porting effort primarily were Ted Roth, Eric
Weddington, and Joerg Wunsch.

And in the spirit of many open source projects, this manual also draws
on the work of others.  The initial revision was composed of parts of
the original Unix manual page written by Joerg Wunsch, the original web
site documentation by Brian Dean, and from the comments describing the
fields in the AVRDUDE configuration file by Brian Dean.  The texi
formatting was modeled after that of the Simulavr documentation by Ted
Roth.


@c
@c Node
@c
@node Command Line Options, Terminal Mode Operation, Introduction, Top
@chapter Command Line Options
@cindex options

@menu
* Option Descriptions::
* Example Command Line Invocations::
@end menu

@c
@c Node
@c
@node Option Descriptions, Example Command Line Invocations, Command Line Options, Command Line Options
@section Option Descriptions

@noindent
AVRDUDE is a command line tool, used as follows:

@smallexample
avrdude -p partno @var{options} @dots{}
@end smallexample

@noindent
Command line options are used to control AVRDUDE's behaviour.  The
following options are recognized:

@table @code
@item -p @var{partno}
This is the only mandatory option and it tells AVRDUDE what type of part
(MCU) that is connected to the programmer.  The @var{partno} parameter
is the part's id listed in the configuration file.  Specify -p ? to list
all parts in the configuration file.  If a part is unknown
to AVRDUDE, it means that there is no config file entry for that part,
but it can be added to the configuration file if you have the Atmel
datasheet so that you can enter the programming specifications.
Currently, the following MCU types are understood:

@table @code
@itemx c128
AT90CAN128

@itemx pwm2
AT90PWM2

@itemx pwm3
AT90PWM3

@itemx 1200
AT90S1200

@itemx 2313
AT90S2313

@itemx 2333
AT90S2333

@itemx 2343
AT90S2343 (*)

@itemx 4414
AT90S4414

@itemx 4433
AT90S4433

@itemx 4434
AT90S4434

@itemx 8515
AT90S8515

@itemx 8535
AT90S8535

@itemx m103
ATmega103

@itemx m128
ATmega128

@itemx m1280
ATmega1280

@itemx m1281
ATmega1281

@itemx m16
ATmega16

@itemx m161
ATmega161

@itemx m162
ATmega162

@itemx m163
ATmega163

@itemx m164
ATmega164

@itemx m169
ATmega169

@itemx m2560
ATmega2560 (**)

@itemx m2561
ATmega2561 (**)

@itemx m32
ATmega32

@itemx m324
ATmega324

@itemx m329
ATmega329

@itemx m3290
ATmega3290

@itemx m48
ATmega48

@itemx m64
ATmega64

@itemx m640
ATmega640

@itemx m644
ATmega644

@itemx m649
ATmega649

@itemx m6490
ATmega6490

@itemx m8
ATmega8

@itemx m8515
ATmega8515

@itemx m8535
ATmega8535

@itemx m88
ATmega88

@itemx t12
ATtiny12

@itemx t13
ATtiny13

@itemx t15
ATtiny15

@itemx t2313
ATtiny2313

@itemx t25
ATtiny25

@itemx t26
ATtiny26

@itemx t45
ATtiny45

@itemx t85
ATtiny85

@end table

(*)   The AT90S2323 and ATtiny22 use the same algorithm.

(**)  Flash addressing above 128 KB is not supported by all
programming hardware.  Known to work are jtag2, stk500v2,
and bit-bang programmers.

@item -b @var{baudrate}
Override the RS-232 connection baud rate specified in the respective
programmer's entry of the configuration file.

@item -B @var{bitclock}
Specify the bit clock period for the JTAG interface (JTAG ICE only).
The value is a floating-point number in microseconds.
The default value of the JTAG ICE results in about 1 microsecond bit
clock period, suitable for target MCUs running at 4 MHz clock and
above.
Unlike certain parameters in the STK500, the JTAG ICE resets all its
parameters to default values when the programming software signs
off from the ICE, so for MCUs running at lower clock speeds, this
parameter must be specified on the command-line.

@item -c @var{programmer-id}
Specify the programmer to be used.  AVRDUDE knows about several common
programmers.  Use this option to specify which one to use.  The
@var{programmer-id} parameter is the programmer's id listed in the
configuration file.  Specify -c ? to list all programmers in the
configuration file.  If you have a programmer that is unknown to
AVRDUDE, and the programmer is controlled via the PC parallel port,
there's a good chance that it can be easily added to the configuration
file without any code changes to AVRDUDE.  Simply copy an existing entry
and change the pin definitions to match that of the unknown programmer.
Currently, the following programmer ids are understood and supported:

@table @code

@itemx abcmini
ABCmini Board, aka Dick Smith HOTCHIP

@itemx alf
Nightshade ALF-PgmAVR, http://nightshade.homeip.net/

@itemx avr109
Atmel AppNote AVR109 Boot Loader

@itemx avr910
Atmel Low Cost Serial Programmer

@itemx avr911
Atmel AppNote AVR911 AVROSP (an alias for avr109)

@itemx avrisp
Atmel AVR ISP (an alias for stk500)

@itemx avrispv2
Atmel AVR ISP, running a version 2.x firmware (an alias for stk500v2)

@itemx avrispmkII
Atmel AVR ISP mkII (alias for stk500v2)

@itemx avrispmk2
Atmel AVR ISP mkII (alias for stk500v2)

@itemx bascom
Bascom SAMPLE programming cable

@itemx bsd
Brian Dean's Programmer, http://www.bsdhome.com/avrdude/

@itemx butterfly
Atmel Butterfly Development Board

@itemx dt006
Dontronics DT006

@item jtagmkI
@itemx jtag1
Atmel JTAG ICE mkI, running at 115200 Bd

@itemx jtag1slow
Atmel JTAG ICE mkI, running at 19200 Bd

@item jtagmkII
@itemx jtag2slow
Atmel JTAG ICE mkII (default speed 19200 Bd)

@itemx jtag2fast
Atmel JTAG ICE mkII, running at 115200 Bd

@itemx jtag2
Same as before.

@itemx pavr
Jason Kyle's pAVR Serial Programmer

@itemx picoweb
Picoweb Programming Cable, http://www.picoweb.net/

@itemx pony-stk200
Pony Prog STK200

@itemx sp12
Steve Bolt's Programmer

@itemx stk200
STK200

@itemx stk500
Atmel STK500

@itemx stk500pp
Atmel STK500 in parallel programming mode (version 2.x
firmware only)

@itemx stk500v2
Atmel STK500, running a version 2.x firmware

@end table



@item -C @var{config-file}
Use the specified config file for configuration data.  This file
contains all programmer and part definitions that AVRDUDE knows about.
If you have a programmer or part that AVRDUDE does not know about, you
can add it to the config file (be sure and submit a patch back to the
author so that it can be incorporated for the next version).  If not
specified, AVRDUDE reads the configuration file from
/usr/local/etc/avrdude.conf (FreeBSD and Linux). See Appendix A for
the method of searching for the configuration file for Windows.

@item -D
Disable auto erase for flash.  When the -U option with flash memory is 
specified, avrdude will perform a chip erase before starting any of the 
programming operations, since it generally is a mistake to program the flash
without performing an erase first.  This option disables that.  However, to 
remain backward compatible, the -i, and -m options automatically disable the 
auto erase feature.

@item -e
Causes a chip erase to be executed.  This will reset the contents of the
flash ROM and EEPROM to the value `0xff', and is basically a
prerequisite command before the flash ROM can be reprogrammed again.
The only exception would be if the new contents would exclusively cause
bits to be programmed from the value `1' to `0'.  Note that in order
to reprogram EERPOM cells, no explicit prior chip erase is required
since the MCU provides an auto-erase cycle in that case before
programming the cell.


@item -E @var{exitspec}[,@dots{}]
By default, AVRDUDE leaves the parallel port in the same state at exit
as it has been found at startup.  This option modifies the state of the
`/RESET' and `Vcc' lines the parallel port is left at, according to
the exitspec arguments provided, as follows:

@table @code
@itemx reset
The `/RESET' signal will be left activated at program exit, that is it
will be held low, in order to keep the MCU in reset state afterwards.
Note in particular that the programming algorithm for the AT90S1200
device mandates that the `/RESET' signal is active before powering up
the MCU, so in case an external power supply is used for this MCU type,
a previous invocation of AVRDUDE with this option specified is one of
the possible ways to guarantee this condition.

@itemx noreset
The `/RESET' line will be deactivated at program exit, thus allowing the
MCU target program to run while the programming hardware remains
connected.

@itemx vcc
This option will leave those parallel port pins active (i. e. high) that
can be used to supply `Vcc' power to the MCU.

@itemx novcc
This option will pull the `Vcc' pins of the parallel port down at
program exit.

@end table

Multiple @var{exitspec} arguments can be separated with commas.


@item -F
Normally, AVRDUDE tries to verify that the device signature read from
the part is reasonable before continuing.  Since it can happen from time
to time that a device has a broken (erased or overwritten) device
signature but is otherwise operating normally, this options is provided
to override the check.

@item -n
No-write - disables actually writing data to the MCU (useful for
debugging AVRDUDE).

@item -P @var{port}
Use port to identify the device to which the programmer is attached.
Normally, the default parallel port is used, but if the programmer type
normally connects to the serial port, the default serial port will be
used. See Appendix A, Platform Dependent Information, to find out the
default port names for your platform. If you need to use a different
parallel or serial port, use this option to specify the alternate port name.

For the JTAG ICE mkII, if AVRDUDE has been built with libusb support,
@var{port} may alternatively be specified as
@var{usb}[:@var{serialno}].  In that case, the JTAG ICE mkII will be
looked up on USB.  If @var{serialno} is also specified, it will be
matched against the serial number read from any JTAG ICE mkII found on
USB.  The match is done after stripping any existing colons from the
given serial number, and right-to-left, so only the least significant
bytes from the serial number need to be given.
For a trick how to find out the serial numbers of all JTAG ICEs
attached to USB, see @ref{Example Command Line Invocations}.

As the AVRISP mkII device can only be talked to over USB, the very
same method of specifying the port is required there.

@item -q
Disable (or quell) output of the progress bar while reading or writing
to the device.  Specify it a second time for even quieter operation.

@item -u
Disables the default behaviour of reading out the fuses three times before
programming, then verifying at the end of programming that the fuses have not
changed. If you want to change fuses you will need to specify this option,
as avrdude will see the fuses have changed (even though you wanted to) and
will change them back for your "saftey". This option was designed to
prevent cases of fuse bits magically changing (usually called @emph{safemode}).

@item -t
Tells AVRDUDE to enter the interactive ``terminal'' mode instead of up-
or downloading files.  See below for a detailed description of the
terminal mode.

@item -U @var{memtype}:@var{op}:@var{filename}[:@var{format}]
Perform a memory operation, equivalent to specifing the @option{-m},
@option{-i} or @option{-o}, and @option{-f} options, except that
multiple @option{-U} optins can be specified in order to operate on
mulitple memories on the same command-line invocation.  The
@var{memtype} field specifies the memory type to operate on. Use
the @option{-v} option on the command line or the @code{part} command from
terminal mode to display all the memory types supported by a particular
device.
Typically, a device's memory configuration at least contains
the memory types
@code{flash}
and
@code{eeprom}.
All memory types currently known are:
@table @code
@item calibration
One or more bytes of RC oscillator calibration data.
@item eeprom
The EEPROM of the device.
@item efuse
The extended fuse byte.
@item flash
The flash ROM of the device.
@item fuse
The fuse byte in devices that have only a single fuse byte.
@item hfuse
The high fuse byte.
@item lfuse
The low fuse byte.
@item lock
The lock byte.
@item signature
The three device signature bytes (device ID).
@end table

The @var{op} field specifies what operation to perform:

@table @code
@itemx r
read the specified device memory and write to the specified file

@itemx w
read the specified file and write it to the specified device memory

@itemx v
read the specified device memory and the specified file and perform a verify operation

@end table

The @var{filename} field indicates the name of the file to read or
write.  The @var{format} field is optional and contains the format of
the file to read or write.  Possible values are:

@table @code
@itemx i
Intel Hex

@itemx s
Motorola S-record

@itemx r
raw binary; little-endian byte order, in the case of the flash ROM data

@itemx m
immediate mode; actual byte values specified on the command line,
seperated by commas or spaces in place of the @var{filename} field of
the @option{-i}, @option{-o}, or @option{-U} options.  This is useful
for programming fuse bytes without having to create a single-byte file
or enter terminal mode.  If the number specified begins with @code{0x},
it is treated as a hex value.  If the number otherwise begins with a
leading zero (@code{0}) it is treated as octal.  Otherwise, the value is
treated as decimal.

@itemx a
auto detect; valid for input only, and only if the input is not provided
at stdin.

@end table

The default is to use auto detection for input files, and raw binary
format for output files.

Note that if @var{filename} contains a colon, the @var{format} field is
no longer optional since the filename part following the colon would
otherwise be misinterpreted as @var{format}.

@item -v
Enable verbose output.

@item -V
Disable automatic verify check when uploading data.

@item -y
Tells AVRDUDE to use the last four bytes of the connected parts' EEPROM
memory to track the number of times the device has been erased.  When
this option is used and the @option{-e} flag is specified to generate a
chip erase, the previous counter will be saved before the chip erase, it
is then incremented, and written back after the erase cycle completes.
Presumably, the device would only be erased just before being
programmed, and thus, this can be utilized to give an indication of how
many erase-rewrite cycles the part has undergone.  Since the FLASH
memory can only endure a finite number of erase-rewrite cycles, one can
use this option to track when a part is nearing the limit.  The typical
limit for Atmel AVR FLASH is 1000 cycles.  Of course, if the
application needs the last four bytes of EEPROM memory, this option
should not be used.

@item -Y @var{cycles}
Instructs AVRDUDE to initialize the erase-rewrite cycle counter residing
at the last four bytes of EEPROM memory to the specified value.  If the
application needs the last four bytes of EEPROM memory, this option
should not be used.

@end table

@page
@c
@c Node
@c
@node Example Command Line Invocations,  , Option Descriptions, Command Line Options
@section Example Command Line Invocations

@noindent
Download the file @code{diag.hex} to the ATmega128 chip using the
STK500 programmer connected to the default serial port:

@smallexample
@cartouche
% avrdude -p m128 -c stk500 -e -U flash:w:diag.hex 

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.03s

avrdude: Device signature = 0x1e9702
avrdude: erasing chip
avrdude: done.
avrdude: performing op: 1, flash, 0, diag.hex
avrdude: reading input file "diag.hex"
avrdude: input file diag.hex auto detected as Intel Hex
avrdude: writing flash (19278 bytes):

Writing | ################################################## | 100% 7.60s

avrdude: 19456 bytes of flash written
avrdude: verifying flash memory against diag.hex:
avrdude: load data flash data from input file diag.hex:
avrdude: input file diag.hex auto detected as Intel Hex
avrdude: input file diag.hex contains 19278 bytes
avrdude: reading on-chip flash data:

Reading | ################################################## | 100% 6.83s

avrdude: verifying ...
avrdude: 19278 bytes of flash verified

avrdude: safemode: Fuses OK

avrdude done.  Thank you.

%
@end cartouche
@end smallexample

@page
@noindent
Upload the flash memory from the ATmega128 connected to the STK500
programmer and save it in raw binary format in the file named
@code{c:/diag flash.bin}:

@smallexample
@cartouche
% avrdude -p m128 -c stk500 -U flash:r:"c:/diag flash.bin":r 

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.03s

avrdude: Device signature = 0x1e9702
avrdude: reading flash memory:

Reading | ################################################## | 100% 46.10s

avrdude: writing output file "c:/diag flash.bin"

avrdude: safemode: Fuses OK

avrdude done.  Thank you.

% 
@end cartouche
@end smallexample

@page
@noindent
Using the default programmer, download the file @code{diag.hex} to
flash, @code{eeprom.hex} to EEPROM, and set the Extended, High, and Low
fuse bytes to 0xff, 0x89, and 0x2e respectively:

@smallexample
@cartouche

% avrdude -p m128 -u -U flash:w:diag.hex \
>                 -U eeprom:w:eeprom.hex \
>                 -U efuse:w:0xff:m      \
>                 -U hfuse:w:0x89:m      \
>                 -U lfuse:w:0x2e:m

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.03s

avrdude: Device signature = 0x1e9702
avrdude: NOTE: FLASH memory has been specified, an erase cycle will be performed
         To disable this feature, specify the -D option.
avrdude: erasing chip
avrdude: reading input file "diag.hex"
avrdude: input file diag.hex auto detected as Intel Hex
avrdude: writing flash (19278 bytes):

Writing | ################################################## | 100% 7.60s

avrdude: 19456 bytes of flash written
avrdude: verifying flash memory against diag.hex:
avrdude: load data flash data from input file diag.hex:
avrdude: input file diag.hex auto detected as Intel Hex
avrdude: input file diag.hex contains 19278 bytes
avrdude: reading on-chip flash data:

Reading | ################################################## | 100% 6.84s

avrdude: verifying ...
avrdude: 19278 bytes of flash verified

[ ... other memory status output skipped for brevity ... ]

avrdude done.  Thank you.

% 
@end cartouche
@end smallexample

@page
@noindent
Connect to the JTAG ICE mkII which serial number ends up in 1C37 via
USB, and enter terminal mode:

@smallexample
@cartouche

% avrdude -c jtag2 -p m649 -P usb:1c:37 -t

avrdude: AVR device initialized and ready to accept instructions

Reading | ################################################## | 100% 0.03s

avrdude: Device signature = 0x1e9603

[ ... terminal mode output skipped for brevity ... ]

avrdude done.  Thank you.

@end cartouche
@end smallexample

@noindent
List the serial numbers of all JTAG ICEs attached to USB.  This is
done by specifying an invalid serial number, and increasing the
verbosity level.

@smallexample
@cartouche

% avrdude -c jtag2 -p m128 -P usb:xx -v
[...]
         Using Port            : usb:xxx
         Using Programmer      : jtag2
avrdude: usbdev_open(): Found JTAG ICE, serno: 00A000001C6B
avrdude: usbdev_open(): Found JTAG ICE, serno: 00A000001C3A
avrdude: usbdev_open(): Found JTAG ICE, serno: 00A000001C30
avrdude: usbdev_open(): did not find any (matching) USB device "usb:xxx"

@end cartouche
@end smallexample


@c
@c Node
@c
@node Terminal Mode Operation, Configuration File, Command Line Options, Top
@chapter Terminal Mode Operation

AVRDUDE has an interactive mode called @var{terminal mode} that is
enabled by the @option{-t} option.  This mode allows one to enter
interactive commands to display and modify the various device memories,
perform a chip erase, display the device signature bytes and part
parameters, and to send raw programming commands.  Commands and
parameters may be abbreviated to their shortest unambiguous form.
Terminal mode also supports a command history so that previously entered
commands can be recalled and edited.

@menu
* Terminal Mode Commands::      
* Terminal Mode Examples::      
@end menu

@node Terminal Mode Commands, Terminal Mode Examples, Terminal Mode Operation, Terminal Mode Operation
@section Terminal Mode Commands

@noindent
The following commands are implemented:

@table @code

@item dump @var{memtype} @var{addr} @var{nbytes}
Read @var{nbytes} from the specified memory area, and display them in
the usual hexadecimal and ASCII form.

@item dump
Continue dumping the memory contents for another @var{nbytes} where the
previous dump command left off.

@item write @var{memtype} @var{addr} @var{byte1} @dots{} @var{byteN}
Manually program the respective memory cells, starting at address addr,
using the values @var{byte1} through @var{byteN}.  This feature is not
implemented for bank-addressed memories such as the flash memory of
ATMega devices.

@item erase
Perform a chip erase.

@item send @var{b1} @var{b2} @var{b3} @var{b4}
Send raw instruction codes to the AVR device.  If you need access to a
feature of an AVR part that is not directly supported by AVRDUDE, this
command allows you to use it, even though AVRDUDE does not implement the
command.

@item sig
Display the device signature bytes.

@item part
Display the current part settings and parameters.  Includes chip
specific information including all memory types supported by the
device, read/write timing, etc.

@item ?
@itemx help
Give a short on-line summary of the available commands.

@item quit
Leave terminal mode and thus AVRDUDE.

@end table

@noindent
In addition, the following commands are supported on the STK500
programmer:

@table @code

@item vtarg @var{voltage}
Set the target's supply voltage to @var{voltage} Volts.

@item varef @var{voltage}
Set the adjustable voltage source to @var{voltage} Volts.
This voltage is normally used to drive the target's
@emph{Aref} input on the STK500.

@item fosc @var{freq}[@var{M}|@var{k}]
Set the master oscillator to @var{freq} Hz.
An optional trailing letter @var{M}
multiplies by 1E6, a trailing letter @var{k} by 1E3.

@item fosc off
Turn the master oscillator off.

@item sck @var{period}
@emph{STK500 only:}
Set the SCK clock period to @var{period} microseconds.

@emph{JTAG ICE only:}
Set the JTAG ICE bit clock period to @var{period} microseconds.
Note that unlike STK500 settings, this setting will be reverted to
its default value (approximately 1 microsecond) when the programming
software signs off from the JTAG ICE.

@item parms
@emph{STK500 only:}
Display the current voltage and master oscillator parameters.

@emph{JTAG ICE only:}
Display the current target supply voltage and JTAG bit clock rate/period.

@end table

@c
@c Node
@c
@node Terminal Mode Examples,  , Terminal Mode Commands, Terminal Mode Operation
@section Terminal Mode Examples

@noindent
Display part parameters, modify eeprom cells, perform a chip erase:

@smallexample
@cartouche
% avrdude -p m128 -c stk500 -t

avrdude: AVR device initialized and ready to accept instructions
avrdude: Device signature = 0x1e9702
avrdude: current erase-rewrite cycle count is 52 (if being tracked)
avrdude> part
>>> part 

AVR Part              : ATMEGA128
Chip Erase delay      : 9000 us
PAGEL                 : PD7
BS2                   : PA0
RESET disposition     : dedicated
RETRY pulse           : SCK
serial program mode   : yes
parallel program mode : yes
Memory Detail         :

                            Page                       Polled
  Memory Type Paged  Size   Size #Pages MinW  MaxW   ReadBack
  ----------- ------ ------ ---- ------ ----- ----- ---------
  eeprom      no       4096    8     0  9000  9000 0xff 0xff
  flash       yes    131072  256   512  4500  9000 0xff 0x00
  lfuse       no          1    0     0     0     0 0x00 0x00
  hfuse       no          1    0     0     0     0 0x00 0x00
  efuse       no          1    0     0     0     0 0x00 0x00
  lock        no          1    0     0     0     0 0x00 0x00
  calibration no          1    0     0     0     0 0x00 0x00
  signature   no          3    0     0     0     0 0x00 0x00

avrdude> dump eeprom 0 16
>>> dump eeprom 0 16 
0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> write eeprom 0 1 2 3 4
>>> write eeprom 0 1 2 3 4 

avrdude> dump eeprom 0 16
>>> dump eeprom 0 16 
0000  01 02 03 04 ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> erase
>>> erase 
avrdude: erasing chip
avrdude> dump eeprom 0 16
>>> dump eeprom 0 16 
0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> 
@end cartouche
@end smallexample


@noindent
Program the fuse bits of an ATmega128 (disable M103 compatibility,
enable high speed external crystal, enable brown-out detection, slowly
rising power).  Note since we are working with fuse bits the -u (unsafe)
option is specified, which allows you to modify the fuse bits. First 
display the factory defaults, then reprogram:

@smallexample
@cartouche
% avrdude -p m128 -u -c stk500 -t

avrdude: AVR device initialized and ready to accept instructions
avrdude: Device signature = 0x1e9702
avrdude: current erase-rewrite cycle count is 52 (if being tracked)
avrdude> d efuse
>>> d efuse 
0000  fd                                                |.               |

avrdude> d hfuse
>>> d hfuse 
0000  99                                                |.               |

avrdude> d lfuse
>>> d lfuse 
0000  e1                                                |.               |

avrdude> w efuse 0 0xff
>>> w efuse 0 0xff 

avrdude> w hfuse 0 0x89
>>> w hfuse 0 0x89 

avrdude> w lfuse 0 0x2f
>>> w lfuse 0 0x2f 

avrdude> 
@end cartouche
@end smallexample


@c
@c Node
@c
@node Configuration File, Platform Dependent Information, Terminal Mode Operation, Top
@chapter Configuration File

@noindent
AVRDUDE reads a configuration file upon startup which describes all of
the parts and programmers that it knows about.  The advantage of this is
that if you have a chip that is not currently supported by AVRDUDE, you
can add it to the configuration file without waiting for a new release
of AVRDUDE.  Likewise, if you have a parallel port programmer that is
not supported by AVRDUDE, chances are good that you can copy and
existing programmer definition, and with only a few changes, make your
programmer work with AVRDUDE.

AVRDUDE first looks for a system wide configuration file in a platform
dependent location.  On Unix, this is usually
@code{/usr/local/etc/avrdude.conf}, while on Windows it is usally in the
same location as the executable file.  The name of this file can be
changed using the @option{-C} command line option.  After the system wide
configuration file is parsed, AVRDUDE looks for a per-user configuration
file to augment or override the system wide defaults.  On Unix, the
per-user file is @code{.avrduderc} within the user's home directory.  On
Windows, this file is the @code{avrdude.rc} file located in the same
directory as the executable.

@menu
* AVRDUDE Defaults::            
* Programmer Definitions::      
* Part Definitions::            
* Other Notes::                 
@end menu

@c
@c Node
@c
@node AVRDUDE Defaults, Programmer Definitions, Configuration File, Configuration File
@section AVRDUDE Defaults

@table @code

@item default_parallel = "@var{default-parallel-device}";
Assign the default parallel port device.  Can be overidden using the
@option{-P} option.

@item default_serial = "@var{default-serial-device}";
Assign the default serial port device.  Can be overidden using the
@option{-P} option.

@item default_programmer = "@var{default-programmer-id}";
Assign the default programmer id.  Can be overidden using the @option{-c}
option.

@end table


@c
@c Node
@c
@node Programmer Definitions, Part Definitions, AVRDUDE Defaults, Configuration File
@section Programmer Definitions

@noindent
The format of the programmer definition is as follows:

@smallexample
programmer
    id     = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings
    desc     = <description> ;                  # quoted string
    type     = par | stk500 ;                   # programmer type
    baudrate = <num> ;                          # baudrate for serial ports
    vcc      = <num1> [, <num2> ... ] ;         # pin number(s)
    reset    = <num> ;                          # pin number
    sck      = <num> ;                          # pin number
    mosi     = <num> ;                          # pin number
    miso     = <num> ;                          # pin number
    errled   = <num> ;                          # pin number
    rdyled   = <num> ;                          # pin number
    pgmled   = <num> ;                          # pin number
    vfyled   = <num> ;                          # pin number
  ;
@end smallexample


@c
@c Node
@c
@node Part Definitions, Other Notes, Programmer Definitions, Configuration File
@section Part Definitions

@smallexample
part
    id               = <id> ;                 # quoted string
    desc             = <description> ;        # quoted string
    devicecode       = <num> ;                # numeric
    chip_erase_delay = <num> ;                # micro-seconds
    pagel            = <num> ;                # pin name in hex, i.e., 0xD7
    bs2              = <num> ;                # pin name in hex, i.e., 0xA0
    reset            = dedicated | io;
    retry_pulse      = reset | sck;
    pgm_enable       = <instruction format> ;
    chip_erase       = <instruction format> ;
    memory <memtype>
        paged           = <yes/no> ;          # yes / no
        size            = <num> ;             # bytes
        page_size       = <num> ;             # bytes
        num_pages       = <num> ;             # numeric
        min_write_delay = <num> ;             # micro-seconds
        max_write_delay = <num> ;             # micro-seconds
        readback_p1     = <num> ;             # byte value
        readback_p2     = <num> ;             # byte value
        pwroff_after_write = <yes/no> ;       # yes / no
        read            = <instruction format> ;
        write           = <instruction format> ;
        read_lo         = <instruction format> ;
        read_hi         = <instruction format> ;
        write_lo        = <instruction format> ;
        write_hi        = <instruction format> ;
        loadpage_lo     = <instruction format> ;
        loadpage_hi     = <instruction format> ;
        writepage       = <instruction format> ;
      ;
  ;
@end smallexample

@menu
* Instruction Format::
@end menu

@c
@c Node
@c
@node Instruction Format,  , Part Definitions, Part Definitions
@subsection Instruction Format

@noindent
Instruction formats are specified as a comma seperated list of string
values containing information (bit specifiers) about each of the 32 bits
of the instruction.  Bit specifiers may be one of the following formats:

@table @code

@item 1
The bit is always set on input as well as output

@item 0
the bit is always clear on input as well as output

@item x
the bit is ignored on input and output

@item a
the bit is an address bit, the bit-number matches this bit specifier's
position within the current instruction byte

@item a@var{N}
the bit is the @var{N}th address bit, bit-number = N, i.e., @code{a12}
is address bit 12 on input, @code{a0} is address bit 0.

@item i
the bit is an input data bit

@item o
the bit is an output data bit

@end table

Each instruction must be composed of 32 bit specifiers.  The instruction
specification closely follows the instruction data provided in Atmel's
data sheets for their parts.  For example, the EEPROM read and write
instruction for an AT90S2313 AVR part could be encoded as:

@smallexample

read  = "1  0  1  0   0  0  0  0   x x x x  x x x x",
        "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

write = "1  1  0  0   0  0  0  0   x x x x  x x x x",
        "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

@end smallexample



@c
@c Node
@c
@node Other Notes,  , Part Definitions, Configuration File
@section Other Notes


@itemize @bullet
@item
The @code{devicecode} parameter is the device code used by the STK500
and is obtained from the software section (@code{avr061.zip}) of
Atmel's AVR061 application note available from
@url{http://www.atmel.com/atmel/acrobat/doc2525.pdf}.

@item
Not all memory types will implement all instructions.

@item
AVR Fuse bits and Lock bits are implemented as a type of memory.

@item
Example memory types are: @code{flash}, @code{eeprom}, @code{fuse},
@code{lfuse} (low fuse), @code{hfuse} (high fuse), @code{efuse}
(extended fuse), @code{signature}, @code{calibration}, @code{lock}.

@item
The memory type specified on the AVRDUDE command line must match one of
the memory types defined for the specified chip.

@item
The @code{pwroff_after_write} flag causes AVRDUDE to attempt to power
the device off and back on after an unsuccessful write to the affected
memory area if VCC programmer pins are defined.  If VCC pins are not
defined for the programmer, a message indicating that the device needs a
power-cycle is printed out.  This flag was added to work around a
problem with the at90s4433/2333's; see the at90s4433 errata at:

         @url{http://www.atmel.com/atmel/acrobat/doc1280.pdf}

@item
The boot loader from application note AVR109 (and thus also the AVR
Butterfly) does not support writing of fuse bits.  Writing lock bits
is supported, but is restricted to the boot lock bits (BLBxx).  These
are restrictions imposed by the underlying SPM instruction that is used
to program the device from inside the boot loader.  Note that programming
the boot lock bits can result in a ``shoot-into-your-foot'' scenario as
the only way to unprogram these bits is a chip erase, which will also
erase the boot loader code.

The boot loader implements the ``chip erase'' function by erasing the
flash pages of the application section.

Reading fuse and lock bits is fully supported.

Note that due to the unability to write the fuse bits, the safemode
functionality does not make sense for these boot loaders.

@end itemize


@c
@c Node
@c
@node Platform Dependent Information, Troubleshooting, Configuration File, Top
@appendix Platform Dependent Information

@menu
* Unix::
* Windows::
@end menu

@c
@c Node
@c
@node Unix, Windows, Platform Dependent Information, Platform Dependent Information
@section Unix

@menu
* Unix Installation::           
* Unix Configuration Files::    
* Unix Port Names::             
* Unix Documentation::          
@end menu

@c
@c Node
@c
@node Unix Installation, Unix Configuration Files, Unix, Unix
@subsection Unix Installation

@noindent
To build and install from the source tarball on Unix like systems:

@example
$ gunzip -c avrdude-@value{VERSION}.tar.gz | tar xf -
$ cd avrdude-@value{VERSION}
$ ./configure
$ make
$ su root -c 'make install'
@end example

The default location of the install is into @code{/usr/local} so you
will need to be sure that @code{/usr/local/bin} is in your @code{PATH}
environment variable.

If you do not have root access to your system, you can do the the
following instead:

@example
$ gunzip -c avrdude-@value{VERSION}.tar.gz | tar xf -
$ cd avrdude-@value{VERSION}
$ ./configure --prefix=$HOME/local
$ make
$ make install
@end example

@menu
* FreeBSD Installation::        
* Linux Installation::          
@end menu

@c
@c Node
@c
@node FreeBSD Installation, Linux Installation, Unix Installation, Unix Installation
@subsubsection FreeBSD Installation

@noindent
AVRDUDE is installed via the FreeBSD Ports Tree as follows:

@example
% su - root
# cd /usr/ports/devel/avrdude
# make install
@end example

If you wish to install from a pre-built package instead of the source,
you can use the following instead:

@example
% su - root
# pkg_add -r avrdude
@end example

Of course, you must be connected to the Internet for these methods to
work, since that is where the source as well as the pre-built package is
obtained.

@c
@c Node
@c
@node Linux Installation,  , FreeBSD Installation, Unix Installation
@subsubsection Linux Installation

@noindent
On rpm based linux systems (such as RedHat, SUSE, Mandrake, etc), you
can build and install the rpm binaries directly from the tarball:

@example
$ su - root
# rpmbuild -tb avrdude-@value{VERSION}.tar.gz
# rpm -Uvh /usr/src/redhat/RPMS/i386/avrdude-@value{VERSION}-1.i386.rpm
@end example

Note that the path to the resulting rpm package, differs from system
to system. The above example is specific to RedHat.

@c
@c Node
@c
@node Unix Configuration Files, Unix Port Names, Unix Installation, Unix
@subsection Unix Configuration Files

@noindent
When AVRDUDE is build using the default @option{--prefix} configure
option, the default configuration file for a Unix system is located at
@code{/usr/local/etc/avrdude.conf}.  This can be overridden by using the
@option{-C} command line option.  Additionally, the user's home directory
is searched for a file named @code{.avrduderc}, and if found, is used to
augment the system default configuration file.

@menu
* FreeBSD Configuration Files::  
* Linux Configuration Files::   
@end menu

@c
@c Node
@c
@node FreeBSD Configuration Files, Linux Configuration Files, Unix Configuration Files, Unix Configuration Files
@subsubsection FreeBSD Configuration Files

@noindent
When AVRDUDE is installed using the FreeBSD ports system, the system
configuration file is always @code{/usr/local/etc/avrdude.conf}.

@c
@c Node
@c
@node Linux Configuration Files,  , FreeBSD Configuration Files, Unix Configuration Files
@subsubsection Linux Configuration Files

@noindent
When AVRDUDE is installed using from an rpm package, the system
configuration file will be always be @code{/etc/avrdude.conf}.

@c
@c Node
@c
@node Unix Port Names, Unix Documentation, Unix Configuration Files, Unix
@subsection Unix Port Names

@noindent
The parallel and serial port device file names are system specific.
The following table lists the default names for a given system.

@multitable @columnfractions .30 .30 .30
@item @strong{System}
  @tab @strong{Default Parallel Port}
  @tab @strong{Default Serial Port}
@item FreeBSD
  @tab @code{/dev/ppi0}
  @tab @code{/dev/cuaa0}
@item Linux
  @tab @code{/dev/parport0}
  @tab @code{/dev/ttyS0}
@item Solaris
  @tab @code{/dev/printers/0}
  @tab @code{/dev/term/a}
@end multitable

On FreeBSD systems, AVRDUDE uses the ppi(4) interface for
accessing the parallel port and the sio(4) driver for serial port
access.

On Linux systems, AVRDUDE uses the ppdev interface for
accessing the parallel port and the tty driver for serial port
access.

On Solaris systems, AVRDUDE uses the ecpp(7D) driver for
accessing the parallel port and the asy(7D) driver for serial port
access.

@c
@c Node
@c
@node Unix Documentation,  , Unix Port Names, Unix
@subsection Unix Documentation

@noindent
AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
@code{/usr/local/man/man1} area, while the HTML and PDF documentation
is installed in @code{/usr/local/share/doc/avrdude} directory.  The
info manual is installed in @code{/usr/local/info/avrdude.info}.

Note that these locations can be altered by various configure options
such as @option{--prefix}.

@c
@c Node
@c
@node Windows,  , Unix, Platform Dependent Information
@section Windows

@menu
* Windows Installation::        
* Windows Configuration Files::  
* Windows Port Names::          
* Using the parallel port::     
* Documentation::               
* Credits.::                    
@end menu

@c
@c Node
@c
@node Windows Installation, Windows Configuration Files, Windows, Windows
@subsection Installation

@noindent
A Windows executable of avrdude is included in WinAVR which can be found at
@url{http://sourceforge.net/projects/winavr}. WinAVR is a suite of executable, 
open source software development tools for the AVR for the Windows platform.

To build avrdude from the source You must have Cygwin (@url{http://www.cygwin.com/}).

To build and install from the source tarball for Windows (using Cygwin):

@example
$ set PREFIX=<your install directory path>
$ export PREFIX
$ gunzip -c avrdude-@value{VERSION}.tar.gz | tar xf -
$ cd avrdude-@value{VERSION}
$ ./configure LDFLAGS="-static" --prefix=$PREFIX --datadir=$PREFIX 
--sysconfdir=$PREFIX/bin --enable-versioned-doc=no
$ make
$ make install
@end example


@c
@c Node
@c
@node Windows Configuration Files, Windows Port Names, Windows Installation, Windows
@subsection Configuration Files

@menu
* Configuration file names::    
* How AVRDUDE finds the configuration files.::  
@end menu

@c
@c Node
@c
@node Configuration file names, How AVRDUDE finds the configuration files., Windows Configuration Files, Windows Configuration Files
@subsubsection Configuration file names

@noindent
AVRDUDE on Windows looks for a system configuration file name of
@code{avrdude.conf} and looks for a user override configuration file of
@code{avrdude.rc}.

@c
@c Node
@c
@node How AVRDUDE finds the configuration files.,  , Configuration file names, Windows Configuration Files
@subsubsection How AVRDUDE finds the configuration files.
 
@noindent
AVRDUDE on Windows has a different way of searching for the system and
user configuration files. Below is the search method for locating the
configuration files:

@enumerate

@item
The directory from which the application loaded.

@item
The current directory.

@item
The Windows system directory. On Windows NT, the name of this directory
is @code{SYSTEM32}.

@item
Windows NT: The 16-bit Windows system directory. The name of this
directory is @code{SYSTEM}.

@item
The Windows directory.

@item
The directories that are listed in the PATH environment variable.

@end enumerate


@c
@c Node
@c
@node Windows Port Names, Using the parallel port, Windows Configuration Files, Windows
@subsection Port Names

@menu
* Serial Ports::                
* Parallel Ports::              
@end menu

@c
@c Node
@c
@node Serial Ports, Parallel Ports, Windows Port Names, Windows Port Names
@subsubsection Serial Ports
 
@noindent
When you select a serial port (i.e. when using an STK500) use the
Windows serial port device names such as: com1, com2, etc.
 
@c
@c Node
@c
@node Parallel Ports,  , Serial Ports, Windows Port Names
@subsubsection Parallel Ports

@noindent
AVRDUDE will only accept 3 Windows parallel port names: lpt1, lpt2, or
lpt3.  Each of these names corresponds to a fixed parallel port base
address:

@table @code
@item lpt1
0x378

@item lpt2
0x278

@item lpt3
0x3BC

@end table

On your desktop PC, lpt1 will be the most common choice. If you are
using a laptop, you might have to use lpt3 instead of lpt1. Select the
name of the port the corresponds to the base address of the parallel
port that you want.


@c
@c Node
@c 
@node Using the parallel port, Documentation, Windows Port Names, Windows
@subsection Using the parallel port

@menu
* Windows NT/2K/XP::            
* Windows 95/98::               
@end menu

@c
@c Node
@c
@node Windows NT/2K/XP, Windows 95/98, Using the parallel port, Using the parallel port
@subsubsection Windows NT/2K/XP

@noindent
On Windows NT, 2000, and XP user applications cannot directly access the
parallel port. However, kernel mode drivers can access the parallel port.
giveio.sys is a driver that can allow user applications to set the state
of the parallel port pins.

Before using AVRDUDE, the giveio.sys driver must be loaded. The
accompanying command-line program, loaddrv.exe, can do just that.

To make things even easier there are 3 batch files that are also
included:

@enumerate
@item install_giveio.bat
Install and start the giveio driver.

@item status_giveio.bat
Check on the status of the giveio driver.

@item remove_giveio.bat
Stop and remove the giveio driver from memory.
@end enumerate

These 3 batch files calls the loaddrv program with various options to
install, start, stop, and remove the driver.

When you first execute install_giveio.bat, loaddrv.exe and giveio.sys
must be in the current directory. When install_giveio.bat is executed it
will copy giveio.sys from your current directory to your Windows
directory. It will then load the driver from the Windows directory. This
means that after the first time install_giveio is executed, you should 
be able to subsequently execute the batch file from any directory and have
it successfully start the driver.

Note that you must have administrator privilege to load the giveio driver.

@c
@c Node
@c
@node Windows 95/98,  , Windows NT/2K/XP, Using the parallel port
@subsubsection Windows 95/98

@noindent
On Windows 95 and 98 the giveio.sys driver is not needed.


@c
@c Node
@c
@node Documentation, Credits., Using the parallel port, Windows
@subsection Documentation

@noindent
AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
@code{/usr/local/man/man1} area, while the HTML and PDF documentation
is installed in @code{/usr/local/share/doc/avrdude} directory.  The
info manual is installed in @code{/usr/local/info/avrdude.info}.

Note that these locations can be altered by various configure options
such as @option{--prefix} and @option{--datadir}.


@c
@c Node
@c
@node Credits.,  , Documentation, Windows
@subsection Credits.

@noindent
Thanks to:

@itemize @bullet
@item
Dale Roberts for the giveio driver.

@item
Paula Tomlinson for the loaddrv sources.

@item
Chris Liechti <cliechti@@gmx.net> for modifying loaddrv to be command
line driven and for writing the batch files.

@end itemize

@c
@c Node
@c
@node Troubleshooting, ,Platform Dependent Information ,Top
@appendix Troubleshooting

@noindent
In general, please report any bugs encountered via
@*
@url{http://savannah.nongnu.org/bugs/?group=avrdude}.


@itemize @bullet

@item
Problem: I'm using a serial programmer under Windows and get the following
error:

@code{avrdude: serial_open(): can't set attributes for device "com1"},

Solution: This problem seems to appear with certain versions of Cygwin. Specifying
@code{"/dev/com1"} instead of @code{"com1"} should help.


@item
Problem: I'm using linux and my AVR910 programmer is really slow.

Solution (short): @code{setserial @var{port} low_latency}

Solution (long):
There are two problems here. First, the system may wait some time before it
passes data from the serial port to the program. Under Linux the following
command works around this (you may need root privileges for this).

@code{setserial @var{port} low_latency}

Secondly, the serial interface chip may delay the interrupt for some time.
This behaviour can be changed by setting the FIFO-threshold to one. Under Linux this
can only be done by changing the kernel source in @code{drivers/char/serial.c}.
Search the file for @code{UART_FCR_TRIGGER_8} and replace it with @code{UART_FCR_TRIGGER_1}. Note that overall performance might suffer if there
is high throughput on serial lines. Also note that you are modifying the kernel at
your own risk.


@item
Problem: I'm not using linux and my AVR910 programmer is really slow.

Solutions: The reasons for this are the same as above.
If you know how to work around this on your OS, please let us know.

@item
Problem: AVRDUDE says my device is not supported when using the AVR109 boot loader

Solution: Currently, AVRDUDE uses the AVR910 device codes given in the
@code{avrdude.conf} file, and matches them against the list of supported
devices reported by the programmer.  Unfortunately, there are no device
codes at all for some of the newer AVR devices, and even worse, the
device codes listed in @code{preprocessor.xls} of appnote AVR109 do not
match those once specified in AVR910.

Use the -F option to force AVRDUDE to continue anyway.

@item
Problem: Updating the flash ROM from terminal mode does not work with the
JTAG ICEs.

Solution: None at this time.  Currently, the JTAG ICE code cannot
write to the flash ROM one byte at a time.

@item
Problem: Page-mode programming the EEPROM (using the -U option) does
not erase EEPROM cells before writing, and thus cannot overwrite any
previous value != 0xff.

Solution: None.  This is an inherent feature of the way JTAG EEPROM
programming works, and is documented that way in the Atmel AVR
datasheets.
In order to successfully program the EEPROM that way, a prior chip
erase (with the EESAVE fuse unprogrammed) is required.
This also applies to the STK500 in parallel programming mode.


@end itemize



@bye

