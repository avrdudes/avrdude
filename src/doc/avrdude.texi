%% -*-texinfo-*-
\input texinfo

@setfilename avrdude.info
@settitle AVRDUDE
@finalout

@include version.texi

@c
@c These are set in version.texi which is automatically generated by automake.
@c
@c @set UPDATED 26 Febuary 2003
@c @set EDITION 3.2.0
@c @set VERSION 3.2.0

@include avrstats.texi
@c Contains various statistics used as @value{NUM...} below

@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.
@dircategory AVR Programming & development tools.
@direntry
* AvrDude: (avrdude).            AVR program downloader/uploader.
@end direntry

@ifinfo
This file documents the avrdude program.

For avrdude version @value{VERSION}, @value{UPDATED}.

Copyright @copyright{} Hans Eirik Bull, Brian Dean, Stefan R@"uger and
J@"org Wunsch

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.

Alternatively, this documentation may be copied and distributed under
the terms of the GNU Free Documentation License (FDL), version 1.3.
@end ifinfo

@titlepage
@title AVRDUDE
@subtitle A program for downloading/uploading AVR microcontroller flash, EEPROM and more
@subtitle for AVRDUDE, Version @value{VERSION}, @value{UPDATED}
@author by Hans Eirik Bull, Brian S. Dean, Stefan R@"uger and
@author J@"org Wunsch

@page

Use @uref{https://github.com/avrdudes/avrdude/issues} to report bugs and ask questions.

Copyright @copyright{} Hans Eirik Bull, Brian S. Dean, Stefan R@"uger and J@"org Wunsch
@sp 2

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end titlepage

@contents

@c
@c Top Node
@c
@node Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up

@ifinfo
This file documents the avrdude program for downloading/uploading
programs to Atmel AVR microcontrollers.

For avrdude version @value{VERSION}, @value{UPDATED}.

Use @url{https://github.com/avrdudes/avrdude/issues} to report bugs and ask questions.

Copyright @copyright{} Hans Eirik Bull, Brian S. Dean, Stefan R@"uger and J@"org Wunsch
@end ifinfo

@menu
* Introduction::
* Command Line Options::
* Terminal Mode Operation::
* Configuration Files::
* Autogenerated Files::
* Programmer Specific Information::
* Platform Dependent Information::
* Troubleshooting::
* List of Programmers::
* List of Parts::
* List of Memories::
* Index::
@end menu

@c
@c Node
@c
@node Introduction, Command Line Options, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction
@cindex Introduction

AVRDUDE - AVR Downloader Uploader - is a program for downloading and
uploading the on-chip memories of Atmel's AVR microcontrollers. It can
program the Flash, EEPROM, and where supported by the  programmer,  lock
bits, fuses that hold the microcontroller's configuration and other
memories that the part might have.

@cindex @code{calibration}
@cindex @code{signature}
@cindex @code{flash}
@cindex @code{eeprom}
AVRDUDE can be used via the command line to read or write chip memories
(eeprom, flash, fuses, lock bits) and read memories such as signature or
calibration bytes; the same can be achieved via an interactive terminal
mode. Using AVRDUDE from the command line works well for programming the
entire memory of the chip from the contents of a file, while interactive mode
is useful for exploring memory contents, modifying individual bytes of
eeprom, programming fuse/lock bits, etc.

@cindex Programmers supported
@cindex Emulating a HW programmer (dryrun)
@cindex Emulating a bootloader (dryboot)

Programming a microcontroller either requires a physical programmer that
sits between the target chip and the PC running AVRDUDE, or a  bootloader
program on the target chip that is then directly connected to the PC to be
served by AVRDUDE. Currently, AVRDUDE knows about @value{NUMPARTS} parts
and @value{NUMPROGRAMMERS} programmers, though not every programmer can
deal with every part. One noteworthy programmer is @code{dryrun}, which
allows one to explore the AVRDUDE command-line and terminal without
needing to have, or connect, a real physical programmer. Similarly,
@code{dryboot} allows exploring how to communicate with a bootloader
without connecting an AVR part.

AVRDUDE supports the following basic programmer types: Atmel's STK500,
Atmel's AVRISP and AVRISP mkII devices,
Atmel's STK600,
Atmel's JTAG ICE (the original one, mkII, and 3), appnote
avr910, appnote avr109 (including the AVR Butterfly),
serial bit-bang adapters,
and the PPI (parallel port interface). PPI represents a class
of simple programmers where the programming lines are directly
connected to the PC parallel port. Several pin configurations exist
for several variations of the PPI programmers, and AVRDUDE can be
configured to work with them by either specifying the appropriate
programmer on the command line or by creating a new entry in its
configuration file. All that's usually required for a new entry is to
tell AVRDUDE which pins to use for each programming function.

A number of equally simple bit-bang programming adapters that connect
to a serial port are supported as well, among them the popular
Ponyprog serial adapter, and the DASA and DASA3 adapters that used to
be supported by uisp(1).  Note that these adapters are meant to be
attached to a physical serial port.  Connecting to a serial port
emulated on top of USB is likely to not work at all, or to work
abysmally slow.

If you happen to have a Linux system with at least 4 hardware GPIOs
available (like almost all embedded Linux boards) you can do without any
additional hardware - just connect them to the SDO, SDI, RESET and SCK
pins of the AVR's SPI interface and use the linuxgpio programmer
type. Older boards might use the labels MOSI for SDO and MISO for SDI. It bitbangs
the lines using the Linux sysfs GPIO interface. Of course, care should
be taken about voltage level compatibility. Also, although not strictly
required, it is strongly advisable to protect the GPIO pins from
overcurrent situations in some way. The simplest would be to just put
some resistors in series or better yet use a 3-state buffer driver like
the 74HC244. Have a look at
@url{https://kolev.info/blog/2013/01/06/avrdude-linuxgpio/} for a more
detailed tutorial about using this programmer type.

Under a Linux installation with direct access to the SPI bus and GPIO
pins, such as would be found on a Raspberry Pi, the ``linuxspi''
programmer type can be used to directly connect to and program a chip
using the built in interfaces on the computer. The requirements to use
this type are that an SPI interface is exposed along with one GPIO
pin. The GPIO serves as the reset output since the Linux SPI drivers
do not hold chip select down when a transfer is not occuring and thus
it cannot be used as the reset pin. A readily available level
translator should be used between the SPI bus/reset GPIO and the chip
to avoid potentially damaging the computer's SPI controller in the
event that the chip is running at 5@w{ }V and the SPI runs at 3.3@w{ }V. The
GPIO chosen for reset can be configured in the avrdude configuration
file using the @code{reset} entry under the linuxspi programmer, or
directly in the port specification. An external pull-up resistor
should be connected between the AVR's reset pin and Vcc. If Vcc is not
the same as the SPI voltage, this should be done on the AVR side of
the level translator to protect the hardware from damage.

On a Raspberry Pi, header J8 provides access to the SPI and GPIO
lines.

Typically, pins 19, 21, and 23 are SPI SDO, SDI, and SCK, while
pins 24 and 26 would serve as CE outputs. So, close to these pins
is pin 22 as GPIO25 which can be used as /RESET, and pin 25 can
be used as GND.

A typical programming cable would then look like:

@multitable @columnfractions .1 .15 .15 .3
@headitem @tab @code{J8 pin} @tab @code{ISP pin} @tab @code{Name}
@item @tab @code{21}     @tab @code{1}   @tab @code{SDI}
@item @tab @code{-}      @tab @code{2}   @tab @code{Vcc - leave open}
@item @tab @code{23}     @tab @code{3}   @tab @code{SCK}
@item @tab @code{19}     @tab @code{4}   @tab @code{SDO}
@item @tab @code{22}     @tab @code{5}   @tab @code{/RESET}
@item @tab @code{25}     @tab @code{6}   @tab @code{GND}
@end multitable

The @code{-P @var{port}} option defaults to
@code{/dev/spidev0.0:/dev/gpiochip0} for this programmer. And, mind the
3.3@w{ }V voltage level of the Raspberry Pi!

@cindex Atmel STK500
@cindex Atmel JTAG ICE mkI
@cindex STK500
@cindex JTAG ICE mkI
@cindex @code{butterfly}
The STK500, JTAG ICE, avr910, and avr109/butterfly use the serial port to communicate with the PC.
@cindex Atmel STK600
@cindex Atmel JTAG ICE mkII
@cindex Atmel AVR JTAGICE3
@cindex STK600
@cindex JTAG ICE mkII
@cindex AVR JTAGICE3
@cindex JTAGICE3
@cindex USBasp ISP and TPI programmer
@cindex FT2232H/D programmer
@cindex FT2232H JTAG programmer
@cindex FT2232H with buffer and LEDs
@cindex FT232H JTAG programmer
@cindex FT232H programmer
@cindex FT232R programmer
@cindex FT232R Synchronous BitBang
@cindex FT245R programmer
@cindex FT4232H programmer
@cindex FTDI TTL232R-5V
@cindex USBtiny simple USB programmer
The STK600, JTAG ICE mkII/3, AVRISP mkII, USBasp, avrftdi (and derivatives), and USBtinyISP
programmers communicate through the USB, using @code{libusb} as a
platform abstraction layer.
The avrftdi adds support for the FT2232C/D, FT2232H, and FT4232H devices. These all use
the MPSSE mode, which has a specific pin mapping. Bit 0 (the lsb of the byte in the config
file) is SCK. Bit 1 is SDO, and Bit 2 is SDI. Bit 3 usually reset. The 2232C/D parts
are only supported on interface A, but the H parts can be either A or B (specified by the
usbdev config parameter).
The STK500, STK600, JTAG ICE, and avr910 contain on-board logic to control the programming of the target
device.
@cindex Atmel bootloader (AVR109, AVR911)
@cindex @code{flash}
The avr109 bootloader implements a protocol similar to avr910, but is
actually implemented in the boot area of the target's flash, as
opposed to being an external device.
The fundamental difference between the two types lies in the
protocol used to control the programmer. The avr910 protocol is very
simplistic and can easily be used as the basis for a simple, home made
programmer since the firmware is available online. On the other hand,
the STK500 protocol is more robust and complicated and the firmware is
not openly available.
The JTAG ICE also uses a serial communication protocol which is similar
to the STK500 firmware version 2 one.  However, as the JTAG ICE is
intended to allow on-chip debugging as well as memory programming, the
protocol is more sophisticated.
(The JTAG ICE mkII protocol can also be run on top of USB.)
Only the memory programming functionality of the JTAG ICE is supported
by AVRDUDE.
@cindex debugWIRE
@cindex ISP
@cindex PDI
@cindex JTAG
@cindex Atmel JTAG ICE mkII
@cindex Atmel AVR JTAGICE3
@cindex JTAG ICE mkII
@cindex AVR JTAGICE3
@cindex JTAGICE3
For the JTAG ICE mkII/3, JTAG, debugWIRE and ISP mode are supported, provided
it has a firmware revision of at least 4.14 (decimal).
See below for the limitations of debugWIRE.
For ATxmega devices, the JTAG ICE mkII/3 is supported in PDI mode (Xmega
parts), provided it has a revision 1 hardware and firmware version of at
least 5.37 (decimal).

@cindex Atmel-ICE
The Atmel-ICE (ARM/AVR) is supported (JTAG, PDI, debugWIRE, ISP, UPDI).

@cindex Atmel XplainedPro
@cindex XplainedPro
Atmel's XplainedPro boards, using EDBG protocol (CMSIS-DAP compliant), are
supported by the ``jtag3'' programmer type.

@cindex Atmel XplainedMini
@cindex XplainedMini
Atmel's XplainedMini boards, using mEDBG protocol, are also
supported by the ``jtag3'' programmer type.

@cindex Atmel AVR Dragon
@cindex AVR Dragon
@cindex Dragon
The AVR Dragon is supported in all modes (ISP, JTAG, PDI, HVSP, PP, debugWIRE).
When used in JTAG and debugWIRE mode, the AVR Dragon behaves similar to a
JTAG ICE mkII, so all device-specific comments for that device
will apply as well.
When used in ISP and PDI mode, the AVR Dragon behaves similar to an
AVRISP mkII (or JTAG ICE mkII in ISP mode), so all device-specific
comments will apply there.
In particular, the Dragon starts out with a rather fast ISP clock
frequency, so the @code{-B @var{bitclock}}
option might be required to achieve a stable ISP communication.
For ATxmega devices, the AVR Dragon is supported in PDI mode, provided it
has a firmware version of at least 6.11 (decimal).

@cindex Wiring bootloader
Wiring boards (e.g. Arduino Mega 2560 Rev3) are supported, utilizing
STK500 V2.x protocol, but a simple DTR/RTS toggle to set the boards
into programming mode.  The programmer type is ``wiring''. Note that
the @code{-D} option will likely be required in this case, because the
bootloader will rewrite the program memory, but no true chip erase can
be performed.

@cindex Arduino bootloader
Serial bootloaders that run a skeleton of the STK500 1.x protocol are supported via
their own programmer type specification ``arduino''.  This programmer works for
the Arduino Uno Rev3 or any AVR that runs the Optiboot bootloader.
The number of connection retry attempts can be specified as an
extended parameter. See the section on
@emph{extended parameters}
below for details.

@cindex Urboot bootloader
@cindex Urclock programmer
@cindex Urprotocol
Urprotocol is a leaner version of the STK500 1.x protocol that is designed
to be backwards compatible with STK500 v1.x; it allows bootloaders to be
much smaller, e.g., as implemented in the urboot project
@url{https://github.com/stefanrueger/urboot}. The programmer type ``urclock''
caters for these urboot bootloaders. Owing to its backward compatibility,
bootloaders that can be served by the arduino programmer can normally also
be served by the urclock programmer. This may require specifying the size
of (to AVRDUDE) @emph{unknown} bootloaders in bytes using the @code{-x
bootsize=<n>} option, which is necessary for the urclock programmer to
enable it to protect the bootloader from being overwritten. If an unknown
bootloader has EEPROM read/write capability then the option @code{-x eepromrw}
informs @code{avrdude -c urclock} of that capability.

@cindex The Bus Pirate
The BusPirate is a versatile tool that can also be used as an AVR programmer.
A single BusPirate can be connected to up to 3 independent AVRs. See
the section on
@emph{extended parameters}
below for details.

@cindex CH341A programmer
The USBasp ISP, USBtinyISP and CH341A adapters are also supported, provided
AVRDUDE has been compiled with libusb support.
They former two feature simple firmware-only USB implementations, running on
an ATmega8 (or ATmega88), or ATtiny2313, respectively.
CH341A programmers connect directly to the AVR target. Their SPI bit clock
is approximately 1.7@w{ }MHz and cannot be changed. As a consequence, the
AVR target must have a CPU frequency of 6.8@w{ }MHz or more: factory-set
AVR parts, which typically run on an internal oscillator between 1 MHz and
1.6 MHz, cannot be programmed using @code{-c ch341a}.

@cindex FLIP bootloader
The Atmel DFU bootloader is supported in both, FLIP protocol version 1
(AT90USB* and ATmega*U* devices), as well as version 2 (Xmega devices).
See below for some hints about FLIP version 1 protocol behaviour.

@cindex MPLAB(R) PICkit 4
@cindex MPLAB(R) PICkit 5
@cindex MPLAB(R) PICkit Basic
@cindex MPLAB(R) SNAP
@cindex PICkit 4
@cindex PICkit 5
@cindex PICkit Basic
@cindex SNAP
The MPLAB(R) PICkit 4/5/Basic and MPLAB(R) SNAP are supported in JTAG, TPI, ISP, PDI and UPDI mode.
@cindex Curiosity nano
The Curiosity Nano board is supported in UPDI mode. It is dubbed ``PICkit on
Board'', thus the name @code{pkobn_updi}.

@cindex SerialUPDI
SerialUPDI programmer implementation is based on Microchip's
@emph{pymcuprog} (@url{https://github.com/microchip-pic-avr-tools/pymcuprog})
utility, but it also contains some performance improvements included in
Spence Konde's @emph{DxCore} Arduino core (@url{https://github.com/SpenceKonde/DxCore}).
In a nutshell, this programmer consists of simple USB-to-UART adapter, diode
and couple of resistors. It uses serial connection to provide UPDI interface.
@xref{SerialUPDI Programmer} for more details and known issues.

The jtag2updi programmer is supported,
and can program AVRs with a UPDI interface.
Jtag2updi is just a firmware that can be loaded onto an AVR,
which enables it to interface with avrdude using the jtagice mkii protocol
via a serial link (@url{https://github.com/ElTangas/jtag2updi}).

@cindex Micronucleus bootloader
@cindex @code{flash}
The Micronucleus bootloader is supported for both protocol version V1 and
V2. As the bootloader does not support reading from flash memory, use the
@code{-V} option to prevent AVRDUDE from verifying the flash memory. See
the section on @emph{extended parameters} below for Micronucleus specific
options.

@cindex Teensy bootloader
@cindex @code{flash}
The Teensy bootloader is supported for all AVR boards.
As the bootloader does not support reading from flash memory,
use the @code{-V} option to prevent AVRDUDE from verifying the flash memory.
See the section on @emph{extended parameters}
below for Teensy specific options.

@ref{List of Programmers} holds a full listing of known programmers.

@menu
* History::
@end menu

@c
@c Node
@c
@node History,  , Introduction, Introduction
@section History and Credits
@cindex History and credits

AVRDUDE was written by Brian S. Dean under the name of AVRPROG to run on
the FreeBSD Operating System.  Brian renamed the software to be called
AVRDUDE when interest grew in a Windows port of the software so that the
name did not conflict with AVRPROG.EXE which is the name of Atmel's
Windows programming software.

For many years, the AVRDUDE source resided in public repositories on
savannah.nongnu.org,
where it continued to be enhanced and ported to other systems.  In
addition to FreeBSD, AVRDUDE now runs on Linux, macOS and Windows.  The
developers behind the porting effort primarily were Ted Roth, Eric
Weddington, and J@"org Wunsch.

In 2022, the project moved to Github (@url{https://github.com/avrdudes/avrdude/}).

And in the spirit of many open source projects, this manual also draws
on the work of others.  The initial revision was composed of parts of
the original Unix manual page written by J@"org Wunsch, the original web
site documentation by Brian Dean, and from the comments describing the
fields in the AVRDUDE configuration file by Brian Dean.  The texi
formatting was modeled after that of the Simulavr documentation by Ted
Roth.


@c
@c Node
@c
@node Command Line Options, Terminal Mode Operation, Introduction, Top
@chapter Command Line Options
@cindex Command line options

@menu
* Option Descriptions::
* Programmers Accepting Exitspec Parameter::
* Programmers Accepting Extended Parameters::
* Example Command Line Invocations::
@end menu

@c
@c Node
@c
@node Option Descriptions, Programmers Accepting Exitspec Parameter, Programmers Accepting Extended Parameters, Command Line Options
@cindex Options (command-line)
@section Option Descriptions
@cindex Option descriptions

@noindent
AVRDUDE is a command line tool, used as follows:

@smallexample
avrdude -p partname @var{options} @dots{}
@end smallexample

@noindent
Command line options are used to control AVRDUDE's behaviour.  The
following options are recognized:

@table @code
@item -p @var{partname}
@item --part @var{partname}
@cindex Option @code{-p} @var{partname}
@cindex Option @code{--part} @var{partname}
@cindex @code{-p} @var{partname}
@cindex @code{--part} @var{partname}
This option tells AVRDUDE what part (MCU) is connected to the programmer.
The @var{partname} parameter is the part's id listed in the configuration
file. To see a list of currently supported MCUs use @code{?} as partname,
which will, for each part, print its id; its official part name;
alternative names, if any; and the list of available programming
interfaces. Depending on the used shell, @code{?} may need to be quoted
as in @code{"?"} or @code{\?}. In connection with @code{-v}, this will
also print a table of variant part names with the package code and some
absolute maximum ratings. The part id, their official part name, the
listed alternative names or any of the full variant part names can be used
to specify a part with the @code{-p} option. If a part is unknown to
AVRDUDE, it means that there is no config file entry for that part, but it
can be added to the configuration file if you have the Atmel datasheet so
that you can enter the programming specifications. If @code{-p ?} is
specified with a specific programmer, see @code{-c} below, then only those
parts are output that the programmer expects to be able to handle,
together with the programming interface(s) that can be used in that
combination. In reality there can be deviations from this list,
particularly if programming is directly via a bootloader. See @ref{List of
Parts} for a full and detailed listing of supported parts.

@item -p @var{wildcard/flags}
@item --part @var{wildcard/flags}
@cindex Option @code{-p} @var{wildcard/flags}
@cindex Option @code{--part} @var{wildcard/flags}
@cindex @code{-p} @var{wildcard/flags}
@cindex @code{--part} @var{wildcard/flags}
Run developer options for MCUs that are matched by @var{wildcard}. Whilst
their main use is for developers some @var{flags} can be of utility for
users, e.g.,  @code{avrdude -p m328p/S} outputs AVRDUDE's understanding of
ATmega328P MCU properties; for more information run @code{avrdude -p x/h}.

@item -b @var{baudrate}
@item --baud @var{baudrate}
@cindex Option @code{-b} @var{baudrate}
@cindex Option @code{--baud} @var{baudrate}
@cindex @code{-b} @var{baudrate}
@cindex @code{--baud} @var{baudrate}
Override the RS-232 connection baud rate specified in the respective
programmer's @code{baudrate} entry of the configuration file
or defined by the @code{default_baudrate} entry in your
@code{~/.config/avrdude/avrdude.rc} or @code{~/.avrduderc} configuration
file if no @code{baudrate} entry was provided for this programmer.

@item -B @var{bitclock}
@item --bitclock @var{bitclock}
@cindex Option @code{-B} @var{bitclock}
@cindex Option @code{--bitclock} @var{bitclock}
@cindex @code{-B} @var{bitclock}
@cindex @code{--bitclock} @var{bitclock}
Specify the bit clock period for the JTAG, PDI, TPI, UPDI, or ISP
interface. The value is a floating-point number in microseconds.
Alternatively, the value might be suffixed with Hz, kHz or
MHz in order to specify the bit clock frequency rather than a
period. Some programmers default their bit clock value to a 1
microsecond bit clock period, suitable for target MCUs running at 4
MHz clock and above. Slower MCUs need a correspondingly higher bit
clock period. Some programmers reset their bit clock value to the
default value when the programming software signs off, whilst
others store the last used bit clock value. It is recommended to
always specify the bit clock if read/write speed is important.  You
can use the 'default_bitclock' keyword in your
@code{~/.config/avrdude/avrdude.rc} or @code{~/.avrduderc}
configuration file to assign a default value to keep from having to
specify this option on every invocation.

Note that some official Microchip programmers store the bitclock setting
and will continue to use it until a different value is provided. This
applies to 2nd generation programmers (AVRISPmkII, AVR Dragon, JTAG ICE
mkII, STK600) and 3rd generation programmers (JTAGICE3, Atmel ICE, Power
Debugger). 4th generation programmers (PICkit 4, MPLAB(R) SNAP) will store
the last user-specified bitclock until the programmer is disconnected from
the computer.

@item -c @var{programmer-id}
@item --programmer @var{programmer-id}
@cindex Option @code{-c} @var{programmer-id}
@cindex Option @code{--programmer} @var{programmer-id}
@cindex @code{-c} @var{programmer-id}
@cindex @code{--programmer} @var{programmer-id}
Specify the programmer to be used.  AVRDUDE knows about quite a few
programmers. The @var{programmer-id} parameter is the programmer's id
listed in the configuration file.  Specify @code{-c ?} to list all
programmers in the configuration file. Depending on the used shell,
@code{?} may need to be quoted as in @code{"?"} or @code{\?}. If you have
a programmer that is unknown to AVRDUDE but related to a known programmer
there is some chance that it can be added to the configuration file
without any code changes to AVRDUDE: copy a similar entry and change those
features that differ to match that of the unknown programmer. If @code{-c
?} is specified with a specific part, see @code{-p} above, then only those
programmers are output that expect to be able to handle this part,
together with the programming interface(s) that can be used in that
combination. In reality there can be deviations from this list,
particularly if programming is directly via a bootloader. See @ref{List of
Programmers} for a full and detailed listing of known programmers.

@item -c @var{wildcard/flags}
@item --programmer @var{wildcard/flags}
@cindex Option @code{-c} @var{wildcard/flags}
@cindex Option @code{--programmer} @var{wildcard/flags}
@cindex @code{-c} @var{wildcard/flags}
@cindex @code{--programmer} @var{wildcard/flags}
Run developer options for programmers that are matched by @var{wildcard}.
Whilst their main use is for developers some @var{flags} can be of utility
for users, e.g., @code{avrdude -c usbtiny/S} shows AVRDUDE's understanding of
usbtiny's properties; for more information run @code{avrdude -c x/h}.

@item -C @var{config-file}
@item --config @var{config-file}
@cindex Option @code{-c} @var{config-file}
@cindex Option @code{--config} @var{config-file}
@cindex @code{-C} @var{config-file}
@cindex @code{--config} @var{config-file}
@cindex Configuration files
Use the specified config file for configuration data.  This file
contains all programmer and part definitions that AVRDUDE knows about.
If not specified, AVRDUDE looks for the configuration file in the following
two locations:

@enumerate

@item
@code{<directory from which application loaded>/../etc/avrdude.conf}

@item
@code{<directory from which application loaded>/avrdude.conf}

@end enumerate

If not found there, the lookup procedure becomes platform dependent. On FreeBSD
and Linux, AVRDUDE looks at @code{/usr/local/etc/avrdude.conf}. See Appendix A
for the method of searching on Windows.

If @var{config-file} is written as @var{+filename}
then this file is read after the system wide and user configuration
files. This can be used to add entries to the configuration
without patching your system wide configuration file. It can be used
several times, the files are read in same order as given on the command
line.

@item -N
@item --noconfig
@cindex Option @code{-N}
@cindex Option @code{--noconfig}
@cindex @code{-N}
@cindex @code{--noconfig}
Do not load the personal configuration file that is usually located at
@code{~/.config/avrdude/avrdude.rc}, @code{~/.avrduderc} or in the same
directory as the avrdude executable.

@item -A
@cindex Option @code{-A}
@cindex @code{-A}
@cindex @code{flash}
Disable the automatic removal of trailing-0xFF sequences in file input
that is to be programmed to flash and in AVR reads from flash memory.
Normally, trailing 0xFFs can be discarded, as flash programming requires
the memory be erased to 0xFF beforehand. @code{-A} should be used when the
programmer hardware, or bootloader software for that matter, does not
carry out chip erase and instead handles the memory erase on a page level.
The popular Arduino bootloader exhibits this behaviour; for this reason
@code{-A} is engaged by default when specifying @code{-c} arduino.

@item -D
@item --noerase
@cindex Option @code{-D}
@cindex Option @code{--noerase}
@cindex @code{-D}
@cindex @code{--noerase}
@cindex @code{flash}
Disable auto-erase for flash. When the @code{-U} option for writing to any
flash memory is specified, avrdude will perform a chip erase before
starting any of the programming operations, since it generally is a
mistake to program the flash without performing an erase first.  This
option disables that. Auto-erase is not used for ATxmega parts nor for the
UPDI (AVR8X family) parts as these can use page erase before writing each
page so no explicit chip erase is required. Note, however, that any flash
page not affected by the current operation will retain its previous
contents. Setting @code{-D} implies @code{-A}.

@item -e
@item --erase
@cindex Option @code{-e}
@cindex Option @code{--erase}
@cindex @code{-e}
@cindex @code{--erase}
@cindex @code{flash}
@cindex @code{eeprom}
Causes a chip erase to be executed. This will reset the contents of the
flash ROM and EEPROM to the value @code{0xff}, and clear all lock bits.
Except for ATxmega and UPDI (AVR8X family) devices, all of which can use
page erase, it is basically a prerequisite command before the flash ROM
can be reprogrammed again.  The only exception would be if the new
contents would exclusively cause bits to be programmed from the value
@code{1} to @code{0}.  This option carries out the chip erase at the
beginning, before any of the @code{-U}, @code{-T} or @code{-t} options are
processed. If a chip erase is required in at a certain position within the
sequence of @code{-U}, @code{-T} or @code{-t} options it is recommended to
use @code{-T} erase instead which is processed in the given command line
order.

@cindex Auto-erase
@cindex @code{flash}
In absence of an explicit @code{-e} or @code{-D} option avrdude tries to
augur from the command line whether or not the chip should be auto-erased
at the  beginning. If avrdude detects a @code{-U} command that writes to
flash then auto-erase will be carried out before any other programming
unless a @code{-T} erase commad has been detected beforehand and unless
flash is read before writing to it. For the purpose of this analysis any
terminal command is considered to possibly read flash.

@cindex @code{eeprom}
Note that for reprogramming EEPROM cells, no explicit prior chip erase is
required since the MCU provides an auto-erase cycle in that case before
programming the cell.

@item -E @var{exitspec}[,@dots{}]
@cindex Option @code{-E} @var{exitspec}[,@dots{}]
@cindex @code{-E} @var{exitspec}[,@dots{}]
Pass @var{exitspec} to the programmer. The interpretation of the exitspec
parameter depends on the programmer itself. See below for a list of
programmers accepting exitspec parameter options or issue
@code{avrdude -E help ...} to see the  options for the programmer.

Multiple @var{exitspec} options can be separated with commas.

@item -F
@cindex Option @code{-F}
@cindex @code{-F}
@cindex @code{signature}
Normally, AVRDUDE tries to verify that the device signature read from
the part is reasonable before continuing.  Since it can happen from time
to time that a device has a broken (erased or overwritten) device
signature but is otherwise operating normally, this options is provided
to override the check.
Also, for programmers like the Atmel STK500 and STK600 which can
adjust parameters local to the programming tool (independent of an
actual connection to a target controller), this option can be used
together with @option{-t} to continue in terminal mode.
Moreover, the option allows to continue despite failed initialization
of connection between a programmer and a target.

@item -i @var{delay}
@cindex Option @code{-i} @var{delay}
@cindex @code{-i} @var{delay}
For bitbang-type programmers, delay for approximately
@var{delay}
microseconds between each bit state change.
If the host system is very fast, or the target runs off a slow clock
(like a 32 kHz crystal, or the 128 kHz internal RC oscillator), this
can become necessary to satisfy the requirement that the ISP clock
frequency must not be higher than 1/4 of the CPU clock frequency.
This is implemented as a spin-loop delay to allow even for very
short delays.
On Unix-style operating systems, the spin loop is initially calibrated
against a system timer, so the number of microseconds might be rather
realistic, assuming a constant system load while AVRDUDE is running.
On Win32 operating systems, a preconfigured number of cycles per
microsecond is assumed that might be off a bit for very fast or very
slow machines.

@item -l @var{logfile}
@item --logfile @var{logfile}
@cindex Option @code{-l} @var{logfile}
@cindex Option @code{--logfile} @var{logfile}
@cindex @code{-l} @var{logfile}
@cindex @code{--logfile} @var{logfile}
Use @var{logfile} rather than @var{stderr} for diagnostics output.
Note that initial diagnostic messages (during option parsing) are still
written to @var{stderr} anyway.

@item -n
@item --test-memory
@cindex Option @code{-n}
@cindex Option @code{--test-memory}
@cindex @code{-n}
@cindex @code{--test-memory}
No-write: disables writing data to the MCU whilst processing @code{-U}
(useful for debugging AVRDUDE). The terminal mode continues to write to
the device.

@item -O
@item --osccal
@cindex Option @code{-O}
@cindex Option @code{--osccal}
@cindex @code{-O}
@cindex @code{--osccal}
@cindex @code{calibration}
Perform a RC oscillator run-time calibration according to Atmel
application note AVR053.
This is only supported on the STK500v2, AVRISP mkII, and JTAG ICE mkII
hardware.
@cindex @code{eeprom}
Note that the result will be stored in the EEPROM cell at address 0.

@item -P @var{port}
@item --port @var{port}
@cindex Option @code{-P} @var{port}
@cindex Option @code{--port} @var{port}
@cindex @code{-P} @var{port}
@cindex @code{--port} @var{port}
Use @var{port} to identify the connection through which the programmer is
attached. This can be a parallel, serial, spi or linuxgpio connection. The
programmer normally specifies the connection type; in absence of a @code{-P}
specification, system-dependent default values @code{default_parallel},
@code{default_serial}, @code{default_spi}, or @code{default_linuxgpio} from
the configuration file are used. If you need to use a different port, use this
option to specify the alternate port name.

If avrdude has been configured with libserialport support, a serial port
can be specified using a predefined serial adapter type in
@var{avrdude.conf} or @var{.avrduderc}, e.g., @code{ch340} or
@code{ft232r}. If more than one serial adapter of the same type is
connected, they can be distinguished by appending a serial number, e.g.,
@code{ft232r:12345678}. Note that the USB to serial chip has to have a
serial number for this to work. Avrdude can check for leading and trailing
serial number matches as well. In the above example, @code{ft232r:1234}
would also result in a match, and so would @code{ft232r:...5678}. If the
USB to serial chip is not known to avrdude, it can be specified using the
hexadecimal USB vendor ID, hexadecimal product ID and an optional serial
number, following the serial number matching rules described above, e.g.,
@code{usb:0x2341:0x0043} or @code{usb:2341:0043:12345678}. To see a list
of currently plugged-in serial ports use @code{-P ?s}. In order to see a
list of all possible serial adapters known to avrdude use @code{-P ?sa}.
Depending on the used shell, @code{?} may need to be quoted as in
@code{"?"} or @code{\?}.

For the JTAG ICE mkII, if AVRDUDE has been built with libusb support,
@var{port} may alternatively be specified as
@code{usb}[:@var{serialno}].  In that case, the JTAG ICE mkII will be
looked up on USB.  If @var{serialno} is also specified, it will be
matched against the serial number read from any JTAG ICE mkII found on
USB.  The match is done after stripping any existing colons from the
given serial number, and right-to-left, so only the least significant
bytes from the serial number need to be given.
For a trick how to find out the serial numbers of all JTAG ICEs
attached to USB, see @ref{Example Command Line Invocations}.

As the AVRISP mkII device can only be talked to over USB, the very
same method of specifying the port is required there.

For the USB programmer "AVR-Doper" running in HID mode, the port must
be specified as @var{avrdoper}. Libhidapi support is required on Unix
and Mac OS but not on Windows. For more information about AVR-Doper see
@url{https://www.obdev.at/products/vusb/avrdoper.html}.

For the USBtinyISP, which is a simplistic device not implementing
serial numbers, multiple devices can be distinguished by their
location in the USB hierarchy.
For USBasp, multiple devices can be distinguished by either USB connection
or serial number.
See the respective @ref{Troubleshooting} entry for examples.

For the XBee programmer the target MCU is to be programmed wirelessly
over a ZigBee mesh using the XBeeBoot bootloader.  The ZigBee 64-bit
address for the target MCU's own XBee device must be supplied as a
16-character hexadecimal value as a port prefix, followed by the
@code{@@} character, and the serial device to connect to a second
directly contactable XBee device associated with the same mesh (with
a default baud rate of 9600).  This may look similar to:
@code{0013a20000000001@/dev/tty.serial}.

For diagnostic purposes, if the target MCU with an XBeeBoot
bootloader is connected directly to the serial port, the
64-bit address field can be omitted.  In this mode the
default baud rate will be 19200.

For programmers that attach to a serial port using some kind of
higher level protocol (as opposed to bit-bang style programmers),
@var{port} can be specified as @code{net}:@var{host}:@var{port}.
In this case, instead of trying to open a local device, a TCP
network connection to (TCP) @var{port} on @var{host}
is established.
Square brackets may be placed around @var{host} to improve
readability for numeric IPv6 addresses (e.g.
@code{net:[2001:db8::42]:1337}).
The remote endpoint is assumed to be a terminal or console server
that connects the network stream to a local serial port where the
actual programmer has been attached to.
The port is assumed to be properly configured, for example using a
transparent 8-bit data connection without parity at 115200 Baud
for a STK500.

Note: The ability to handle IPv6 hostnames and addresses is limited to
Posix systems (by now).

@item -r
@item --reconnect
@cindex Option @code{-r}
@cindex Option @code{--reconnect}
@cindex @code{-r}
@cindex @code{--reconnect}
Opens the serial port at 1200 baud and immediately closes it, waits 400 ms
for each @code{-r} on the command line and then establishes communication
with the programmer. This is commonly known as a "1200@w{ }bps touch", and is
used to trigger programming mode for certain boards like Arduino Leonardo,
Arduino Micro/Pro Micro and the Arduino Nano Every. Longer waits, and
therefore multiple @code{-r} options, are sometimes needed for slower, less
powerful hosts.

@item -q
@item --quell
@cindex Option @code{-q}
@cindex Option @code{--quell}
@cindex @code{-q}
@cindex @code{--quell}
Disable (or quell) output of the progress bar while reading or writing
to the device.  Specify it a second time for even quieter operation.

@item -T @var{cmd}
@cindex Option @code{-T} @var{cmd}
@cindex @code{-T} @var{cmd}
Run terminal line @var{cmd} when it is its turn in relation to other
@code{-t} interactive terminals, @code{-T} terminal commands and
@code{-U} memory operations. Except for the simplest of terminal commands
the argument @var{cmd} will most likely need to be set in quotes, see your
OS shell manual for details. See below for a detailed description of all
terminal commands.

@item -t
@item --terminal
@cindex Option @code{-t}
@cindex Option @code{--terminal}
@cindex @code{-t}
@cindex @code{--terminal}
Tells AVRDUDE to run an interactive terminal when it is its turn in
relation to other @code{-t} interactive terminals, @code{-T}
terminal commands and @code{-U} memory operations.

@item -U @var{memory}:@var{op}:@var{filename}[:@var{format}]
@item --memory @var{memory}:@var{op}:@var{filename}[:@var{format}]
@cindex Option @code{-U} @var{memory}:@var{op}:@var{filename}[:@var{format}]
@cindex Option @code{--memory} @var{memory}:@var{op}:@var{filename}[:@var{format}]
@cindex @code{-U} @var{memory}:@var{op}:@var{filename}[:@var{format}]
@cindex @code{--memory} @var{memory}:@var{op}:@var{filename}[:@var{format}]

Perform a memory operation when it is its turn in relation to other
@code{-t} interactive terminals, @code{-T} terminal commands and @code{-U}
memory operations. The @var{memory} field specifies the memory type to
operate on. From version 8.0 the memory field can also be a
comma-separated list of memories, eg, @code{flash,eeprom}; also, Intel Hex
or Motorola S-Record files generated by AVRDUDE can store multiple
memories. The special memory @code{ALL} expands to all memories that a
part has while @code{all} expands to all memories with exception of
sub-memories. @code{etc} is the same as @code{all}; this can be used to
change the order in which memories are written to or read from file, eg,
@code{signature,etc} is a list of all memories such that the
@code{signature} memory comes first. It is possible to remove a memory
from the list so far by preceding a minus or backslash, eg,
@code{all,-calibration}. Use the @option{-T part} option on the command
line or the @code{part} command in the interactive terminal to display all
the memories supported by a particular device.

@cindex @code{calibration}
@cindex @code{signature}
@cindex @code{flash}
@cindex @code{eeprom}
Typically, a device's memory configuration at least contains the memory
types @code{flash}, @code{eeprom}, @code{signature} and @code{lock}, which
is sometimes known as @code{lockbits}. The signature memory contains the
three device signature bytes, which should be, but not always are, unique
for the part. The @code{lock} memory of one or four bytes typically
details whether or not external reading/writing of the flash memory, or
parts of it, is allowed. After restricting access via the lock memory,
often the only way to unlock memory is via a chip erase.  Parts will also
typically have fuse bytes, which are read/write memories for configuration
of the device and calibration memories that typically contain read-only
factory calibration values.

@cindex @code{flash}
@cindex @code{eeprom}
The flash memory, being physically implemented as NOR-memory, is special
in the sense that it is normally only possible to program bits to change
from 1 to 0. Before reprogramming takes place normally flash memory has to
be erased. Older parts would only offer a chip erase to do so, which also
erases EEPROM unless a fuse configuration preserves its contents. If
AVRDUDE detects a @code{-U} option that writes to a flash memory it might
automatically trigger a chip erase for these older parts. See the
description of auto-erase under the @code{-e} option above. ATxmegas or
UPDI parts (AVR8X family) offer a page erase, and AVRDUDE takes advantage
of that by erasing pages before programming them unless @code{-e} (chip
erase) or @code{-D} (do not erase before writing) was requested. It should
be noted that in absence of the @code{-e} chip erase option any ATxmega or
UPDI flash pages not affected by the programming will retain their
previous content.

See @ref{List of Memories} for a complete list of memories that AVR
devices can have.

The @var{op} field specifies what operation to perform:

@table @code
@item r
read device memories and write to the specified file

@item w
read data from the specified file and write to the device memories in the
list; read-only memories in a memory list are skipped, as are fuses and
lock bits when the programmer is a bootloader; writing to single read-only
memories fails only if the contents differs between the file and memory

@item v
read data from both the device and the specified file and perform a verify

@end table

The @var{filename} field indicates the name of the file to read or
write.  The @var{format} field is optional and contains the format of
the file to read or write.  Possible values are:

@table @code
@cindex Intel Hex
@item i
Intel Hex

@item I
Intel Hex with comments on reading from, and tolerance of checksum errors, writing to the AVR

@cindex Motorola S-Record
@item s
Motorola S-Record

@cindex @code{flash}
@cindex Raw binary
@item r
raw binary; little-endian byte order, in the case of the flash data

@cindex ELF (Executable and Linkable Format)
@item e
ELF (Executable and Linkable Format), the final output file from the
linker; currently only accepted as an input file

@cindex Immediate file mode
@item m
immediate mode; actual byte values are specified on the command line,
separated by commas or spaces in place of the @var{filename} field of the
@option{-U} option.  This is useful for programming fuse bytes without
having to create a single-byte file or enter terminal mode.

@cindex Auto-detect mode
@item a
auto detect; valid for input only, and only if the input is not provided
at stdin.

@cindex Decimal file mode
@item d
decimal; this and the following formats generate one line of output for
the respective memory section, forming a comma-separated list of the
values. This can be particularly useful for subsequent processing, like
for fuse bit settings.

@cindex Hexadecimal file mode
@item h
hexadecimal; each value will get the string @emph{0x} prepended.

@cindex Octal file mode
@item o
octal; each value will get a @emph{0}
prepended unless it is less than 8 in which case it gets no prefix.

@cindex Binary file mode
@item b
binary; each value will get the string @emph{0b} prepended.
@end table

When used as input, the @code{m}, @code{d}, @code{h}, @code{o} and
@code{b} formats will use the same code for reading lists of numbers
separated by white space and/or commas. The read routine handles decimal,
hexadecimal, octal or binary numbers on a number-by-number basis, and the
list of numbers can therefore be of mixed type. In fact the syntax, is the
same as for data used by the terminal write command, i.e., the file's input
data can also be 2-byte short integers, 4-byte long integers or 8-byte
long long integers, 4-byte floating point numbers, 8-byte double precision
numbers, C-type strings with a terminating nul or C-like characters such
as @code{'\t'}. Numbers are written as little endian to memory. When using
@code{0x} hexadecimal or @code{0b} binary input leading zeros are used to
determine the size of the integer, e.g., @code{0x002a} will occupy two
bytes and write a @code{0x2a} to memory followed by @code{0x00}, while
@code{0x01234} will occupy 4 bytes. See the description of the terminal
write command for more details.

In absence of an explicit file format, the default is to use auto
detection for input files, raw binary format for output files from a
single memory read and Intel Hex with comments when an output file is
generated from a list of memories. Note that while AVRDUDE will generate a
single output file from a memory list for all formats with the exception
of elf (@code{:e}) it only recognises Intel hex (@code{:I} or @code{:i}),
Motorola S-Record (@code{:s}) or elf files (@code{:e}, generated by the
compiler) as valid multi-memory files when reading a file for verifying or
writing memories. Note also that if a @var{filename} contains a colon as
penultimate character the @var{format} field is no longer optional since
the last character would otherwise be misinterpreted as @var{format}.

@cindex @code{flash}
When reading any kind of flash memory area (including the various sub-areas
in Xmega devices), the resulting output file will be truncated to not contain
trailing 0xFF bytes which indicate unprogrammed (erased) memory. Thus, if the
entire memory is unprogrammed, this will result in an output file that has no
contents at all. This behaviour can be overridden with the @code{-A} option.

@cindex @code{flash}
As an abbreviation, the form @code{-U} @var{filename}
is equivalent to specifying
@code{-U} @emph{flash:w:}@var{filename}@emph{:a} or
@code{-U} @emph{application:w:}@var{filename}@emph{:a} for ATxmegas.
This will only work if @var{filename} does not have a pair of colons in it
that sandwich a single character as otherwise the first part might be
interpreted as memory, and the single character as memory operation.

A file  name  used for writing to flash that starts with @code{urboot:}
autogenerates a read-only urboot bootloader file. Try for example @code{-c
dryrun -U urboot:help} for a list of features that determine the contents
of the bootloader. @xref{Autogenerated Files} for detailed documentation.
Writing @code{urboot:...} files to flash using @code{-U} has the desired
side-effect of also writing all necessary fuse configurations for the
bootloader to work.

@item -v
@item --verbose
@cindex Option @code{-v}
@cindex Option @code{--verbose}
@cindex @code{-v}
@cindex @code{--verbose}
Enable verbose output.
More @code{-v} options increase verbosity level.

@item -V
@item --noverify-memory
@cindex Option @code{-V}
@cindex Option @code{--noverify-memory}
@cindex @code{-V}
@cindex @code{--noverify-memory}
Disable automatic verify check when writing data to the AVR with @code{-U}.

@item --version
@cindex Option @code{--version}
Print avrdude version and exit

@item -x @var{extended_param}
@cindex Option @code{-x} @var{extended_param}
@cindex @code{-x} @var{extended_param}
Pass @var{extended_param} to the chosen programmer implementation as
an extended parameter.  The interpretation of the extended parameter
depends on the programmer itself.  See below for a list of programmers
accepting extended parameters or issue @code{avrdude -x help ...} to
see the extended options of the chosen programmer.

@end table

@page
@c
@c Node
@c
@node Programmers Accepting Exitspec Parameter, Programmers Accepting Extended Parameters, Option Descriptions, Command Line Options
@section Programmers Accepting Exitspec Parameters
@cindex Programmers accepting exitspec parameters

@cindex FLIP bootloader
@cindex Option @code{-x} flip2
@cindex @code{-x} flip2
@cindex Option @code{-x} linuxspi
@cindex @code{-x} linuxspi
@cindex Option @code{-x} linuxgpio
@cindex @code{-x} linuxgpio
@cindex Option @code{-x} raspberry_pi_gpio
@cindex @code{-x} raspberry_pi_gpio
@cindex Option @code{-x} parallel port programmers
@cindex @code{-x} parallel port programmers

Currently, the @code{flip2}, @code{linuxspi}, @code{linuxgpio}, @code{raspberry_pi_gpio},
@code{pickit4_mplab}, @code{pickit5} and old-school parallel port programmers such
as @code{stk200} and @code{dapa} support @code{-E} exitspec parameter options.
These let the user decide in which state the programmer pins after ended
programming session. AVRDUDE only allows one @code{-E} option. However,
multiple exitspec parameters can be specified as one comma-separated list.

@table @code
@item flip2
@itemx linuxspi
@itemx linuxgpio
@itemx raspberry_pi_gpio
@itemx Parallel port programmers

@table @code
@item help
Show help menu and exit.

@cindex Option @code{-E} reset
@cindex @code{-E} reset
@item reset
The `/RESET' signal will be left activated at program exit, that is it
will be held low, in order to keep the MCU in reset state afterwards.
Note in particular that the programming algorithm for the AT90S1200
device mandates that the `/RESET' signal is active before powering up
the MCU, so in case an external power supply is used for this MCU type,
a previous invocation of AVRDUDE with this option specified is one of
the possible ways to guarantee this condition. @code{flip2} will not
exit bootloader mode at program exit if @code{reset} is used.

@cindex Option @code{-E} noreset
@cindex @code{-E} noreset
@item noreset
The `/RESET' line will be deactivated at program exit, thus allowing the
MCU target program to run while the programming hardware remains
connected. @code{flip2} will exit bootloader mode at program exit and
start the application if @code{noreset} is used, and this is the default
behaviour for this bootloader.
@end table

@cindex Option @code{-x} parallel port programmers
@cindex @code{-x} parallel port programmers
@item Parallel port programmers

@table @code
@cindex Option @code{-E} vcc
@cindex @code{-E} vcc
@item vcc
This option will leave those parallel port pins active (i. e. high) that
can be used to supply `Vcc' power to the MCU.

@cindex Option @code{-E} novcc
@cindex @code{-E} novcc
@item novcc
This option will pull the `Vcc' pins of the parallel port down at
program exit.

@cindex Option @code{-E} d_high
@cindex @code{-E} d_high
@item d_high
This option will leave the 8 data pins on the parallel port active
(i.e. high).

@cindex Option @code{-E} d_low
@cindex @code{-E} d_low
@item d_low
This option will leave the 8 data pins on the parallel port inactive
(i.e. low).
@end table

@cindex Option @code{-x} pickit4_mplab, pickit5
@cindex @code{-x} pickit4_mplab, pickit5
@item Pickit 4 (MPLAB)
@itemx Pickit 5

@table @code
@cindex Option @code{-E} vcc
@cindex @code{-E} vcc
@item vcc
This option will leave the power supply from the programmer enabled after
avrdude finished the operation. Disabled by default.

@end table

@end table

@page
@c
@c Node
@c
@node Programmers Accepting Extended Parameters, Example Command Line Invocations, Programmers Accepting Exitspec Parameter, Command Line Options
@section Programmers Accepting Extended Parameters
@cindex Programmers accepting extended parameters

Extended parameters are programmer-specific options; they all start with
@code{-x}. Generally, each programmer will allow @code{-x help}, which
will show a help menu of known extended parameters for this programmer, if
any, and exit. The extended parameters below are all shown without the
necessary @code{-x} option lead-in. AVRDUDE allows any number of @code{-x}
extended parameters to be specified on the command line.

@table @code

@cindex Emulating a bootloader (dryboot)
@cindex Emulating a HW programmer (dryrun)
@cindex Option @code{-x} dryboot
@cindex @code{-x} dryboot
@cindex Option @code{-x} dryrun
@cindex @code{-x} dryrun
@item dryrun
@itemx dryboot

Both dryrun and dryboot programmers emulate programming and accept the following parameters:

@table @code
@cindex @code{flash}
@item init
Initialise memories with human-readable patterns. Flash memory will be
randomly configured with respect to bootloader, data and code length.
Patterns can best be seen with fixed-width font and the @code{:I} format
by inspecting the generated hex file or by using, eg, @code{-U
flash:r:-:I}. Patterns in flash memory are executable and represent benign
AVR code, ie, no I/O memory access. Choose a fixed seed for reproducible
results.

@item init=<n>
Shortcut for @code{-x init -x seed=<n>} (see below)

@cindex @code{flash}
@item random
Initialise memories with random code and values. Flash memory will be
randomly configured with respect to bootloader, data and code length.
Random code in flash will be benign, that is, not accessing I/O memories,
SRAM or flash. Choose a fixed seed for reproducible results.

@item random=<n>
Shortcut for @code{-x random -x seed=<n>}

@item seed=<n>
Seed random number generator with @var{n}; the default is
@code{time(NULL)}. Setting this option with a fixed positive @var{n} will
make the random choices reproducible, ie, they will stay the same between
different avrdude runs.

@end table

@cindex Option @code{-x} JTAG ICE mkII/3
@cindex @code{-x} JTAG ICE mkII/3
@cindex Option @code{-x} Atmel-ICE
@cindex @code{-x} Atmel-ICE
@cindex Option @code{-x} PICkit 4
@cindex @code{-x} PICkit 4
@cindex Option @code{-x} MPLAB(R) SNAP
@cindex @code{-x} MPLAB(R) SNAP
@cindex Option @code{-x} Power Debugger
@cindex @code{-x} Power Debugger
@cindex Option @code{-x} AVR Dragon
@cindex @code{-x} AVR Dragon
@cindex Atmel JTAG ICE mkII
@cindex JTAG ICE mkII
@cindex Atmel AVR JTAGICE3
@cindex AVR JTAGICE3
@cindex JTAGICE3
@cindex MPLAB(R) PICkit 4
@cindex PICkit 4
@cindex MPLAB(R) PICkit 5
@cindex PICkit 5
@cindex MPLAB(R) PICkit Basic
@cindex PICkit Basic
@cindex MPLAB(R) SNAP
@cindex SNAP
@cindex Atmel PowerDebugger
@cindex PowerDebugger
@cindex Atmel AVR Dragon
@cindex AVR Dragon
@cindex Dragon
@item JTAG ICE mkII/3
@itemx Atmel-ICE
@itemx PICkit 4
@itemx MPLAB(R) SNAP
@itemx Power Debugger
@itemx AVR Dragon

When using the JTAG ICE mkII, JTAGICE3, Atmel-ICE, PICkit 4, MPLAB(R) SNAP,
Power Debugger or AVR Dragon in JTAG mode, the following extended parameter
is accepted:
@table @code
@item jtagchain=UB,UA,BB,BA
Setup the JTAG scan chain for @var{UB} units before, @var{UA} units
after, @var{BB} bits before, and @var{BA} bits after the target AVR,
respectively.
Each AVR unit within the chain shifts by 4 bits.
Other JTAG units might require a different bit shift count.

@item hvupdi
@var{Power Debugger and Pickit 4 only}
@*
High-voltage UPDI programming is used to enable a UPDI pin that has previously
been set to RESET or GPIO mode. Use @code{-x hvupdi} to enable high-voltage UPDI
initialization for supported targets.

@item vtarg=VALUE, vtarg
@var{Power Debugger only}
@*
The voltage generator can be enabled by setting a target voltage.
The current set-voltage can be read by @code{-x vtarg} alone.

@end table

@cindex Option @code{-x} PICkit 4
@cindex @code{-x} PICkit 4
@cindex Option @code{-x} MPLAB(R) SNAP
@cindex @code{-x} MPLAB(R) SNAP
@cindex MPLAB(R) PICkit 4
@cindex MPLAB(R) SNAP
@cindex SNAP
@cindex PICkit 4
@item PICkit 4
@item MPLAB(R) SNAP

The PICkit 4 and MPLAB(R) SNAP programmers accept the following extended parameters:
@table @code
@item mode=avr,mplab/pic
Switch programmer to AVR or MPLAB mode, then exit: the PICkit 4 and MPLAB(R) SNAP
programmer can only be utilised by Avrdude when in AVR mode.
Use @code{-x mode=avr} for switching to AVR mode, or @code{-x mode=mplab}
for switching to MPLAB mode.
@end table

@cindex Option @code{-x} PICkit 5
@cindex @code{-x} PICkit 5
@cindex MPLAB(R) PICkit 4
@cindex PICkit 4
@cindex MPLAB(R) PICkit 5
@cindex PICkit 5
@item PICkit 5
@item PICkit 4 (PIC Mode)

The PICkit 5 and PICkit 4 (MPLAB Mode) programmer can accept following extended parameters
@table @code
@item vtarg=VALUE
Specify a voltage between 1.8 and 5.5@w{ }V that the programmer should supply
to the target. If there is already a valid voltage applied to the VTG Pin,
this setting will be ignored. When AVRDUDE detects an external voltage outside
of this range, it will terminate the operation. You can disable this check by
setting the voltage to 0@w{ }V. If an XMEGA part was selected, a requested voltage
above 3.49@w{ }V will lead to an abort of operation.
Usually, the programmer will stop providing power when the session ends.
To continue to power the target you can use the @code{-E vcc} option.
@item hvupdi
High-voltage UPDI programming is used to enable a UPDI pin that has previously
been set to RESET or GPIO mode. Use @code{-x hvupdi} to enable high-voltage UPDI
initialization for supported targets. Depending on the target, the HV pulse will
be applied either on the RST pin, or the UPDI pin.
@end table

@cindex Option @code{-x} Xplained Mini
@cindex @code{-x} Xplained Mini
@cindex Atmel XplainedMini
@cindex XplainedMini
@item Xplained Mini

The Xplained Mini/Nano programmer (ISP or UPDI, not TPI) type accepts the
following extended parameters:

@table @code
@item suffer=VALUE, @code{suffer}
The SUFFER register allows the user to modify the behavior of the on-board mEDBG.
The current state can be read by @code{-x suffer} alone.
@table @code
@item Bit 7 ARDUINO:
Adds control of extra LEDs when set to 0
@item Bit 6..3:
Reserved (must be set to 1)
@item Bit 2 EOF:
Agressive power-down, sleep after 5 seconds if no USB enumeration when set to 0
@item Bit 1 LOWP:
forc running the mEDBG at 1 MHz when bit set to 0
@item Bit 0 FUSE:
Fuses are safe-masked when bit sent to 1. Fuses are unprotected when set to 0
@end table
@end table

@table @code
@item vtarg_switch=VALUE, @code{vtarg_switch}
The on-board target voltage switch can be turned on or off by writing a 1 or
a 0. The current state can be read by @code{-x vtarg_switch} alone.
Note that the target power switch will always be on after a power cycle.
Also note that the smaller Xplained Nano boards does not have a target power switch.

@end table

@cindex Option @code{-x} Curiosity Nano
@cindex @code{-x} Curiosity Nano
@cindex Curiosity nano
@item Curiosity Nano

The Curiosity Nano board accepts the following extended parameter:
@table @code
@item vtarg=VALUE, vtarg
The generated on-board target voltage can be changed by specifying a new voltage.
The current set-voltage can be read by @code{-x vtarg} alone.
@end table

@cindex Option @code{-x} STK500
@cindex @code{-x} STK500
@cindex Option @code{-x} STK600
@cindex @code{-x} STK600
@cindex Atmel STK500
@cindex STK500
@cindex Atmel STK600
@cindex STK600
@item STK500
@item STK600

The STK500 and STK600 boards accept the following extended parameters:
@table @code
@item vtarg=VALUE, vtarg
The generated on-board target voltage can be changed by specifying a new voltage.
The current set-voltage can be read by @code{-x vtarg} alone.
@item fosc=VALUE[MHz|M|kHz|k|Hz|H], fosc
Set the programmable oscillator frequency in MHz, kHz or Hz.
The current frequency can be read by @code{-x fosc} alone.
@item varef=VALUE, varef
The generated on-board analog reference voltage can be changed by specifying
a new reference voltage. The current reference voltage can be read by
@code{-x varef} alone.
@item varef[0,1]=VALUE, varef[0,1]
@var{STK600 only}
@*
The generated on-board analog reference voltage for channel 0 or channel 1 can
be changed by specifying a new reference voltage.
The current reference voltage can be read by @code{-x varef0} or
@code{-x varef1} alone.
@item attempts[=<1..99>]
@var{STK500V1 only}
@*
Specify how many connection retry attempts to perform before exiting.
Defaults to 10 if not specified.
@item xtal=VALUE[MHz|M|kHz|k|Hz|H]
Defines the XTAL frequency of the programmer if it differs from 7.3728 MHz of the
original STK500. Used by avrdude for the correct calculation of fosc and sck.
@end table

@cindex Atmel bootloader (AVR109, AVR911)
@cindex Bootloader (AVR109, AVR911)
@cindex Option @code{-x} AVR109
@cindex @code{-x} AVR109
@item AVR109

The AVR109 programmer type accepts the following extended parameter:
@table @code
@item autoreset
Toggle RTS/DTR lines on port open to issue a hardware reset.
@end table

@cindex Option @code{-x} AVR910
@cindex @code{-x} AVR910
@cindex Atmel low-cost programmer AVR910
@cindex Low-cost programmer AVR910
@item AVR910

The Atmel low-cost AVR910 programmer type accepts the following extended parameter:
@table @code
@item devcode=VALUE
Override the device code selection by using @var{VALUE}
as the device code.
The programmer is not queried for the list of supported
device codes, and the specified @var{VALUE}
is not verified but used directly within the
@code{T} command sent to the programmer.
@var{VALUE} can be specified using the conventional number notation of the
C programming language.
@item no_blockmode
Disables the default checking for block transfer capability.
Use
@code{no_blockmode} only if your @code{AVR910}
programmer creates errors during initial sequence.
@end table

@cindex Option @code{-x} Arduino
@cindex @code{-x} Arduino
@cindex Arduino bootloader
@item Arduino

The Arduino programmer type accepts the following extended parameter:
@table @code
@item attempts[=<1..99>]
Specify how many connection retry attempts to perform before exiting.
Defaults to 10 if not specified.
@item noautoreset
Do not toggle RTS/DTR lines on port open to prevent a hardware reset.
@end table

@cindex Urboot bootloader
@cindex Urclock programmer
@cindex Urprotocol
@cindex Option @code{-x} Urclock
@cindex @code{-x} Urclock
@item Urclock

The urclock programmer type accepts the following extended parameters:
@table @code
@item showall
Show all info for the connected part, then exit. The @code{-x show...} options
below can be used to assemble a bespoke response consisting of a subset
(or only one item) of all available relevant information about the
connected part and bootloader.
@cindex @code{flash}
@cindex @code{eeprom}
@item showid
Show a unique Urclock ID stored in either flash or EEPROM of the MCU, then exit.
@item id=<E|F>.<addr>.<len>
Historically, the Urclock ID was a six-byte unique little-endian number
stored in Urclock boards at EEPROM address 257. The location of this
number can be set by the @code{-x id=<E|F>.<addr>.<len>} extended parameter. @code{E}
stands for EEPROM and @code{F} stands for flash. A negative address addr counts
from the end of EEPROM and flash, respectively. The length len of the
Urclock ID can be between 1 and 8 bytes.
@cindex @code{flash}
@item showdate
Show the last-modified date of the input file for the flash application,
then exit. If the input file was stdin, the date will be that of the
programming. Date and filename are part of the metadata that the urclock
programmer stores by default in high flash just under the bootloader; see also
@cindex @code{flash}
@code{-x nometadata}.
@item showfilename
Show the input filename (or title) of the last flash writing session, then exit.
@item title=<string>
When set, <string> will be used in lieu of the input filename. The maximum
string length for the title/filename field is 254 bytes including
terminating nul.
@item showapp
Show the size of the programmed application, then exit.
@cindex @code{flash}
@item showstore
Show the size of the unused flash between the application and metadata, then exit.
@item showmeta
Show the size of the metadata just below the bootloader, then exit.
@item showboot
Show the size of the bootloader, then exit.
@item showversion
Show bootloader version and capabilities, then exit.
@item showvector
Show the vector number and name of the interrupt table vector used by the
bootloader for starting the application, then exit. For hardware-supported
bootloaders this will be vector 0 (Reset), and for vector bootloaders this
will be any other vector number of the interrupt vector table or the slot
just behind the vector table with the name @code{VBL_ADDITIONAL_VECTOR}.
@item showpart
Show the part for which the bootloader was compiled, then exit.
@cindex @code{flash}
@item bootsize=<size>
Manual override for bootloader size. Urboot bootloaders put the number of
used bootloader pages into a table at the top of the bootloader section,
i.e., typically top of flash, so the urclock programmer can look up the
bootloader size itself. In backward-compatibility mode, when programming
via other bootloaders, this option can be used to tell the programmer the
size, and therefore the location, of the bootloader.
@cindex @code{flash}
@item vectornum=<n>
Manual override for vector number. Urboot bootloaders put the vector
number used by a vector bootloader into a table at the top of flash, so
this option is normally not needed for urboot bootloaders. However, it is
useful in backward-compatibility mode (or when the urboot bootloader does
not offer flash read). Specifying a vector number in these circumstances
implies a vector bootloader whilst the default assumption would be a
hardware-supported bootloader.
@cindex @code{eeprom}
@item eepromrw
Manual override for asserting EEPROM read/write capability. Not normally
needed for urboot bootloaders, but useful for in backward-compatibility
mode if the bootloader offers EEPROM read/write.
@cindex @code{flash}
@item emulate_ce
If an urboot bootloader does not offer a chip erase command it will tell
the urclock programmer so during handshake. In this case the urclock
programmer emulates a chip erase, if warranted by user command line
options, by filling the remainder of unused flash below the bootloader
with 0xff. If this option is specified, the urclock programmer will assume
that the bootloader cannot erase the chip itself. The option is useful
for backwards-compatible bootloaders that do not implement chip erase.
@cindex @code{flash}
@item restore
Write unchanged flash input files to the AVR and trim below the bootloader if
needed. This is most useful when one has a backup of the full flash and
wants to play that back onto the device. No metadata are written in this
case and no vector patching happens either if it is a vector bootloader.
However, for vector bootloaders, even under the option @code{-x restore} an
input file will not be written to the AVR for which the reset vector does not point
to the vector bootloader. This is to avoid loading an input file onto the
device that would render the vector bootloader becoming unreachable after reset.
@cindex @code{flash}
@item initstore
On writing to flash fill the store space between the flash application and
the metadata section with 0xff.
@cindex @code{flash}
@item nofilename
On writing to flash do not store the application input filename (nor a title).
@cindex @code{flash}
@item nodate
On writing to flash do not store the application input filename (nor a
title) and no date either.
@cindex @code{flash}
@item nostore
On writing to flash do not store metadata except the metadata code byte
@code{0xff} saying there are no metadata.  In particular, no data store
frame is programmed.
@cindex @code{flash}
@cindex Metadata
@item nometadata
Do not support any metadata. The full flash besides the bootloader is
available for the application. If the application is smaller than the
available space then a metadata code byte @code{0xff} is stored
nevertheless to indicate there are no further metadata available. In
absence of @code{-x nometadata}, the default for the urclock programmer is
to write as much metadata (filename, data and store information) as the
size of the application and the other extended options allow. The
subtle difference between @code{-x nometadata} and @code{-x nostore} is that
the latter always explicitly stores in flash that no further metadata are
available, so that a such prepared flash can always be queried with
@code{avrdude -x showall}. In contrast to this, it cannot be guaranteed
that a @code{-x showall} query on flash prepared with @code{-x nometadata}
yields useful results.
@item noautoreset
Do not toggle RTS/DTR lines on port open to prevent a hardware reset.
@item delay=<n>
Add a <n> ms delay after reset. This can be useful if a board takes a
particularly long time to exit from external reset. <n> can be negative,
in which case the default 120 ms delay after issuing reset will be
shortened accordingly.
@item strict
Urclock has a faster, but slightly different strategy than -c arduino to
synchronise with the bootloader; some stk500v1 bootloaders cannot cope
with this, and they need the @code{-x strict} option.
@end table

@cindex Option @code{-x} BusPirate
@cindex @code{-x} BusPirate
@cindex The Bus Pirate
@cindex BusPirate
@item BusPirate

The BusPirate programmer type accepts the following extended parameters:
@table @code
@item reset=cs,aux,aux2
The default setup assumes the BusPirate's CS output pin connected to
the RESET pin on AVR side. It is however possible to have multiple AVRs
connected to the same BP with SDI, SDO and SCK lines common for all of them.
In such a case one AVR should have its RESET connected to BusPirate's
@emph{CS}
pin, second AVR's RESET connected to BusPirate's
@emph{AUX}
pin and if your BusPirate has an
@emph{AUX2}
pin (only available on BusPirate version v1a with firmware 3.0 or newer)
use that to activate RESET on the third AVR.

It may be a good idea to decouple the BusPirate and the AVR's SPI buses from
each other using a 3-state bus buffer. For example 74HC125 or 74HC244 are some
good candidates with the latches driven by the appropriate reset pin (cs,
aux or aux2). Otherwise the SPI traffic in one active circuit may interfere
with programming the AVR in the other design.

@item spifreq=@var{0..7}
@multitable @columnfractions .05 .3
@item @code{0} @tab  30 kHz (default)
@item @code{1} @tab 125 kHz
@item @code{2} @tab 250 kHz
@item @code{3} @tab   1 MHz
@item @code{4} @tab   2 MHz
@item @code{5} @tab   2.6 MHz
@item @code{6} @tab   4 MHz
@item @code{7} @tab   8 MHz
@end multitable

@item rawfreq=0..3
Sets the SPI speed and uses the Bus Pirate's binary ``raw-wire'' mode instead
of the default binary SPI mode:

@multitable @columnfractions .05 .3
@item @code{0} @tab 5 kHz
@item @code{1} @tab 50 kHz
@item @code{2} @tab 100 kHz (Firmware v4.2+ only)
@item @code{3} @tab 400 kHz (v4.2+)
@end multitable

The only advantage of the ``raw-wire'' mode is that different SPI frequencies
are available. Paged writing is not implemented in this mode.

@item pullups
Enable the Bus Pirate's built-in pull-up resistors. These resistors are
useful when working with different voltage levels. VPU pin of the Bus Pirate
must be connected to an external voltage.
For example: connect VPU pin to the +5V pin or an external power supply.

@item hiz
Enable the Bus Pirate's HiZ mode on SPI, allowing it to work as an
open-collector and interface with external pull-up circuits.
If the external target circuit does not have pull-ups, the Bus Pirate
will not be able to send data.

@item ascii
Attempt to use ASCII mode even when the firmware supports BinMode (binary
mode).
BinMode is supported in firmware 2.7 and newer, older FW's either don't
have BinMode or their BinMode is buggy. ASCII mode is slower and makes
the above
@code{reset=}, @code{spifreq=}
and
@code{rawfreq=}
parameters unavailable. Be aware that ASCII mode is not guaranteed to work
with newer firmware versions, and is retained only to maintain compatibility
with older firmware versions.

@cindex @code{flash}
@item nopagedwrite
Firmware versions 5.10 and newer support a binary mode SPI command that enables
whole pages to be written to AVR flash memory at once, resulting in a
significant write speed increase. If use of this mode is not desirable for some
reason, this option disables it.

@item nopagedread
Newer firmware versions support in binary mode SPI command some AVR Extended
Commands. Using the ``Bulk Memory Read from Flash'' results in a
significant read speed increase. If use of this mode is not desirable for some
reason, this option disables it.

@item cpufreq=@var{125..4000}
This sets the @emph{AUX}  pin to output a frequency of @var{n} kHz. Connecting
the @emph{AUX} pin to the XTAL1 pin of your MCU, you can provide it a clock,
for example when it needs an external clock because of wrong fuses settings.
Make sure the CPU frequency is at least four times the SPI frequency.

@item serial_recv_timeout=@var{1...}
This sets the serial receive timeout to the given value.
The timeout happens every time avrdude waits for the BusPirate prompt.
Especially in ascii mode this happens very often, so setting a smaller value
can speed up programming a lot.
The default value is 100 ms. Using 10 ms might work in most cases.

@end table

@cindex Option @code{-x} Micronucleus bootloader
@cindex @code{-x} Micronucleus bootloader
@cindex Micronucleus bootloader
@item Micronucleus bootloader

The Micronucleus programmer type accepts the following extended parameter:
@table @code
@item wait=@var{timeout}
If the device is not connected, wait for the device to be plugged in.
The optional @var{timeout} specifies the connection time-out in seconds.
If no time-out is specified, AVRDUDE will wait indefinitely until the
device is plugged in.
@end table

@cindex Option @code{-x} Teensy bootloader
@cindex @code{-x} Teensy bootloader
@cindex Teensy bootloader
@item Teensy bootloader

The Teensy programmer type accepts the following extended parameter:
@table @code
@item wait=@var{timeout}
If the device is not connected, wait for the device to be plugged in.
The optional @var{timeout} specifies the connection time-out in seconds.
If no time-out is specified, AVRDUDE will wait indefinitely until the
device is plugged in.
@end table

@cindex Option @code{-x} Wiring
@cindex @code{-x} Wiring
@cindex Wiring bootloader
@item Wiring

The Wiring programmer type accepts the following extended parameters:
@table @code
@item snooze=<n>
After performing the port open phase, AVRDUDE will wait/snooze for
@var{snooze} milliseconds before continuing to the protocol sync phase.
No toggling of DTR/RTS is performed if @var{snooze} > 0.
@item delay=<n>
Add a <n> milliseconds delay after reset. This can be useful if a board
takes a particularly long time to exit from external reset. <n> can be
negative, in which case the default 100 ms delay after issuing reset will
be shortened accordingly.
@end table

@cindex Option @code{-x} PICkit2
@cindex @code{-x} PICkit2
@cindex Microchip PICkit 2 programmer
@cindex PICkit 2 programmer
@item PICkit2

Connection to the PICkit2 programmer:
@multitable @columnfractions .05 .3
@item @code{(AVR)} @tab      @code{(PICkit2)}
@item @code{RST} @tab      @code{VPP/MCLR (1) }
@item @code{VDD} @tab      @code{VDD Target (2) -- possibly optional if AVR self powered }
@item @code{GND} @tab      @code{GND (3) }
@item @code{SDI} @tab      @code{PGD (4) }
@item @code{SCLK} @tab      @code{PDC (5) }
@item @code{OSI} @tab      @code{AUX (6) }
@end multitable

The PICkit2 programmer type accepts the following extended parameters:
@table @code
@item clockrate=@var{rate}
Sets the SPI clocking rate in Hz (default is 100@w{ }kHz). Alternately the -B or -i options can be used to set the period.
@item timeout=@var{usb-transaction-timeout}
Sets the timeout for USB reads and writes in milliseconds (default is 1500 ms).
@end table

@cindex Option @code{-x} USBasp
@cindex @code{-x} USBasp
@cindex USBasp ISP and TPI programmer
@item USBasp

The USBasp programmer type accepts the following extended parameter:
@table @code
@item section_config
Programmer will erase
configuration section with option '-e' (chip erase),
rather than entire chip.
Only applicable to TPI devices (ATtiny 4/5/9/10/20/40).
@end table

@cindex Option @code{-x} xbee
@cindex @code{-x} xbee
@cindex XBeeBoot OTA bootloader
@item xbee

The xbee programmer type accepts the following extended parameter:
@table @code
@item xbeeresetpin=@var{1..7}
Select the XBee pin @code{DIO<1..7>} that is connected to the MCU's
@code{/RESET} line.  The programmer needs to know which DIO pin to use to
reset into the bootloader.  The default (3) is the @code{DIO3} pin
(XBee pin 17), but some commercial products use a different XBee
pin.

The remaining two necessary XBee-to-MCU connections are not selectable
- the XBee @code{DOUT} pin (pin 2) must be connected to the MCU's
RXD line, and the XBee @code{DIN} pin (pin 3) must be connected to
the MCU's TXD line.

@end table

@cindex Option @code{-x} jtag2updi
@cindex @code{-x} jtag2updi
@cindex Option @code{-x} serialupdi
@cindex @code{-x} serialupdi
@cindex JTAGv2 to UPDI bridge
@cindex SerialUPDI
@item jtag2updi
@item serialupdi

The jtag2updi and serialupdi programmer types accept the following extended parameters:
@table @code
@item rtsdtr=low,high
Forces RTS/DTR lines to assume low or high state during the whole
programming session. Some programmers might use this signal to
indicate UPDI programming state, but this is strictly hardware
specific.

When not provided, driver/OS default value will be used.

@end table

@cindex Option @code{-x} linuxspi
@cindex @code{-x} linuxspi
@cindex Linux /dev/spidev* programmer
@item linuxspi

The linuxspi programmer type accepts the following extended parameter:
@table @code
@item disable_no_cs
Ensures the programmer does not use the SPI_NO_CS bit for the SPI
driver. This parameter is useful for kernels that do not support
the CS line being managed outside the application.
@end table

@cindex Flashcom serprog protocol
@cindex Option @code{-x} serprog
@cindex @code{-x} serprog
@item serprog

The serprog programmer type accepts the following extended parameter:
@table @code
@item cs
Sets the chip select (CS) to use on supported programmers.
Programmers supporting the 0x16 serprog command can have more than the default CS (0).
This option allows to choose these additional CSes (1, 2, ...) for programming the AVR.
@end table

@end table

@page
@c
@c Node
@c
@node Example Command Line Invocations,  , Programmers Accepting Extended Parameters, Command Line Options
@section Example Command Line Invocations
@cindex Example Command line invocations

AVRDUDE error messages, warnings and progress reports are generally
written to stderr which can, in bash, be turned off by @code{2>/dev/null}
or by using increasingly more @code{-q} options to suppress them. Terminal
output of commands or that of the @code{-U} command with an output file
named @code{-} are written to stdout. In some examples empty lines are
shown for clarity that are not printed by AVRDUDE or the shell.

@cindex @code{flash}
@noindent
@strong{Write the file @code{diag.hex} to the ATmega128 chip} using the
STK500 programmer connected to the default serial port:

@smallexample
@cartouche
$ avrdude -p m128 -c stk500 -e -U flash:w:diag.hex

Reading 19278 bytes for flash from input file diag.hex
Writing 19278 bytes to flash
Writing | ################################################## | 100% 7.60 s
Reading | ################################################## | 100% 6.83 s
19278 bytes of flash verified

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@noindent
Same but in @strong{quell-progress-reporting (silent) mode @code{-qq}:}

@cindex @code{flash}
@smallexample
@cartouche
$ avrdude -qq -p m128 -c stk500 -e -U flash:w:diag.hex
@end cartouche
@end smallexample

@noindent
@strong{Using @code{&&} to confirm that the silent AVRDUDE command went OK:}

@cindex @code{flash}
@smallexample
@cartouche
$ avrdude -qq -p m128 -c stk500 -e -U flash:w:diag.hex && echo OK
OK
@end cartouche
@end smallexample

@cindex @code{flash}
@noindent
@strong{Save flash memory in raw binary format to the file named @code{c:/diag flash.bin}:}

@cindex @code{flash}
@smallexample
@cartouche
$ avrdude -p m128 -c stk500 -U flash:r:"c:/diag flash.bin":r

Reading flash memory ...
Reading | ################################################## | 100% 6.90 s
Writing 19278 bytes to output file diag flash.bin

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@noindent
@strong{Read the fuses and print their values in different formats (hexadecimal, binary and octal):}

@smallexample
@cartouche
$ avrdude -cusbasp -patmega128 -qq -Ulfuse:r:-:h -Uhfuse:r:-:b -Uefuse:r:-:o

0xbf
0b11000110
0377
@end cartouche
@end smallexample

@page

@noindent
@cindex @code{flash}
@cindex @code{eeprom}
Using the default programmer, write the file @code{diag.hex} to flash, the
file @code{eeprom.hex} to EEPROM, and @strong{set the extended, high, and
low fuse bytes} to 0xff, 0x89, and 0x2e respectively:

@smallexample
@cartouche
$ avrdude -p m128 -U flash:w:diag.hex    \
                  -U eeprom:w:eeprom.hex \
                  -U efuse:w:0xff:m      \
                  -U hfuse:w:0x89:m      \
                  -U lfuse:w:0x2e:m

Processing -U flash:w:diag.hex:i
Reading 19278 bytes for flash from input file diag.hex
Writing 19278 bytes to flash
Writing | ################################################## | 100% 7.60 s
Reading | ################################################## | 100% 6.81 s
19278 bytes of flash verified

Processing -U eeprom:w:eeprom.hex:i
Reading 3328 bytes for eeprom from input file eeprom.hex
Writing 3328 bytes to eeprom
Writing | ################################################## | 100% 1.20 s
Reading | ################################################## | 100% 0.70 s
3328 bytes of eeprom verified

Processing -U efuse:w:0xff:m
Reading 1 byte for efuse from input file 0xff
Writing 1 byte (0xFF) to efuse, 1 byte written, 1 verified

Processing -U hfuse:w:0x89:m
Reading 1 byte for hfuse from input file 0x89
Writing 1 byte (0x89) to hfuse, 1 byte written, 1 verified

Processing -U lfuse:w:0x2e:m
Reading 1 byte for lfuse from input file 0x2e
Writing 1 byte (0x2E) to lfuse, 1 byte written, 1 verified

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@noindent
@strong{Write data from stdin (standard input) to EEPROM;} no error output means all went fine:

@smallexample
@cartouche
$ echo 'The quick brown fox' | avrdude -c usbasp -p attiny13 -qq -U eeprom:w:-:r
@end cartouche
@end smallexample


@noindent
@strong{Execute multiple terminal mode commands separated by semicolons:}

@smallexample
@cartouche
$ echo 'write eeprom 0 "Bonjour"; write ee 0x18 0x12345678; dump eeprom 0 0x20' | \
  avrdude -qqcdryrun -patmega328p -t

0000  42 6f 6e 6a 6f 75 72 00  ff ff ff ff ff ff ff ff  |Bonjour.........|
0010  ff ff ff ff ff ff ff ff  78 56 34 12 ff ff ff ff  |........xV4.....|
@end cartouche
@end smallexample

@page
@noindent
@strong{The same using -T:}

@smallexample
@cartouche
$ avrdude -qqcdryrun -patmega328p \
  -T 'write eeprom 0 "Bonjour"; write ee 0x18 0x12345678; dump eeprom 0 0x20'

0000  42 6f 6e 6a 6f 75 72 00  ff ff ff ff ff ff ff ff  |Bonjour.........|
0010  ff ff ff ff ff ff ff ff  78 56 34 12 ff ff ff ff  |........xV4.....|
@end cartouche
@end smallexample

@noindent
@strong{Read EEPROM and write content to stdout (standard output):}

@smallexample
@cartouche
$ avrdude -qq -cusbasp -pattiny13 -Ueeprom:r:-:i

:20000000E2809954686520717569636B2062726F776E20666F78E280990AFFFFFFFFFFFFD3
:20002000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
:00000001FF
@end cartouche
@end smallexample

@noindent
@strong{Same but redirect stderr (standard error output) to @code{/dev/null} instead of using @code{-qq}:}

@smallexample
@cartouche
$ avrdude -cusbasp -pattiny13 -Ueeprom:r:-:i 2>/dev/null

:20000000E2809954686520717569636B2062726F776E20666F78E280990AFFFFFFFFFFFFD3
:20002000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE0
:00000001FF
@end cartouche
@end smallexample

@cindex @code{flash}
@noindent
@strong{Using the Avrdude output to print strings present in flash memory:}

@smallexample
@cartouche
$ avrdude -pattiny13 -qq -U flash:r:-:r | strings

Main menu
Distance: %d cm
Exit
@end cartouche
@end smallexample

@noindent
@strong{List the serial numbers of all JTAG ICEs attached to USB;} this is
done by specifying an invalid serial number, and increasing the
verbosity level:

@smallexample
@cartouche
$ avrdude -c jtag2 -p m128 -P usb:xyz -v

Using port            : usb:xyz
Using programmer      : jtag2fast
Programmer baud rate  : 115200
Found JTAG ICE with serno: 00A000001C6B
Found JTAG ICE with serno: 00A000001C3A
Found JTAG ICE with serno: 00A000001C30
Error: did not find any (matching) USB device usb:xyz (03eb:2103)
Error: unable to open port usb:xyz for programmer jtag2fast

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@page
@noindent
Connect to the JTAG ICE mkII with a @strong{serial number ending in 1C37}
via USB, @strong{enter interactive terminal mode}, list all @strong{commands for
the connected part} and quit:

@smallexample
@cartouche
$ avrdude -c jtag2 -p m649 -P usb:1c:37 -t

avrdude> help
Valid commands:
  dump    : display a memory section as hex dump
  read    : alias for dump
  disasm  : disassemble a memory section
  write   : write data to memory; flash and EEPROM are cached
  save    : save memory segments to file
  backup  : backup memories to file
  restore : restore memories from file
  verify  : compare memories with file
  flush   : synchronise flash and EEPROM cache with the device
  abort   : abort flash and EEPROM writes, ie, reset the r/w cache
  erase   : perform a chip or memory erase
  config  : change or show configuration properties of the part
  factory : reset part to factory state
  regfile : I/O register addresses and contents
  include : include contents of named file as if it was typed
  sig     : display device signature bytes
  part    : display the current part information
  send    : send a raw command to the programmer
  verbose : display or set -v verbosity level
  quell   : display or set -q quell level for progress bars
  help    : show help message
  ?       : same as help
  quit    : synchronise flash/EEPROM cache with device and quit
  q       : abbreviation for quit

For more details about a terminal command cmd type cmd -?

Other:
  !<line> : run the shell <line> in a subshell, eg, !ls *.hex
  # ...   : ignore rest of line (eg, used as comments in scripts)

Note that not all programmer derivatives support all commands. Flash and
EEPROM type memories are normally read and written using a cache via paged
read and write access; the cache is synchronised on quit or flush commands.
The part command displays valid memories for use with dump and write.

avrdude> quit

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@page
@noindent
@strong{Factory fuse setting of a device:}

@smallexample
@cartouche
$ avrdude -patmega328p/St | grep initval

.ptmm	ATmega328P	lfuse	initval	0x62
.ptmm	ATmega328P	hfuse	initval	0xd9
.ptmm	ATmega328P	efuse	initval	0xff
.ptmm	ATmega328P	lock	initval	0xff
@end cartouche
@end smallexample

@noindent
@strong{List of all parts known to AVRDUDE:}

@smallexample
@cartouche
$ avrdude -p \*/d | cut -f2 -d"'"

ATtiny11
ATtiny12
ATtiny13
ATtiny13A
ATtiny15
AT89S51
[...]
AVR64EA48
LGT8F88P
LGT8F168P
LGT8F328P
@end cartouche
@end smallexample

@noindent
@strong{List of all modern AVR parts (with UPDI interface) known to AVRDUDE:}

@smallexample
@cartouche
$ avrdude -p \*/Ud | cut -f2 -d"'"

ATtiny202
ATtiny204
ATtiny402
[...]
AVR64EA28
AVR64EA32
AVR64EA48
@end cartouche
@end smallexample

@noindent
@strong{List of all curently plugged-in serial devices known to the libserialport library:}

@smallexample
@cartouche
$ avrdude -P \?s
Possible candidate serial ports are:
  -P /dev/ttyUSB0 or -P ft232r:A600K203
  -P /dev/ttyUSB1 or -P ft232r:MCU8
  -P /dev/ttyUSB3, -P ch340 or -P ch340-115k
Note that above ports might not be connected to a target board or an AVR programmer.
Also note there may be other direct serial ports not listed above.
@end cartouche
@end smallexample

@page
@noindent
@strong{List of all serial adapters known to AVRDUDE, i.e., defined in avrdude.conf:}

@smallexample
@cartouche
$ avrdude -P \?sa

Valid serial adapters are:
  ch340   = [usbvid 0x1a86, usbpid 0x7523]
  ch341a  = [usbvid 0x1a86, usbpid 0x5512]
  ch342   = [usbvid 0x1a86, usbpid 0x55d2]
  ch343   = [usbvid 0x1a86, usbpid 0x55d3]
  ch344   = [usbvid 0x1a86, usbpid 0x55d5]
  ch347   = [usbvid 0x1a86, usbpid 0x55da 0x55db 0x55dd 0x55de]
  ch9102  = [usbvid 0x1a86, usbpid 0x55d4]
  ch9103  = [usbvid 0x1a86, usbpid 0x55d7]
  cp210x  = [usbvid 0x10c4, usbpid 0xea60 0xea70 0xea71]
  ft2232h = [usbvid 0x0403, usbpid 0x6010]
  ft231x  = [usbvid 0x0403, usbpid 0x6015]
  ft234x  = [usbvid 0x0403, usbpid 0x6015]
  ft230x  = [usbvid 0x0403, usbpid 0x6015]
  ft232h  = [usbvid 0x0403, usbpid 0x6014]
  ft232r  = [usbvid 0x0403, usbpid 0x6001]
  ft4232h = [usbvid 0x0403, usbpid 0x6011]
  pl2303  = [usbvid 0x067b, usbpid 0x2303 0x2304 0x23a3 0x23b3 0x23c3 0x23d3 0x23e3]
@end cartouche
@end smallexample

@noindent
@strong{Output a list of non-bootloader programmers that can be used for a part.}
Note that 2>&1 folds stderr into stdout in a bash shell:
@smallexample
@cartouche
$ avrdude -c "?" -p 32ea32 2>&1 | grep -v bootloader

Valid programmers for part AVR32EA32 are:
  atmelice_updi           = Atmel-ICE (UPDI)
  dryrun                  = Emulates programming without a programmer (TPI, [...])
  jtag2updi               = JTAGv2 to UPDI bridge (UPDI)
  nanoevery               = JTAGv2 to UPDI bridge (UPDI)
  jtag3updi               = Atmel AVR JTAGICE3 (UPDI)
  pickit4_mplab_updi      = MPLAB(R) PICkit 4 (UPDI)
  pickit4_updi            = MPLAB(R) PICkit 4 (UPDI)
  pickit5_updi            = MPLAB(R) PICkit 5 (UPDI)
  pickit_basic_updi       = MPLAB(R) PICkit Basic (UPDI)
  pickit_basic_mplab_updi = MPLAB(R) PICkit Basic (UPDI)
  pkobn_updi              = Curiosity nano (nEDBG) (UPDI)
  powerdebugger_updi      = Atmel PowerDebugger (UPDI)
  serialupdi              = SerialUPDI (UPDI)
  snap_mplab_updi         = MPLAB(R) SNAP (UPDI)
  snap_updi               = MPLAB(R) SNAP (UPDI)
  xplainedmini_updi       = Atmel XplainedMini (UPDI)
  xplainedpro_updi        = Atmel XplainedPro (UPDI)
@end cartouche
@end smallexample

@page
@noindent
@strong{Print programmer definition} as understood by AVRDUDE:
@smallexample
@cartouche
$avrdude -c linuxspi/s

#------------------------------------------------------------
# linuxspi
#------------------------------------------------------------

# This programmer uses the built in linux SPI bus devices to program an
# attached AVR. The reset pin must be attached to a GPIO pin that
# is otherwise unused (see gpioinfo(1)); the SPI bus CE pins are not
# suitable since they would release /RESET too early.
#

programmer # linuxspi
    id                     = "linuxspi";
    desc                   = "Use Linux SPI device in /dev/spidev*";
    type                   = "linuxspi";
    prog_modes             = PM_TPI | PM_ISP;
    extra_features         = HAS_BITCLOCK_ADJ;
    connection_type        = spi;
    reset                  = 25;    # Pi GPIO number - this is J8:22
;
@end cartouche
@end smallexample


@noindent
@strong{Print filename of last stored sketch with its date stamp} (only with urclock programmer):
@smallexample
@cartouche
$avrdude -qq -curclock -P/dev/ttyUSB0 -pattiny13 -x showdate -x showfilename

2023-05-19 11.13 blink.hex
@end cartouche
@end smallexample

@noindent
@strong{AVRDUDE in a bash script creating terminal scripts that reset a part to factory settings:}
@smallexample
@cartouche
$ cat make-init-scripts

#!/bin/bash
mkdir /tmp/factory
for part in $(avrdude -p\*/d | grep = | cut -f2 -d"'"); do
  echo $part
  avrdude -p$part/St | grep initval | cut -f3,5 | grep -ve-1 \
  | sed "s/.*/write &/" >/tmp/factory/$part.ini
done
@end cartouche
@end smallexample

@noindent
@strong{Run above script and use one of the created terminal scripts:}
@smallexample
@cartouche
$ ./make-init-scripts

$ cat /tmp/factory/ATmega328P.ini
write lfuse	0x62
write hfuse	0xd9
write efuse	0xff
write lock	0xff

$ avrdude -qq -cusbasp -pATmega328P -t < /tmp/factory/ATmega328P.ini
@end cartouche
@end smallexample

@page
@noindent
@strong{Create a bash function @code{avrdude-elf}} that takes an elf file as input,
with support for optional Avrdude flags at the end, and @strong{writes to all memories
specified in the elf file.} In this example, the elf file did not contain any
EEPROM data:
@smallexample
@cartouche
# Show all writable memories present for the ATtiny13
$ echo $(avrdude -pattiny13/ot | grep write | cut -f3 | uniq)

eeprom flash lfuse hfuse lock

# Function that writes to all memories present in the elf file
@verbatim
avrdude-elf() {
  avrdude -cusbasp -pattiny13 -U{eeprom,flash,{l,h}fuse,lock}:w:"$1":e "${@:2}"
}
@end verbatim

# Run function where -B8 and -V is appended to the Avrdude command
$ avrdude-elf blink.elf -B8 -V

Set SCK frequency to 93750 Hz

Processing -U eeprom:w:blink.elf:e
Reading 64 bytes for eeprom from input file blink.elf
Writing 64 bytes to eeprom
Writing | ################################################## | 100% 0.08 s
64 bytes of eeprom written

Processing -U flash:w:blink.elf:e
Reading 1024 bytes for flash from input file blink.elf
Writing 1024 bytes to flash
Writing | ################################################## | 100% 0.12 s
1024 bytes of flash written

Processing -U lfuse:w:blink.elf:e
Reading 1 byte for lfuse from input file blink.elf
Writing 1 byte (0x6A) to lfuse, 1 byte written

Processing -U hfuse:w:blink.elf:e
Reading 1 byte for hfuse from input file blink.elf
Writing 1 byte (0xFF) to hfuse, 1 byte written

Processing -U lock:w:blink.elf:e
Reading 1 byte for lock from input file blink.elf
Writing 1 byte (0xFF) to lock, 1 byte written

Avrdude done.  Thank you.
@end cartouche
@end smallexample


@c
@c Node
@c
@node Terminal Mode Operation, Configuration Files, Command Line Options, Top
@chapter Terminal Mode Operation
@cindex Terminal mode operation

AVRDUDE has an interactive mode called @var{terminal mode} that is
enabled by the @option{-t} option.  This mode allows one to enter
interactive commands to display and modify the various device memories,
perform a chip erase, display the device signature bytes and part
parameters, and to send raw programming commands.  Commands and
parameters may be abbreviated to their shortest unambiguous form.
Terminal mode also supports a command history so that previously entered
commands can be recalled and edited.

@menu
* Terminal Mode Commands::
* Terminal Mode Examples::
@end menu

@node Terminal Mode Commands, Terminal Mode Examples, Terminal Mode Operation, Terminal Mode Operation
@section Terminal Mode Commands
@cindex Terminal mode commands

In this mode, AVRDUDE only initializes communication with the MCU, and then
awaits user commands on standard input.  Commands and parameters may be
abbreviated to the shortest unambiguous form.  Terminal mode provides a
command history using readline(3), so previously entered command lines can be
recalled and edited.

The @var{addr} and @var{len} parameters of the dump, read, disasm, write,
save and erase commands can be negative with the same syntax as substring
computations in perl or python. The table below details their meaning with
respect to an example memory of size @code{sz=0x800} (2048 bytes).

@multitable {0/negativ}{negativ}{@code{[addr, addr+len-1]}}{End is @code{|len|} bytes below memory size @code{sz}}
@headitem @code{addr}
@tab @code{len}
@tab Memory interval
@tab Comment
@item 0/positive
@tab  positive
@tab  @code{[addr, addr+len-1]}
@tab  Note: @code{len = end-start + 1}
@item 0/positive
@tab  negative
@tab  @code{[addr, sz+len]}
@tab  End is @code{|len|} bytes below memory size @code{sz}
@item negative
@tab  positive
@tab  @code{[sz+addr, @dots{}]}
@tab  Start is @code{|addr|} bytes below memory size
@item negative
@tab  negative
@tab  @code{[sz+addr, sz+len]}
@tab  Combining above two cases
@item any
@tab  zero
@tab  empty set
@tab  No action
@item @verb{|0x700|}
@tab  @verb{|   12|}
@tab @code{[0x700, 0x70b]}
@tab Conventional use
@item @verb{| 1024|}
@tab  @verb{| -257|}
@tab @code{[0x400, 0x6ff]}
@tab Size of memory is @code{2048} or @code{0x800}
@item @verb{| -512|}
@tab  @verb{|  512|}
@tab @code{[0x600, 0x7ff]}
@tab Last 512 bytes
@item @verb{| -256|}
@tab  @verb{|   -1|}
@tab @code{[0x700, 0x7ff]}
@tab Last 256 bytes
@item @verb{|    0|}
@tab  @verb{|   49|}
@tab @code{[0, 48]}
@tab First 49 bytes
@item @verb{|    0|}
@tab  @verb{|  -49|}
@tab @code{[0, 1999]}
@tab All but the last @code{48 = |len+1|} bytes
@item @verb{|    0|}
@tab  @verb{|   -1|}
@tab @code{[0, 0x7ff]}
@tab All memory without knowing its size
@end multitable

@noindent
The following commands are implemented for all programmers:

@table @code

@item dump @var{memory} @var{addr} @var{len}
@cindex @code{dump} @var{[memory [addr [len]]]}
Read from the specified memory interval (see above), and display in the
usual hexadecimal and ASCII form.

@item dump @var{memory} @var{addr}
@cindex @code{dump} @var{[memory [addr [len]]]}
Read from memory addr as many bytes as the most recent dump memory addr
len command with this very memory had specified (default 256 bytes), and
display them.

@item dump @var{memory}
@cindex @code{dump} @var{[memory [addr [len]]]}
Continue dumping from the memory and location where the most recent dump
command left off; if no previous dump command has addressed a memory an
error message will be shown.

@item dump
@cindex @code{dump} @var{[memory [addr [len]]]}
Continue dumping from the memory and location where the most recent dump
command left off; if no previous dump command has addressed a memory an
error message will be shown.

@item dump @var{memory} @var{addr} @dots{}
@cindex @code{dump} @var{memory} @var{[addr]} @dots{} @w{ } @w{ } @w{ }
Start reading from @var{addr}, all the way to the last memory address
(deprecated: use @code{dump @var{memory} @var{addr} -1}).

@item dump @var{memory} @dots{}
@cindex @code{dump} @var{memory} @var{[addr]} @dots{} @w{ } @w{ } @w{ }
Read all bytes from the specified memory, and display them (deprecated:
use @code{dump @var{memory} 0 -1}).

@item read
@cindex @code{read} @var{[memory [addr [len]]]}
@cindex @code{read} @var{memory} @var{[addr]} @dots{} @w{ } @w{ } @w{ }
Can be used as an alias for dump.

@item disasm @var{[options]} @var{dump-arguments}
@cindex @code{disasm} @var{[memory [addr [len]]]}
Like dump, the disasm command displays a part of the specified memory,
albeit by interpreting the memory contents as AVR opcodes and showing it
as assembler source code. Unlike dump, the disasm command has options;
these control how disasm displays its result (see below). Other than that,
the syntax of specifying the memory and its to be processed interval is
virtually the same as that of dump: the default disasm length is 32 bytes,
though, and sometimes the length can be slightly shorter or longer than
requested, so that the memory section for disasm aligns with opcodes.
Disasm options, once set, stay in force until switched off, typically by
changing the case of the option. This way, a simple disasm without further
options can be used to step through memory keeping the appearance. Disasm
knows the following options:
@table @code

@item -g
Generate avr-gcc source: this sets @code{-sOFQ} and outputs a .text preamble and
a main symbol unless the disassembly emits one itself; @code{-G} (default)
switches off @code{-g} and stops outputting a preamble

@item -A
Do not show addresses; @code{-a} (the default) shows addresses

@item -O
Do not show opcode bytes; @code{-o} (the default) show opcode bytes

@item -C
Do not show comments; @code{-c} (the default) show comments

@item -f
Show affected flags in SREG, eg, @code{---SVNZC} for the @code{sbiw}
opcode; @code{-F} (the default) do not show SREG flags

@item -q
Show the number of machine cycles that an opcode takes; @code{-Q}
(the default) do not show the cycles

@item -n
Put the opcode full name into comment (eg, subtract immediate from word);
@code{-N} (the default) do not show the full opcode names

@item -e
Put a technical explanation of the opcode into the comment, eg,
@code{Rd+1:Rd <-- Rd+1:Rd - K} for the @code{sbiw} opcode; -E (the
default) do not show technical explanations

@item -S
Use AVR instruction set style: this means that register pairs are shown
as, eg, in r31:30 instead of r30; @code{-s} (the default) use avr-gcc code
style

@item -L
Do not preprocess labels; @code{-l} (the default) preprocess jump/call
labels

@item -U
Do not show unused labels; @code{-u} (the default) show unused tagged labels

@item -d
Decode all opcodes including those that are undocumented; @code{-D} (the
default) decode only opcodes that are valid for the part

@item -z
Zap the list of jumps and calls before disassembly

@item -t=@var{file}
@cindex Tagfile
Delete symbols from a previously read tagfile, if any, and read the
tagfile @var{file} for assigning addresses to symbol names.
@end table

The tagfile is an ASCII file where each line describes a symbol for code
label addresses (@code{L}), variable addresses in flash (@code{P}) and
variables addresses in memory or I/O space (@code{M}). Hashmarks start a
tagfile comment that extends to the end of the line and is ignored by
disasm. Here is a defining example of how a tagfile looks like

@smallexample
@cartouche
0x7f54 L        putch     Outputs a char # L are code labels
0x7ffe P W 1    version16 A word integer # P are PGM data
0x7f80 P A 4    headings  Column headers # Auto-aligned strings
0x0100 M B 2048 sram      2 kB SRAM      # Memory address
@end cartouche
@end smallexample

Code labels @code{L} can be, eg, function names in program space or goto
labels.  They use up to four columns separated by white space: the
address, the letter @code{L}, the symbolic name of the label and an
optional comment column for the symbol, which is copied by disasm into the
disassembly comment column, should this label be referenced or used by the
code. Variable symbols have a @code{P} or @code{M} in the second column;
they can be bytes or words (16 bits) as determined by the letter @code{B}
or @code{W} in the third column and either single variables or arrays as
specified by the multiplicity count in the forth column. @code{P} symbols,
but not @code{M} symbols, can also encode chars (8 bits), longs (32 bits),
quads (64 bits) or octas (128 bits) as signified by the letters @code{C},
@code{L}, @code{Q} or @code{O}, respectively, or be the base location of
nul-terminated strings as encoded by @code{A} or @code{S} in the third
column. Out of necessity, the space occupied by @code{A}/@code{S} strings
varies. The difference between @code{A} and @code{S} symbols is that the
array of @code{A} strings might have an additional nul character to
auto-align the space occupied by them to an even address. The fifth column
is the symbolic name for the @code{P} or @code{M} address that can be used
by disasm to output relevant addresses symbolically. @code{P} areas
described in the tagfile also tell disasm that the corresponding area is
not code and should not be disassembled as such; instead the directives
are used for disassembly of that area. As with @code{L} labels, @code{P}
and @code{M} variables may have an optional final comment column
pertaining to the symbol that may be output in the disassembly column as
and when the corresponding variables are used.

@cindex @code{flash}
Tagfiles are useful for disassembly to make the output of disasm more
readable. They can be built manually and incrementally as one's under‐
standing of the code grows. Alternatively, the bash shell script
@code{elf2tag} can automatically generate a tag file from the .elf file
that produced the flash contents:

@smallexample
@cartouche
$ elf2tag application.elf >application.tag
@end cartouche
@end smallexample

@code{elf2tag} uses the @code{avr-objdump -d} disassembly to create
@code{L} labels and @code{avr-nm} to generate @code{M} symbols.

@item write @var{memory} @var{addr} @var{data[,]} @var{@{data[,]@}}
@cindex @code{write} @var{memory} @var{addr} @var{data[,]} @var{@{data[,]@}}
Manually program the respective memory cells, starting at address
@var{addr}, using the data items provided. The terminal implements reading
from and writing to flash, EEPROM, bootrow and usersig type memories normally
through a cache and paged access functions. All other memories are
directly written to without use of a cache. Some older parts without paged
access, depending on the programmer, might also have flash and EEPROM
directly accessed without cache.
Items @var{data} can have the following formats:

@multitable @columnfractions .32 .42 .20
@item @strong{Type}
@tab @strong{Example}
@tab @strong{Size (bytes)}
@c
@item String
@tab @code{"Hello, world\n"}
@tab varying
@c
@item File
@tab @code{C:/My\ projects/blink.hex}
@tab varying
@c
@item File with format
@tab @code{blink.hex:i}
@tab varying
@c
@item Character
@tab @code{'A'}
@tab 1
@c
@item Binary integer
@tab @code{0b101010}
@tab 1, 2, 4, or 8
@c
@item Octal integer
@tab @code{012345}
@tab 1, 2, 4, or 8
@c
@item Decimal integer
@tab @code{12345}
@tab 1, 2, 4, or 8
@c
@item Hexadecimal integer
@tab @code{0x12345}
@tab 1, 2, 4, or 8
@c
@item Decimal float
@tab @code{3.1415926}
@tab 4
@c
@item Hexadecimal float
@tab @code{0xA.8p2}
@tab 4
@c
@item Decimal double
@tab @code{3.141592653589793D}
@tab 8
@c
@item Hexadecimal double
@tab @code{0xA.8p2D}
@tab 8
@c
@end multitable

@var{data}
can be binary, octal, decimal or hexadecimal integers, floating point
numbers or C-style strings and characters. If nothing matches, @code{data}
will be interpreted as a name of a file containing data, which will be
read and inserted at this point. In order to force the interpretation of a
data item as file, e.g., when the file name would be understood as a
number otherwise, the file name can be given a @code{:}@emph{f} format
specifier. In absence of a format suffix, the terminal will try to
auto-detect the file format.

A file name that starts with @code{urboot:} autogenerates a read-only
urboot bootloader file. Try for example the terminal command @code{write
flash urboot:help} for a list of features that determine the contents of
the bootloader. @xref{Autogenerated Files} for detailed documentation. It
is worth noting here that writing @code{urboot:...} files to flash in the
terminal does @emph{not} write the necessary fuses for the bootloader to
work (in contrast to @code{-U} operations).

For integers, an optional case-insensitive suffix specifies the data size:

@multitable {@code{H} or @code{S}}{8 bytes (64 bits) }
@item @code{LL}
@tab 8 bytes (64 bits)
@item @code{L}
@tab 4 bytes (32 bits)
@item @code{H} or @code{S}
@tab 2 bytes (16 bits)
@item @code{HH}
@tab 1 byte (8 bits)
@end multitable

Suffix @code{D} indicates a 64-bit double, @code{F} a 32-bit float, whilst a
floating point number without suffix defaults to 32-bit float. Hexadecimal
floating point notation is supported. An ambiguous trailing suffix, e.g.,
@code{0x1.8D}, is read as no-suffix float where @code{D} is part of the
mantissa; use a zero exponent @code{0x1.8p0D} to clarify.

An optional @code{U} suffix makes integers unsigned. Ordinary @code{0x}
hexadecimal and @code{0b} binary integers are always treated as unsigned.
@code{+0x}, @code{-0x}, @code{+0b} and @code{-0b} numbers with an explicit
sign are treated as signed unless they have a @code{U} suffix. Unsigned
integers cannot be larger than 2^64-1. If @var{n} is an unsigned integer
then @var{-n} is also a valid unsigned integer as in C. Signed integers
must fall into the [-2^63, 2^63-1] range or a correspondingly smaller
range when a suffix specifies a smaller type.

Ordinary @code{0x} hexadecimal and @code{0b} binary integers with @var{n}
hex digits (counting leading zeros) use the smallest size of one, two,
four and eight bytes that can accommodate any n-digit hexadecimal/binary
integer. If an integer suffix specifies a size explicitly the
corresponding number of least significant bytes are written, and a warning
shown if the number does not fit into the desired representation.
Otherwise, unsigned integers occupy the smallest of one, two, four or
eight bytes needed. Signed numbers are allowed to fit into the smallest
signed or smallest unsigned representation: For example, @code{255} is
stored as one byte as @code{255U} would fit in one byte, though as a
signed number it would not fit into a one-byte interval [-128, 127]. The
number @code{-1} is stored in one byte whilst @code{-1U} needs eight bytes
as it is the same as @code{0xFFFFffffFFFFffffU}.

One trailing comma at the end of data items is ignored to facilitate copy
and paste of lists.

@item write @var{memory} @var{data}
@cindex @code{write} @var{memory} @var{data}
The start address may be omitted if the size of the memory being written
to is one byte. @var{data} can be anything including a file.

@item write @var{memory} @var{file}
@cindex @code{write} @var{memory} @var{file}
The start address may be omitted when a file is written to the memory.

@item write @var{memory} @var{addr} @var{len} @var{data[,]} @var{@{data[,]@}} @dots{}
@cindex @code{write} @var{memory} @var{addr} @var{len} @var{data[,]} @var{@{data[,]@}} @dots{} @w{ }
The ellipsis @dots{} form writes the data to the entire memory intervall
addressed by @var{addr len} and, if necessary, pads the remaining space by
repeating the last data item. The fill write command does not write beyond
the specified memory area even if more data than needed were given.

@item save @var{memory} @var{@{addr len@}} @var{file[:format]}
@cindex @code{save} @var{memory} @var{@{addr len@}} @var{file[:format]}
Save one or more memory segments to a file in a format specified by the
@code{:}format letter. The default is @code{:r} for raw binary. Each
memory segment is described by an address and length pair. In absence of
any memory segments the entire memory is saved to the file. Only Motorola
S-Record (@code{:s}) and Intel Hex (@code{:i} or @code{:I}) formats store
address information with the saved data.  Avrdude cannot currently save
ELF file formats. All the other file formats lose the address information
and concatenate the chosen memory segments into the output file. If the
file name is - then avrdude writes to stdout.

@item backup @var{memlist} @var{file[:format]}
@cindex @code{backup} @var{memlist} @var{file[:format]}
Backup one or more memories to the specified file using the selected
format. The default format for a single-memory backup is @code{:r} (raw
binary); for multi-memory backups it is @code{:I} (Intel Hex with
comments). @var{Memlist} can be a comma separated list of memories just as
in the @code{-U} command line argument. @code{backup} flushes the cache
before reading memories.

@item restore @var{memlist} @var{file[:format]}
@cindex @code{restore} @var{memlist} @var{file[:format]}
Restore one or more memories from the specified file. It is the user's
responsibility to erase memories as needed beforehand: some paged memories
look like NOR-memory when using certain programmers, meaning programming
cannot set bits to 1 (eg, flash under most programmers). These memories
need to be erased beforehand using the erase command (see below). The
format only needs to be specified if it cannot be automatically detected,
eg, when the file is @code{-} for standard input. @var{Memlist} can be a
comma separated list of memories just as in the @code{-U} command line
argument. @code{restore} flushes the cache before writing memories and
resets the cache after writing memories. Note that restoring read-only
memories verifies file contents with the corresponding microprocessor's
memories.

@item verify @var{memlist} @var{file[:format]}
@cindex @code{verify} @var{memlist} @var{file[:format]}
Compare one or more memories with the specified file. Memlist can be a
comma separated list of memories just as in the @code{-U} command line
argument. @code{verify} flushes the cache before verifying memories.

@cindex @code{erase}
@cindex @code{flash}
@cindex @code{bootrow}
@cindex @code{eeprom}
@item erase
Perform a chip erase and discard all pending writes to flash, EEPROM and bootrow.
Note that EEPROM will be preserved if the EESAVE fuse bit is active, ie, had
a corresponding value at the last reset prior to the operation.

@item erase @var{memory}
@cindex @code{erase} @var{memory} @var{[addr len]}
Erase the entire specified memory.

@item erase @var{memory} @var{addr} @var{len}
@cindex @code{erase} @var{memory} @var{[addr len]}
Erase a section of the specified memory.

@item flush
@cindex @code{flush}
@cindex @code{usersig}
@cindex @code{bootrow}
@cindex @code{eeprom}
Synchronise with the device all pending writes to flash, EEPROM, bootrow and
usersig. With some programmer and part combinations, flash (and sometimes
EEPROM, too) looks like a NOR memory, i.e., a write can only clear bits,
never set them. For NOR memories a page erase or, if not available, a chip
erase needs to be issued before writing arbitrary data. Usersig is
unaffected by a chip erase. When a memory looks like a NOR
memory, either page erase is deployed (e.g., with parts that have PDI/UPDI
interfaces), or if that is not available, both EEPROM and flash caches are
fully read in, a chip erase command is issued and both EEPROM and flash
are written back to the device. Hence, it can take minutes to ensure that
a single previously cleared bit is set and, therefore, this routine should
be called sparingly.

@cindex @code{flush}
@cindex @code{usersig}
@cindex @code{bootrow}
@cindex @code{eeprom}
@cindex @code{abort}
@item abort
Normally, caches are only ever actually written to the device when using
@code{flush}, at the end of the terminal session after typing @code{quit},
or after EOF on input is encountered. The @code{abort} command resets the
cache discarding all previous writes to the flash, EEPROM, bootrow and
usersig cache.

@item config @var{[-f|-a|-v]}
@cindex @code{config} @var{[-f|-a|-v]}
Show all configuration properties of the part; these are usually bitfields
in fuses or lock bits bytes that can take on values, which typically have
a mnemonic name. Each part has their own set of configurable items.  The
option @code{-f} groups the configuration properties by the fuses and lock
bits byte they are housed in, and shows the current value of these
memories as well. Config @code{-a} outputs an initialisation script with
all properties and all possible respective assignments. The currently
assigned mnemonic values are the ones that are not commented out. The
option @code{-v} increases the verbosity of the output of the config
command.

@item config @var{[-f|-v]} @var{property} @var{[-f|-v]}
@cindex @code{config} @var{[-f|-v]} @var{property} @var{[-f|-v]}
Show the current value of the named configuration property. Wildcards or
initial strings are permitted (but not both), in which case the current
values of all matching properties are displayed.

@item config @var{[-f|-v]} @var{property=} @var{[-f|-v]}
@cindex @code{config} @var{[-f|-v]} @var{property=} @var{[-f|-v]}
Show all possible values of the named configuration property (notice the
trailing @code{=}). The one that is currently set is the only one not
commented out. As before, wildcards or initial strings are permitted.

@item config @var{[-f|-v|-c]} @var{property=value} @var{[-f|-v|-c]}
@cindex @code{config} @var{[-f|-v|-c]} @var{property=value} @var{[-f|-v|-c]}
Modify the named configuration property to the given value. The
corresponding fuse or lock bits will be changed immediately but the change
will normally only take effect the next time the part is reset, at which
point the fuses and lock bits are utilised. Value can either be a valid
integer or one of the symbolic mnemonics, if known. Wildcards or initial
strings are permitted for either the property or the assigned mnemonic
value, but an assignment only happens if both the property and the name
can be uniquely resolved. Option @code{-v} shows the value of the assigned
configuration property by reading it again from the fuse. In absence of
@code{-v} the option @code{-c} confirms the new value of the configuration
property only if it has changed.

It is quite possible, as is with direct writing to the underlying fuses
and lock bits, to brick a part, i.e., make it unresponsive to further
programming with the chosen programmer: here be dragons.

@cindex @code{eeprom}
@cindex @code{factory reset}
@item factory reset
Resets the connected part to factory state as far as possible
(bootloaders, for example, cannot write fuses and may not have a means to
erase EEPROM). This command may change the clock frequency F_CPU of the
part after the next MCU reset when the changed fuse values come into
effect. As such, this may require that future avrdude calls use a
different bit clock rate up to F_CPU/4 for the programmer next time. Note
that the command @code{factory} can be abbreviated but the required
argument @code{reset} needs to be spelled out in full.

@item regfile @var{[opts]}
@cindex @code{regfile} @var{[opts]}
@code{regfile} with no further argument displays the register file of a
part, i.e., all register names and their contents in  @code{io} memory, if
possible: note that external programming cannot read the registers of
classic parts (ISP or TPI interfaces).

Option @code{-a} displays the register I/O addresses in addition;
@code{-m} displays the register memory addresses used for
@code{lds}/@code{sts} opcodes instead of the I/O addresses. Option
@code{-s} also shows the size of the register in bytes whilst @code{-v}
shows a slightly expanded register explanation alongside each register.

@item regfile @var{[opts]} @var{reg} @var{[opts]}
@cindex @code{regfile} @var{[opts]} @var{reg} @var{[opts]}
@code{regfile} together with a register name @var{reg} shows all those
registers that are matched by @var{reg}. Wildcards or partial strings are
permitted but not both. Register names have the form @var{module.name} or
@var{module.instance.name}. If the provided @var{reg} is a full, existing
register name, e.g., @code{porta.out} then that is the only register that
is displayed even though that might be a partial name of another register,
eg, @code{porta.outdir}. If the provided @var{reg} is the same as
@var{instance.name} or @var{name} then partial matching is no longer
utilised and all module registers with that exact @var{instance.name} or
@var{name} are shown. Partial matching can be forced through use of
wildcards, e.g., using @code{porta.out*}

@item regfile @var{[opts]} @var{reg}=@var{value} @var{[opts]}
@cindex @code{regfile} @var{[opts]} @var{reg}=@var{value} @var{[opts]}
This sets a single register addressed by @var{reg} to the given
@var{value}. Only external programming of modern parts (those with UPDI
interface) can read from and write to register io memory, but as that
memory is volatile, the contents will be lost after reset.

@item include @var{[opts]} @var{file}
@cindex @code{include} @var{[opts]} @var{file}
Include contents of the named file @var{file} as if it was typed. This is
useful for batch scripts, e.g., recurring initialisation code for fuses. The
include option @code{-e} prints the lines of the file as comments before
processing them; on a non-zero verbosity level the line numbers are
printed, too.

@item signature
@cindex @code{signature}
Display the device signature bytes.

@item part @var{[opts]}
@cindex @code{part} @var{[opts]}
@cindex Programming mode
@cindex Variants of parts
Display the current part information, including supported programming modes,
memory and variants tables. Use @var{-m} to only print the memory table,
and @var{-v} to only print the variants table.

@item verbose @var{]level]}
@cindex @code{verbose} @var{]level]}
Change (when @var{level} is provided), or display the verbosity
level.
The initial verbosity level is controlled by the number of @code{-v} options
given on the command line.

@item quell @var{[level]}
@cindex @code{quell} @var{[level]}
Change (when @var{level} is provided), or display the quell
level. 1 is used to suppress progress reports. 2 or higher yields
progressively quieter operations. The initial quell level is controlled
by the number of @code{-q} options given on the command line.

@item ?
@itemx help
Give a short on-line summary of the available commands.

@item quit
@cindex @code{quit}
Leave terminal mode and thus AVRDUDE.

@item q
Can be used as an alias for @code{quit}.

@item !@var{line}
@cindex @code{!} (subshell)
Run the shell @var{line} in a subshell, e.g., @code{!ls *.hex}. Subshell
commands take the rest of the line as their command. For security reasons,
they must  be enabled explictly by putting @code{allow_subshells = yes;}
into your @code{$@{HOME@}/.config/avrdude/avrdude.rc} or
@code{$@{HOME@}/.avrduderc} file.

@item # @var{comment}
Place comments onto the terminal line (useful for scripts).

@end table

@noindent
In addition, the following commands are supported on some programmers:

@table @code

@item pgerase @var{memory} @var{addr}
@cindex @code{pgerase} @var{memory} @var{addr}
Erase one page of the memory specified.

@item send @var{b1} @var{b2} @var{b3} @var{b4}
@cindex @code{send} @var{b1} @var{b2} @var{b3} @var{b4}
Send raw instruction codes to the AVR device. If you need access to a
feature of an AVR part that is not directly supported by AVRDUDE, this
command allows you to use it, even though AVRDUDE does not implement the
command. When using direct SPI mode, up to 3 bytes
can be omitted.

@item spi
@cindex @code{spi}
Enter direct SPI mode.  The @emph{pgmled} pin acts as chip select.
@emph{Only supported on parallel bitbang programmers, and partially by USBtiny.}
Chip Select must be externally held low for direct SPI when
using USBtinyISP, and send must be a multiple of four bytes.

@item pgm
@cindex @code{pgm}
Return to programming mode (from direct SPI mode).

@item vtarg @var{voltage}
@cindex @code{vtarg} @var{voltage}
Set the target's supply voltage to @var{voltage} Volts.

@item varef @var{[channel]} @var{voltage}
@cindex @code{varef} @var{[channel]} @var{voltage}
Set the adjustable voltage source to @var{voltage} Volts.
This voltage is normally used to drive the target's
@emph{Aref} input on the STK500 and STK600.
The STK600 offers two reference voltages, which can be
selected by the optional parameter @var{channel} (either
0 or 1).

@item fosc @var{freq}[@code{M}|@code{k}]
@cindex @code{fosc} @var{freq}[@code{M}|@code{k}]
Set the programming oscillator to @var{freq} Hz.
An optional trailing letter @code{M}
multiplies by 1E6, a trailing letter @code{k} by 1E3.

@item fosc off
@cindex @code{fosc off}
Turn the programming oscillator off.

@item sck @var{period}
@cindex @code{sck} @var{period}
Set the SCK clock period to @var{period} microseconds.
Note that some official Microchip programmers store the bitclock setting and
will continue to use it until a diferent value is provided. See
@code{-B bitclock} for more information.

@item parms
@cindex @code{parms}
Display programmer specific parameters.

@end table

@page

@c
@c Node
@c
@node Terminal Mode Examples,  , Terminal Mode Commands, Terminal Mode Operation
@section Terminal Mode Examples
@cindex Terminal mode examples

@noindent
@strong{Enter terminal, display part parameters, modify EEPROM, perform a chip erase and quit:}

@cindex @code{part}
@smallexample
@cartouche
$ avrdude -qq -c usbasp -p atmega328p -t

avrdude> part
ATmega328P with programming modes ISP, HVPP, debugWIRE, SPM

Memory        Size  Pg size
---------------------------
eeprom        1024        4
flash        32768      128
efuse            1        1
hfuse            1        1
lfuse            1        1
lock             1        1
signature        3        1
calibration      1        1
io             224        1
sram          2048        1

Variants         Package  F max   T range         V range
----------------------------------------------------------------
ATmega328P       N/A      20 MHz  [-40 C,   N/A]  [1.8 V, 5.5 V]
ATmega328P-15MZ  MLF32    20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-AN    TQFP32   20 MHz  [-40 C, 105 C]  [1.8 V, 5.5 V]
ATmega328P-ANR   TQFP32   20 MHz  [-40 C, 105 C]  [1.8 V, 5.5 V]
ATmega328P-AU    TQFP32   20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-AUR   TQFP32   20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-MMH   MLF28    20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-MMHR  MLF28    20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-MN    QFN32    20 MHz  [-40 C, 105 C]  [1.8 V, 5.5 V]
ATmega328P-MNR   MLF32    20 MHz  [-40 C, 105 C]  [1.8 V, 5.5 V]
ATmega328P-MU    MLF32    20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-MUR   MLF32    20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]
ATmega328P-PN    PDIP28   20 MHz  [-40 C, 105 C]  [1.8 V, 5.5 V]
ATmega328P-PU    PDIP28   20 MHz  [-40 C,  85 C]  [1.8 V, 5.5 V]

avrdude> dump eeprom 0 16
0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> write eeprom 0 1 2 3 4 0xcafe "Avrdude"

avrdude> dump eeprom 0 16
0000  01 02 03 04 fe ca 41 76  72 64 75 64 65 00 ff ff  |......Avrdude...|

avrdude> flush

avrdude> erase
erasing chip ...

avrdude> dump eeprom 0 16
0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> quit
@end cartouche
@end smallexample

@page
@noindent
@strong{Program the fuse bits of an ATmega328P with a fuse calculator}
@itemize @bullet
@item Enable full-swing high speed external crystal with long startup time
@item Remove default clock division by 8
@item Make reset jump to bootloader
@item Set the size of the bootloader to 512 bytes (256 words)
@item Enable brown-out detection at 2.7 V
@end itemize

@noindent
First display the factory defaults, then consult an external fuse
calculator, select the ATmega328P part, find above settings, note the
ensuinig new values for the three fuses and reprogram:

@smallexample
@cartouche
$ avrdude -c usbasp -p atmega328p -t

avrdude> dump efuse
Reading | ################################################## | 100% 0.00 s
0000  ff                                                |.               |

avrdude> dump hfuse
Reading | ################################################## | 100% 0.00 s
0000  d9                                                |.               |

avrdude> dump lfuse
Reading | ################################################## | 100% 0.00 s
0000  62                                                |b               |

avrdude> #
avrdude> # Consult external fuse calculator
avrdude> #
avrdude> #

avrdude> write efuse 0xfd
Writing | ################################################## | 100% 0.01 s

avrdude> write hfuse 0xde
Writing | ################################################## | 100% 0.01 s

avrdude> write lfuse 0xf7
Writing | ################################################## | 100% 0.01 s

avrdude> quit

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@page
@noindent
@strong{Program the fuse bits of an ATmega328P with the config command}

@smallexample
@cartouche
$ avrdude -qq -c usbasp -p atmega328p -t

avrdude> # Show all configurations
avrdude> config
config sut_cksel=intrcosc_8mhz_6ck_14ck_65ms # 34
config ckout=co_disabled # 1
config ckdiv8=by_8 # 0
config bootrst=application # 1
config bootsz=bs_2048w # 0
config eesave=ee_erased # 1
config wdton=wdt_programmable # 1
config spien=isp_enabled # 0
config dwen=dw_off # 1
config rstdisbl=external_reset # 1
config bodlevel=bod_disabled # 7
config lb=no_lock # 3
config blb0=no_lock_in_app # 3
config blb1=no_lock_in_boot # 3

avrdude> # Show possible values for full-swing external crystal
avrdude> config sut_cksel=extfs
avrdude warning: (config) ambiguous; known sut_cksel extfs symbols are:
 - sut_cksel=extfsxtal_258ck_14ck_4ms1 #  6
 - sut_cksel=extfsxtal_1kck_14ck_65ms  #  7
 - sut_cksel=extfsxtal_258ck_14ck_65ms # 22
 - sut_cksel=extfsxtal_16kck_14ck_0ms  # 23
 - sut_cksel=extfsxtal_1kck_14ck_0ms   # 38
 - sut_cksel=extfsxtal_16kck_14ck_4ms1 # 39
 - sut_cksel=extfsxtal_1kck_14ck_4ms1  # 54
 - sut_cksel=extfsxtal_16kck_14ck_65ms # 55

avrdude> # Set the one with appropriate startup times
avrdude> c su=55

avrdude> # Unprogram clock division by 8, make reset jump to bootloader
avrdude> c ckdiv8=1
avrdude> c bootrst=boot
avrdude> c bootsz=bs_256w

avrdude> # Query which bod levels exist; set brown-out at 2.7 V
avrdude> c bodlevel=
# conf bodlevel=bod_4v3      # 4
# conf bodlevel=bod_2v7      # 5
# conf bodlevel=bod_1v8      # 6
config bodlevel=bod_disabled # 7 (factory)
avrdude> c bod=*2v7

avrdude> quit
@end cartouche
@end smallexample

@page
@noindent
@strong{Show and change registers}

@smallexample
@cartouche
$ avrdude -c xplainedmini_updi -p ATtiny817 \
  -T "reg ctrlc" -T "reg usart0.baud=0x1234" -T "reg -asv usart0"

Processing -T reg ctrlc
0x00 portmux.ctrlc
0x00 adc0.ctrlc
0x03 usart0.ctrlc
0x00 tca0.ctrlc
0x00 tcd0.ctrlc

Processing -T reg usart0.baud=0x1234

Processing -T reg -asv usart0
I/O 0x800: (1)   0x00 usart0.rxdatal  # Receive data low byte
I/O 0x801: (1)   0x00 usart0.rxdatah  # Receive data high byte
I/O 0x802: (1)   0x00 usart0.txdatal  # Transmit data low byte
I/O 0x803: (1)   0x00 usart0.txdatah  # Transmit data high byte
I/O 0x804: (1)   0x20 usart0.status   # Status register
I/O 0x805: (1)   0x00 usart0.ctrla    # Control register A
I/O 0x806: (1)   0x00 usart0.ctrlb    # Control register B
I/O 0x807: (1)   0x03 usart0.ctrlc    # Control register C
I/O 0x808: (2) 0x1234 usart0.baud     # Baud rate register (16 bits)
I/O 0x80b: (1)   0x00 usart0.dbgctrl  # Debug control register
I/O 0x80c: (1)   0x00 usart0.evctrl   # Event control register
I/O 0x80d: (1)   0x00 usart0.txplctrl # IRCOM transmitter pulse length control register
I/O 0x80e: (1)   0x00 usart0.rxplctrl # IRCOM receiver pulse length control register

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@strong{Show register file of a classic part}

@smallexample
@cartouche
$ avrdude -qq -p ATtiny11 -c dryrun -T "regfile -av"

I/O 0x08: ac.acsr     # Analog comparator control and status register
I/O 0x16: portb.pinb  # Port B input register
I/O 0x17: portb.ddrb  # Port B data direction register
I/O 0x18: portb.portb # Port B data register
I/O 0x21: wdt.wdtcr   # Watchdog timer control register
I/O 0x32: tc0.tcnt0   # Timer/counter 0
I/O 0x33: tc0.tccr0   # T/C 0 control register
I/O 0x34: cpu.mcusr   # MCU status register
I/O 0x35: cpu.mcucr   # MCU control register
I/O 0x38: tc0.tifr    # T/C interrupt flag register
I/O 0x39: tc0.timsk   # T/C interrupt mask register
I/O 0x3a: exint.gifr  # General interrupt flag register
I/O 0x3b: exint.gimsk # General interrupt mask register
I/O 0x3f: cpu.sreg    # Status register
@end cartouche
@end smallexample

@page

@noindent
The following example demonstrates @strong{negative address and length
bytes}, and the @strong{fill form of the @code{write} command using an
ellipis ...} where the last data item provided is used to fill up the
indicated memory range.

@smallexample
@cartouche
$ avrdude -c usbasp -p atmega328p -t

avrdude> dump flash -64 -33
Reading | ################################################## | 100% 0.02 s
7fc0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
7fd0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> dump flash -32 -1
Reading | ################################################## | 100% 0.00 s
7fe0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
7ff0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> write flash -64 1234567890 'A' 'V' 'R' 2.718282 0xaa 0xbb 0xcc "Hello World!"
Caching | ################################################## | 100% 0.00 s

avrdude> write flash -32 -1 0x01 0b00000010 0b11 0x04 0x05 ...
Caching | ################################################## | 100% 0.00 s

avrdude> read flash -64 -33
Reading | ################################################## | 100% 0.00 s
7fc0  d2 02 96 49 41 56 52 55  f8 2d 40 aa bb cc 48 65  |...IAVRU.-@@...He|
7fd0  6c 6c 6f 20 57 6f 72 6c  64 21 00 ff ff ff ff ff  |llo World!......|

avrdude> read flash -32 -1
Reading | ################################################## | 100% 0.00 s
7fe0  01 02 03 04 05 05 05 05  05 05 05 05 05 05 05 05  |................|
7ff0  05 05 05 05 05 05 05 05  05 05 05 05 05 05 05 05  |................|

avrdude> flush
Synching cache to device ...
Writing | ################################################## | 100% 0.05 s

avrdude> quit

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@page

@cindex @code{disasm} example

@cindex @code{flash}
@noindent @strong{Disassembe the flash contents of an ATtiny13A,} write
the output to file @code{blink.S}, compile to `blink.elf` and verify that
the flash contents of the ATtiny13A is the same as the one given by the
compiled @code{blink.elf}. Then @code{cat} the disassembled @code{blink.S}
to stdout.

@smallexample
@cartouche
$ avrdude -qq -p t13a -c avrisp2 -T "disasm -g flash 0 -1" >blink.S
$ avr-gcc -mmcu=attiny13a -nostdlib -Wl,--section-start=.text=0x0000 blink.S -o bl.elf
$ avrdude -qq -p t13a -c avrisp2 -U flash:v:bl.elf && echo OK
OK

$ cat blink.S

       .equ    io.pinb, 0x16
       .equ    io.ddrb, 0x17

       .text
main:
L000:  rjmp    Label1               ; L016
L002:  rjmp    Label0               ; L014
L004:  rjmp    Label0               ; L014
L006:  rjmp    Label0               ; L014
L008:  rjmp    Label0               ; L014
L00a:  rjmp    Label0               ; L014
L00c:  rjmp    Label0               ; L014
L00e:  rjmp    Label0               ; L014
L010:  rjmp    Label0               ; L014
L012:  rjmp    .+0                  ; L014

; Rjmp from L002, L004, L006, L008, L00a, L00c, L00e, L010
Label0:
L014:  reti

Label1:                             ; Rjmp from L000
L016:  sbi     io.ddrb, 2           ; Bit 2 = 0x04

Label2:                             ; Rjmp from L024
L018:  ldi     r29, 0x1e            ; 30

Label3:                             ; Brne from L01c, L020
L01a:  sbiw    r30, 0x01            ; 1
L01c:  brne    Label3               ; L01a
L01e:  dec     r29
L020:  brne    Label3               ; L01a
L022:  sbi     io.pinb, 2           ; Bit 2 = 0x04
L024:  rjmp    Label2               ; L018

L026:  .fill   493, 2, 0xffff
@end cartouche
@end smallexample

@page

@noindent
@strong{Mixing terminal commands and @code{-U} memory operations:} the
example below burns a bootloader, uses a terminal line to write
application data to flash, loads the application, configures the brownout
detection level to 2.7 V and, finally, stores the full flash as new hex
file. Note the use of different quotation marks in @code{bash} to pass the
terminal command lines as single entity to AVRDUDE.

@smallexample
@cartouche
$ avrdude -qc dryrun -p m328p \
          -U urboot_m328p_1s_autobaud_uart0_pr_ee_ce.hex \
          -T 'write flash 0x7D00 0xc0cac01a 0xcafe "secret Coca Cola recipe"' \
          -U flash:w:cola-vending-machine.hex \
          -T "config -v bod=*2v7" \
          -U flash:r:app+data.hex:I

Processing -U flash:w:urboot_m328p_1s_autobaud_uart0_pr_ee_ce.hex:i
Reading 368 bytes for flash from input file urboot_m328p_1s_autobaud_uart0_pr_ee_ce.hex
Writing 368 bytes to flash, 368 bytes written, 368 verified

Processing -T write flash 0x7D00 0xc0cac01a 0xcafe "secret Coca Cola recipe"
Synching cache to device ... done

Processing -U flash:w:cola-vending-machine.hex:i
Reading 736 bytes for flash from input file cola-vending-machine.hex
Writing 736 bytes to flash, 736 bytes written, 736 verified

Processing -T config -v bod=*2v7
config bodlevel=bod_2v7 # 5

Processing -U flash:r:app+data.hex:I
Reading flash memory ...
Writing 32768 bytes to output file app+data.hex

Avrdude done.  Thank you.
@end cartouche
@end smallexample


@page

@c
@c Node
@c
@node Configuration Files, Autogenerated Files, Terminal Mode Operation, Top
@cindex Configuration files
@cindex @code{avrdude.conf}
@chapter Configuration Files


@noindent
AVRDUDE reads a configuration file upon startup which describes all of
the parts and programmers that it knows about.  The advantage of this is
that if you have a chip that is not currently supported by AVRDUDE, you
can add it to the configuration file without waiting for a new release
of AVRDUDE. Likewise, if you have a parallel port programmer that is
not supported, chances are that you can copy an
existing programmer definition and, with only a few changes, make your
programmer work.

AVRDUDE first looks for a system wide configuration file in a platform
dependent location.  On Unix, this is usually
@code{/usr/local/etc/avrdude.conf}@xref{Unix}, whilst on Windows it is usually in the
same location as the executable file.  The full name of this file can be
specified using the @option{-C} command line option.  After parsing the system wide
configuration file, AVRDUDE looks for a per-user configuration
file to augment or override the system wide defaults.  On Unix, the
per-user file is @code{$@{XDG_CONFIG_HOME@}/avrdude/avrdude.rc}, whereas
if @code{$@{XDG_CONFIG_HOME@}} is either not set or empty,
@code{$@{HOME@}/.config/} is used instead. If that does not exist
@code{.avrduderc} within the user's home directory is used. On Windows,
this file is the @code{avrdude.rc} file located in the same directory as
the executable.

@menu
* AVRDUDE Defaults::
* Programmer Definitions::
* Serial Adapter Definitions::
* Part Definitions::
* Other Notes::
@end menu

@c
@c Node
@c
@node AVRDUDE Defaults, Programmer Definitions, Configuration Files, Configuration Files
@section AVRDUDE Defaults
@cindex AVRDUDE defaults

@table @code

@item avrdude_conf_version = "@var{build-time-version}";
Automatically set during the build process.

@item default_parallel = "@var{default-parallel-device}";
@cindex @code{default_parallel}
Assign the default parallel port device.  Can be overridden using the
@option{-P} option.

@item default_serial = "@var{default-serial-device}";
@cindex @code{default_serial}
Assign the default serial port device.  Can be overridden using the
@option{-P} option.

@item default_linuxgpio = "@var{default-linuxgpio-device}";
@cindex @code{default_linuxgpio}
Assign the default gpiochip for linuxgpio's libgpiod mode,
e.g. "gpiochip0".  Ignored for linuxgpio's sysfs mode.  Can be overridden
using the @option{-P} option.

@item default_programmer = "@var{default-programmer-id}";
@cindex @code{default_programmer}
Assign the default programmer id.  Can be overridden using the @option{-c}
option.

@item default_baudrate = "@var{default-baudrate}";
Assign the default baudrate value that will be used if the programmer doesn't
provide its specific @code{baudrate} entry. Can be overridden using the @option{-b}
option.

@item default_bitclock = "@var{default-bitclock}";
@cindex @code{default_bitclock}
Assign the default bitclock value.  Can be overridden using the @option{-B}
option.

@item allow_subshells = @var{no};
@cindex @code{allow_subshells}
Whether or not AVRDUDE's interactive terminal is allowed to use subshell
@code{!} commands. This defaults to no for security reasons, e.g., in the
rare case @code{avrdude -t} is set up with attached hardware to provide a
web service, remote ssh or a login on a PC instead of a shell, say, for
demo or training purposes. In almost all other cases this can be
overridden in the per-user @code{avrddude.rc} or @code{.avrduderc}
configuration file with @var{yes}.

@end table


@c
@c Node
@c
@node Programmer Definitions, Serial Adapter Definitions, AVRDUDE Defaults, Configuration Files
@cindex @code{programmer}
@section Programmer Definitions
@cindex Programmer definitions

@noindent
The format of the programmer definition is as follows:

@smallexample
programmer
    parent <id>                              # optional parent
    id       = <id1> [, <id2> ... ];         # <idN> are quoted strings
    desc     = <description>;                # quoted string
    type     = <type>;                       # programmer type, quoted string
                                             # list known types with -c ?type
    prog_modes = PM_<i/f> @{| PM_<i/f>@}       # interfaces, e.g., PM_SPM|PM_PDI (1)
    is_serialadapter = <yes|no>              # programmer is also a serialadapter
    extra_features = HAS_<fea> @{| HAS_<fea>@}  # extra features, e.g., HAS_SUFFER (2)
    connection_type = parallel | serial | usb | spi
    baudrate = <num>;                        # baudrate for avr910-programmer
    vcc      = <pin1> [, <pin2> ... ];       # pin number(s) (3)
    buff     = <pin1> [, <pin2> ... ];       # pin number(s)
    reset    = <pin>;                        # pin number
    sck      = <pin>;                        # pin number
    sdo|pico = <pin>;                        # pin number
    sdi|poci = <pin>;                        # pin number
    tck      = <pin>;                        # pin number
    tdi      = <pin>;                        # pin number
    tdo      = <pin>;                        # pin number
    tms      = <pin>;                        # pin number
    errled   = <pin>;                        # pin number
    rdyled   = <pin>;                        # pin number
    pgmled   = <pin>;                        # pin number
    vfyled   = <pin>;                        # pin number
    usbvid   = <hexnum>;                     # USB vendor ID
    usbpid   = <hexnum> [, <hexnum> ...];    # USB product ID (4)
    usbdev   = <interface>;                  # USB interface or other device info
    usbvendor = <vendorname>;                # USB Vendor Name
    usbproduct = <productname>;              # USB Product Name
    usbsn    = <serialno>;                   # USB Serial Number
    hvupdi_support = <num> [, <num>, ... ];  # HV support for enabling UPDI
;
@end smallexample

@noindent
If a parent is specified, all settings of it (except its ids) are used for the new
programmer. These values can be changed by new setting them for the new programmer.

@noindent
@strong{Notes}

@enumerate

@item Known programming modes are
@cindex Programming modes

@itemize @bullet
@cindex @code{PM_SPM}
@cindex SPM
@item @code{PM_SPM}: Bootloaders, self-programming with SPM opcodes or NVM Controllers
@cindex @code{PM_TPI}
@cindex TPI
@item @code{PM_TPI}: Tiny Programming Interface (t4, t5, t9, t10, t20, t40, t102, t104)
@cindex @code{PM_ISP}
@cindex ISP
@item @code{PM_ISP}: SPI programming for In-System Programming (almost all classic parts)
@cindex @code{PM_PDI}
@cindex PDI
@item @code{PM_PDI}: Program and Debug Interface (xmega parts)
@cindex @code{PM_UPDI}
@cindex UPDI
@item @code{PM_UPDI}: Unified Program and Debug Interface
@cindex @code{PM_HVSP}
@cindex HVSP
@item @code{PM_HVSP}: High Voltage Serial Programming (some classic parts)
@cindex @code{PM_HVPP}
@cindex HVPP
@item @code{PM_HVPP}: High Voltage Parallel Programming (most non-HVSP classic parts)
@cindex @code{PM_debugWIRE}
@cindex debugWIRE
@item @code{PM_debugWIRE}: Simpler alternative to JTAG (a subset of HVPP/HVSP parts)
@cindex @code{PM_JTAG}
@cindex JTAG
@item @code{PM_JTAG}: Joint Test Action Group standard (some classic parts)
@cindex @code{PM_JTAGmkI}
@cindex JTAGmkI
@item @code{PM_JTAGmkI}: Subset of @code{PM_JTAG}, older parts, Atmel ICE mkI
@cindex @code{PM_XMEGAJTAG}
@cindex XMEGAJTAG
@item @code{PM_XMEGAJTAG}: JTAG, some XMEGA parts
@cindex @code{PM_AVR32JTAG}
@cindex AVR32JTAG
@item @code{PM_AVR32JTAG}: JTAG for 32-bit AVRs
@cindex @code{PM_aWire}
@cindex aWire
@item @code{PM_aWire}: AVR32 parts
@end itemize

@item The following extra programmer features are known

@itemize @bullet
@cindex @code{HAS_SUFFER}
@cindex SUFFER
@item @code{HAS_SUFFER}: Only present on Xplained Mini/Nano programmers;
  the Super User Fantastic Feature Enable Register allows the user to modify
  the behavior of the mEDBG programmer/debugger chip, see the Xplained Mini/Nano
  documentation for more information
@cindex @code{HAS_VTARG_SWITCH}
@cindex VTARG_SWITCH
@item @code{HAS_VTARG_SWITCH}: Programer has a programmable target power switch
@cindex @code{HAS_VTARG_READ}
@cindex VTARG_READ
@item @code{HAS_VTARG_READ}: Programmer can read the target voltage
@cindex @code{HAS_VTARG_ADJ}
@cindex VTARG_ADJ
@item @code{HAS_VTARG_ADJ}: Programmer has an adjustable target power source that can
  be controlled with Avrdude
@cindex @code{HAS_FOSC_ADJ}
@cindex FOSC_ADJ
@item @code{HAS_FOSC_ADJ}: Programmer has a programable frequency generator that
  can clock an AVR directly through its XTAL1 pin
@cindex @code{HAS_VAREF_ADJ}
@cindex VAREF_ADJ
@item @code{HAS_VAREF_ADJ}: Programmer has an adjustable analog reference voltage that
  can be controlled with Avrdude
@end itemize

@item To invert the polarity of a pin, use a tilde @code{~<num>}; to invert
the polarity of all pins in a list use @code{~(<num1> [, <num2> ... ])}

@item Not all programmer types can handle a list of USB PIDs

@end enumerate

@noindent
The following programmer types are currently implemented:

@multitable @columnfractions .21 .75
@include programmer_types.texi
@end multitable

@c
@c Node
@c
@node Serial Adapter Definitions, Part Definitions, Programmer Definitions, Configuration Files
@cindex @code{serialadapter}
@section Serial Adapter Definitions
@cindex Serial adapter definitions

@noindent
The format of a serial adapter definition is as follows:

@smallexample
serialadapter
    parent <id>                               # optional serialadapter or programmer parent
    id       = <id1> [, <id2> ... ];          # <idN> are quoted strings
    desc     = <description>;                 # quoted string
    baudrate = <num>;                         # optional default baudrate, eg, in .avrduderc
    usbvid   = <hexnum>;                      # USB vendor ID
    usbpid   = <hexnum> [, <hexnum> ...];     # list of USB product IDs
    usbsn    = <serialno>;                    # USB Serial Number in per-user .avrduderc
;
@end smallexample

Technically, a @code{serialadapter} is implemented as @code{programmer}
that has only USB parameters defined. It can be used for a @code{-P
<serialadapter>[:<serial number>]} port specification instead of the
created serial port. Per-user serialadapter definitions in
@code{~/.avrduderc} or @code{avrdude.rc} files can add a serial number to
assign a particular board a specific id and default communication baud rate:

@smallexample
serialadapter parent "ft232r"
    id                     = "bike-shed-door";
    usbsn                  = "0123456789";
    baudrate               = 250000;
;
@end smallexample

@noindent
This is particularly useful for programming through a bootloader as it
allows specifying the port as @code{-P bike-shed-door} rather than having
to figure out which serial port name the operating system has assigned to
the plugged in bike-shed-door board at runtime. Note that each programmer
that defines @code{usbpid} and sets @code{is_serialadapter = yes} can also
be utilised as a serialadapter.

@c
@c Node
@c
@node Part Definitions, Other Notes, Serial Adapter Definitions, Configuration Files
@cindex @code{part}
@section Part Definitions
@cindex Part definitions

@smallexample
part
    desc             = <description>;         # quoted string, the long part name, eg, "ATmega328p"
    id               = <id>;                  # quoted string, normally an abbreviated part name
    variants         = <str1> [, <str2> ...]; # quoted strings, each starts so "<alt-name>: ..."
    family_id        = <id>;                  # quoted string, e.g., "megaAVR" or "tinyAVR"
    prog_modes       = PM_<i/f> @{| PM_<i/f>@}  # interfaces, e.g., PM_SPM|PM_ISP|PM_HVPP|PM_debugWIRE
    mcuid            = <num>;                 # unique id in 0..2039 for 8-bit AVRs
    archnum          = <num>;                 # avr-gcc architecture number; -1 if not 8-bit AVR
    n_interrupts     = <num>;                 # number of interrupts, used for vector bootloaders
    n_page_erase     = <num>;                 # if set, number of pages erased during SPM erase
    n_boot_sections  = <num>;                 # Number of boot sections
    boot_section_size = <num>;                # Size of (smallest) boot section, if any
    hvupdi_variant   = <num>;                 # numeric: -1 or 0..3; how to enable UPDI with HV
    stk500_devcode   = <num>;                 # numeric
    avr910_devcode   = <num>;                 # numeric
    is_at90s1200     = <yes/no>;              # AT90S1200 part
    signature        = <num> <num> <num>;     # signature bytes
    usbpid           = <num>;                 # DFU USB PID
    chip_erase_delay = <num>;                 # microseconds
    reset            = dedicated | io;
    retry_pulse      = reset | sck;
    # STK500 parameters (parallel programming IO lines)
    pagel            = <num>;                 # page load pin name in hex, e.g., 0xD7
    bs2              = <num>;                 # byte select 2 pin name in hex, e.g., 0xA0
    serial           = <yes/no>;              # can use serial programming
    parallel         = <yes/no/pseudo>;       # can use parallel programming
    # STK500v2 parameters, to be taken from Atmel's ATDF files
    timeout          = <num>;
    stabdelay        = <num>;
    cmdexedelay      = <num>;
    synchloops       = <num>;
    bytedelay        = <num>;
    pollvalue        = <num>;
    pollindex        = <num>;
    predelay         = <num>;
    postdelay        = <num>;
    pollmethod       = <num>;
    hvspcmdexedelay  = <num>;
    # STK500v2 HV programming parameters, from ATDFs
    pp_controlstack  = <num>, <num>, ...;     # PP only
    hvsp_controlstack = <num>, <num>, ...;    # HVSP only
    flash_instr      = <num>, <num>, <num>;
    eeprom_instr     = <num>, <num>, ...;
    hventerstabdelay = <num>;
    progmodedelay    = <num>;                 # PP only
    latchcycles      = <num>;
    togglevtg        = <num>;
    poweroffdelay    = <num>;
    resetdelayms     = <num>;
    resetdelayus     = <num>;
    hvleavestabdelay = <num>;
    resetdelay       = <num>;
    synchcycles      = <num>;                 # HVSP only
    chiperasepulsewidth = <num>;              # PP only
    chiperasepolltimeout = <num>;
    chiperasetime    = <num>;                 # HVSP only
    programfusepulsewidth = <num>;            # PP only
    programfusepolltimeout = <num>;
    programlockpulsewidth = <num>;            # PP only
    programlockpolltimeout = <num>;
    # debugWIRE and/or JTAG ICE mkII parameters, also from ATDF files
    allowfullpagebitstream = <yes/no>;
    enablepageprogramming = <yes/no>;
    idr              = <num>;                 # IO addr of IDR (OCD) reg
    rampz            = <num>;                 # IO addr of RAMPZ reg
    spmcr            = <num>;                 # mem addr of SPMC[S]R reg
    eecr             = <num>;                 # mem addr of EECR reg
    eind             = <num>;                 # mem addr of EIND reg
    mcu_base         = <num>;                 # MCU control block in ATxmega devices
    nvm_base         = <num>;                 # NVM controller in ATxmega devices
    ocd_base         = <num>;                 # OCD module in AVR8X/UPDI devices
    syscfg_base      = <num>;                 # Chip revision ID in AVR8X/UPDI devices
    ocdrev           = <num>;                 # JTAGICE3 parameter from ATDF files
    pgm_enable       = <instruction format>;
    chip_erase       = <instruction format>;
    # parameters for bootloaders
    autobaud_sync    = <num>;                 # autobaud detection byte, default 0x30
    factory_fcpu     = <num>;                 # F_CPU in Hz on reset and factory-set fuses

    memory <memstr>
        paged           = <yes/no>;           # yes/no (flash of classic parts only)
        offset          = <num>;              # memory offset
        size            = <num>;              # bytes
        page_size       = <num>;              # bytes
        num_pages       = <num>;              # numeric
        initval         = <num>;              # factory setting of fuses and lockbits
        bitmask         = <num>;              # bits used (only in fuses and lockbits)
        n_word_writes   = <num>;              # TPI only: if set, number of words to write
        min_write_delay = <num>;              # micro-seconds
        max_write_delay = <num>;              # micro-seconds
        readback        = <num> <num>;        # pair of byte values
        readback_p1     = <num>;              # byte value (first component)
        readback_p2     = <num>;              # byte value (second component)
        pwroff_after_write = <yes/no>;        # yes/no
        mode            = <num>;              # STK500 v2 file parameter from ATDF files
        delay           = <num>;              #   "
        blocksize       = <num>;              #   "
        readsize        = <num>;              #   "
        read            = <instruction format>;
        write           = <instruction format>;
        read_lo         = <instruction format>;
        read_hi         = <instruction format>;
        write_lo        = <instruction format>;
        write_hi        = <instruction format>;
        loadpage_lo     = <instruction format>;
        loadpage_hi     = <instruction format>;
        writepage       = <instruction format>;
    ;
;
@end smallexample

@noindent
If any of the above parameters are not specified, the default value of 0
is used for numerics (except for @code{mcuid}, @code{hvupdi_variant},
@code{ocdrev}, @code{initval} and @code{bitmask}, all of which default to
-1, and for @code{autobaud_sync} which defaults to 0x30) or the empty
string @code{""} for string values. If a required parameter is left empty,
AVRDUDE will complain. Almost all occurrences of numbers (with the
exception of pin numbers and where they are separated by space, e.g., in
signature and readback) can also be given as simple expressions involving
arithemtic and bitwise operators.

@menu
* Parent Part::
* Instruction Format::
@end menu

@c
@c Node
@c
@node Parent Part, Instruction Format, Part Definitions, Part Definitions
@subsection Parent Part
@cindex Parent part

@noindent
Parts can also inherit parameters from previously defined parts using
the following syntax. In this case specified integer and string values
override parameter values from the parent part. New  memory definitions
are added to the definitions inherited from the  parent. If, however, a
new memory definition refers to an existing one of the same name for
that part then, from v7.1, the existing memory definition is extended,
and components overwritten with new values. Assigning @code{NULL}
removes an inherited SPI instruction format, memory definition, control
stack, eeprom or flash instruction, e.g., as in @code{memory "efuse" =
NULL;}. The @code{variants} parameter is never inherited as it almost
always would be a mistake to do so: @code{variants} defines a string
list detailing variant names of the  part followed by an optional
colon, the package code and some absolute maximum ratings.

@noindent
Example format for part inheritance:

@smallexample
   part parent <id>                              # String identifying parent
       id               = <id>;                  # Id string for new part
       <any set of other parameters from the list above>
   ;
@end smallexample

@c
@c Node
@c
@node Instruction Format,  , Parent Part, Part Definitions
@subsection Instruction Format
@cindex Instruction format

@noindent
Instruction formats are specified as a comma separated list of string
values containing information (bit specifiers) about each of the 32 bits
of the instruction.  Bit specifiers may be one of the following formats:

@table @code

@item 1
The bit is always set on input as well as output

@item 0
The bit is always clear on input as well as output

@item x
The bit is ignored on input and output

@item a
The bit is an address bit, the bit-number matches this bit specifier's
position within the current instruction byte

@item a@var{N}
The bit is the @var{N}th address bit, bit-number = N, i.e., @code{a12}
is address bit 12 on input, @code{a0} is address bit 0.

@item i
The bit is an input data bit; as with @code{a} bits an input data bit can
optionally be followed by a bit number, here between 0 and 7, if the bit
needs to be moved to a different position in the SPI write command byte
than it appears in memory.

@item o
The bit is an output data bit; as with @code{i} bits an output data bit
can optionally be followed by a bit number; this is useful in case the
part's SPI read command places a particular bit into a different position
than the write command put it, e.g., ATtiny22L or AT90S8535 lock bits.

@end table

Each instruction must be composed of 32 bit specifiers.  The instruction
specification closely follows the instruction data provided in Atmel's
data sheets for their parts.  For example, the EEPROM read and write
instruction for an AT90S2313 AVR part could be encoded as:

@smallexample

read  = "1  0  1  0   0  0  0  0   x x x x  x x x x",
        "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

write = "1  1  0  0   0  0  0  0   x x x x  x x x x",
        "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

@end smallexample

As the address bit numbers in the SPI opcodes are highly systematic, they
don't really need to be specified. A compact version of the format
specification neither uses bit-numbers for address lines nor spaces. If such
a string is longer than 7 characters, then the characters @code{0}, @code{1},
@code{x}, @code{a}, @code{i} and @code{o} will be recognised as the
corresponding bit, whilst any of the characters @code{.}, @code{-}, @code{_}
or @code{/} can act as arbitrary visual separators, which are ignored.
Examples:

@smallexample

  loadpage_lo = "0100.0000--000x.xxxx--xxaa.aaaa--iiii.iiii";

  loadpage_lo = "0100.0000", "000x.xxxx", "xxaa.aaaa", "iiii.iiii";

@end smallexample

@c
@c Node
@c
@node Other Notes,  , Part Definitions, Configuration Files
@section Other Notes
@cindex Other notes


@itemize @bullet
@item
The @code{stk500_devcode} parameter is the device code used by the STK500
and is obtained from the software section (@code{avr061.zip}) of
Atmel's AVR061 application note available from
@url{http://www.atmel.com/dyn/resources/prod_documents/doc2525.pdf}.

@item
Not all memories will implement all instructions.

@item
AVR Fuse bits and Lock bits are implemented as a type of memory.

@item
Example memories are: @code{flash}, @code{eeprom}, @code{fuse},
@code{lfuse} (low fuse), @code{hfuse} (high fuse), @code{efuse}
(extended fuse), @code{signature}, @code{calibration}, @code{lock}.

@item
The memory specified on the AVRDUDE command line must match one of
the memories defined for the specified chip.

@item
The @code{pwroff_after_write} flag causes AVRDUDE to attempt to power
the device off and back on after an unsuccessful write to the affected
memory area if VCC programmer pins are defined.  If VCC pins are not
defined for the programmer, a message indicating that the device needs a
power-cycle is printed out.  This flag was added to work around a
problem with the at90s4433/2333's; see the at90s4433 errata at:

         @url{https://www.microchip.com/content/dam/mchp/documents/OTH/ProductDocuments/DataSheets/doc1042.pdf}

@item
The bootloader from application note AVR109 (and thus also the AVR
Butterfly) does not support writing of fuse bits.  Writing lock bits
is supported, but is restricted to the boot lock bits (BLBxx).  These
are restrictions imposed by the underlying SPM instruction that is used
to program the device from inside the bootloader.  Note that programming
the boot lock bits can result in a ``shoot-into-your-foot'' scenario as
the only way to unprogram these bits is a chip erase, which will also
erase the bootloader code.

@cindex @code{flash}
The bootloader implements the ``chip erase'' function by erasing the
flash pages of the application section.

Reading fuse and lock bits is fully supported.

@end itemize

@page

@c
@c Node
@c
@node Autogenerated Files,  Programmer Specific Information, Configuration Files, Top
@cindex Autogenerated files
@cindex @code{urboot:...}
@chapter Autogenerated files

@noindent Autogenerated files are @emph{virtual} read-only files that do
not exist externally but that are provided by AVRDUDE instead. They have
the form @var{prefix}@code{:}@var{parameters} and can be used to write the
contents of memory. The @var{prefix} tells AVRDUDE which sort of file to
generate while the part after the colon is usually an underscore-separated
list of parameters that determines the contents of the autogenerated file.

Currently, the only autogenerated files are urboot bootloaders from the
@url{https://github.com/stefanrueger/urboot} project. They take the form
@code{urboot:}@var{features}. Bootloader features are specified using an
underscore-separated list in arbitrary order, eg,
@code{urboot:autobaud_2s}. For a complete list of possible features see
below. The following example writes a suitable autobaud bootloader to the
flash of an ATmega328P target:

@smallexample
@cartouche
$ avrdude -c dryrun -p m328p -U urboot:autobaud
Reading 260 bytes for flash from input file urboot:autobaud
Writing 260 bytes to flash
Writing | ################################################## | 100% 0.00 s
Reading | ################################################## | 100% 0.00 s
260 bytes of flash verified
Setting fuses for bootloader urboot:autobaud

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@noindent
Autogenerated bootloaders can be used in the terminal as well:

@smallexample
@cartouche
$ avrdude -c dryrun -p m328p -t
avrdude> write flash urboot:autobaud
Caching | ################################################## | 100% 0.00 s

avrdude> quit
Synching cache to device ...
Writing | ################################################## | 100% 0.00 s

Avrdude done.  Thank you.
@end cartouche
@end smallexample

@noindent
Note that using @code{urboot:...} in @code{-U} options has the desired
side effect of also setting all necessary fuse configurations for the
bootloader to work correctly. This does @emph{not} happen when using the
terminal @code{write} command, where the necessary fuse configurations
need to be requested manually.

@page

@noindent The terminal mode is great for exploring possible bootloaders
interactively:

@smallexample
@cartouche
$ avrdude -c dryrun -p m328p -t
avrdude> write flash urboot:autobaud_list
   Selection Size Use Vers Features  Type               Canonical file name
         _pr *256 256 u8.0 w---jPra- vector/spmready    urboot_m328p_1s_autobaud_u...
   _ee_ce_pr *378 384 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_u...
   _ee_u4_pr  372 384 u8.0 weU-jPra- vector/spmready    urboot_m328p_1s_autobaud_u...
   _ce_u4_pr  362 384 u8.0 w-U-jPrac vector/spmready    urboot_m328p_1s_autobaud_u...
      _u4_pr  316 384 u8.0 w-U-jPra- vector/spmready    urboot_m328p_1s_autobaud_u...
_ee_ce_u4_hw *400 512 u8.0 weU-hprac hardware-supported urboot_m328p_1s_autobaud_u...
_ee_ce_u4_pr  414 512 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_u...
   _ee_u4_hw  354 512 u8.0 weU-hpra- hardware-supported urboot_m328p_1s_autobaud_u...
@end cartouche
@end smallexample

@noindent
The @code{list} feature does not generate the bootloader code but instead
interactively lists possible selections. In above example, the last column
is cut off for space reasons. Using successively @code{ee} (provide a
bootloader with EEPROM r/w capability), @code{ce} (add chip erase
emulation code to the generated bootloader) and @code{u4} (generate code
skipping all redundant flash page writes and page erases to wear out the
flash memory less and speed up the bootloading process) will then
iteratively reduce the available selection:

@smallexample
@cartouche
avrdude> write flash urboot:autobaud_list_ee
Selection Size Use Vers Features  Type               Canonical file name
   _ce_pr *378 384 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_uart...
   _u4_pr  372 384 u8.0 weU-jPra- vector/spmready    urboot_m328p_1s_autobaud_uart...
_ce_u4_hw *400 512 u8.0 weU-hprac hardware-supported urboot_m328p_1s_autobaud_uart...
_ce_u4_pr  414 512 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_uart...
   _u4_hw  354 512 u8.0 weU-hpra- hardware-supported urboot_m328p_1s_autobaud_uart...

avrdude> write flash urboot:autobaud_list_ee_ce
Select Size Use Vers Features  Type               Canonical file name
   _pr *378 384 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_uart0_r...
_u4_hw *400 512 u8.0 weU-hprac hardware-supported urboot_m328p_1s_autobaud_uart0_r...
_u4_pr  414 512 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_uart0_r...

avrdude> write flash urboot:autobaud_list_ee_ce_u4
Sel Size Use Vers Features  Type               Canonical file name
_hw *400 512 u8.0 weU-hprac hardware-supported urboot_m328p_1s_autobaud_uart0_rxd0...
_pr  414 512 u8.0 weU-jPrac vector/spmready    urboot_m328p_1s_autobaud_uart0_rxd0...
@end cartouche
@end smallexample

@noindent
In all lists the starred bootloaders are those that are the most
feature-rich given the available used flash space, which --- out of necessity ---
must be a multiple of flash pages or minimal boot section. These can be
selected with the @code{best} feature. The @code{show} feature displays
the properties of the bootloader that would be written without actually
writing it; removing @code{show} will then write the bootloader to flash
and, using @code{-U}, also set the necessary fuses:

@smallexample
@cartouche
$ avrdude -qq -c dryrun -p m328p -U urboot:autobaud_show_best_ee
378 384 u8.0 weU-jPrac vector/spmready urboot_m328p_1s_autobaud_uart0_rxd0_txd1_no...

$ avrdude -qq -c dryrun -p m328p -U urboot:autobaud_best_ee && echo OK
OK
@end cartouche
@end smallexample

@noindent
Like the urboot project AVRDUDE currently only provides bootloaders for classic parts.
The following table lists possible features.

@multitable {@code{led[+-][a-h][0-7]}} {Bootloader adapts to host baud rate within MCU capability (*2)}
@item                @code{2s} @tab WDT timeout: @code{250ms}, @code{500ms}, @code{1s} (default), @code{2s}, @code{4s} or @code{8s} (*0)
@item          @code{autobaud} @tab Bootloader adapts to host baud rate within MCU capability (*1)
@item           @code{uart<n>} @tab Hardware UART number, eg, @code{uart0} (default), @code{uart1}, ...
@item            @code{alt<n>} @tab Alternative UART I/O lines (*2)
@item          @code{9.6kbaud} @tab Or other reasonable baud rates; also accepting @code{baud} unit
@item             @code{16MHz} @tab Or other CPU frequencies; also accepting @code{kHz} and @code{Hz} units
@item            @code{[xa-q]} @tab Optional F_CPU prefix designator, eg, @code{i9.2MHz} (*3)
                               @*@w{@ @ - @code{x}}: external oscillator (default)
                               @*@w{@ @ - @code{i}}: internal oscillator
                               @*@w{@ @ - @code{[a-h]}}: internal oscillator that is 10% (@code{a}) to 1.25% (@code{h}) slow
                               @*@w{@ @ - @code{[j-q]}}: internal oscillator that is 1.25% (@code{j}) to 10% (@code{q}) fast
@item              @code{swio} @tab Software I/O, must specify @code{rx} and @code{tx} pins
@item      @code{rx[a-h][0-7]} @tab MCU receive pin for @code{swio}, eg, @code{rxb0}
@item      @code{tx[a-h][0-7]} @tab MCU transfer pin for @code{swio}, eg, @code{txb1}
@item            @code{lednop} @tab If no LED is specified generate template bootloader
@item      @code{no-led/noled} @tab Drop blinking code unless a LED is specified
@item @code{led[+-][a-h][0-7]} @tab Generate code for activity LED with polarity +/-, eg, @code{led+b5}
@item              @code{dual} @tab Dual boot; must specify CS pin for external SPI flash (*4)
@item      @code{cs[a-h][0-7]} @tab Chip select pin for dual boot, eg, @code{csd5}
@item                @code{hw} @tab Generate bootloader with hardware boot section (*5)
@item              @code{v<n>} @tab Optional vector for vector bootloader, eg, @code{v25} or @code{vspmready}
@item                @code{ee} @tab Generate bootloader with EEPROM r/w support
@item                @code{ce} @tab Generate bootloader that can emulate a chip erase
@item                @code{pr} @tab Generate vector bootloader with reset vector protection (*6)
@item                @code{u1} @tab Generate bootloader that skips redundant flash page writes (*7,8)
@item                @code{u2} @tab ... and skips redundant flash page erases during emulated CE (*7,8)
@item                @code{u3} @tab ... and skips not needed flash page erases during page write (*7,8)
@item                @code{u4} @tab ... and skips empty flash page writes after page erase (*8)
@item   @code{serialno=abc123} @tab Put serial number, eg, @code{abc123}, in top of unused bootloader flash
@item   @code{fill=urboot\x20} @tab Fill otherwise unused bootloader flash repeatedly with argument
@item   @code{save=myfile.hex} @tab Save bootloader to file with chosen name (*9)
@item              @code{save} @tab Save bootloader to file with canonical file name (*9)
@item   @code{tags=myfile.tag} @tab Save symbols to tag file with chosen name (*9)
@item              @code{tags} @tab Save symbols to tag file with canonical file name (*9)
@item           @code{configs} @tab Show needed fuse configuration but do not write to memories
@item              @code{show} @tab Show bootloader features but do not write to flash
@item              @code{list} @tab List possible bootloader configurations but do not write to flash
@item              @code{best} @tab Select smallest feature-rich bootloader (first in list) and, if
                                    the baud rate error is too high for UART, switch to @code{swio}
@item              @code{help} @tab Show this help message and return
@end multitable

@noindent
@strong{Notes.} Features can also be specified like in elements of a canonical file name.
For details on urboot bootloaders and their features see @url{https://github.com/stefanrueger/urboot}.
@multitable {*8} {Only works with UART I/O where the RX port pin is bit-addressable lorem ipsum}
@item *0 @tab Some parts do not provide @w{4 s} or @w{8 s} watchdog timeout
@item *1 @tab @code{autobaud} only works with UART I/O where the RX port pin is bit-addressable
@item *2 @tab From classic parts, only ATtiny441/841 have alternate UART signals
@item *3 @tab There is a subtle difference between external oscillators (@code{x}), which are
              reasonably accurate, and internal oscillators (@code{a}...@code{h}, @code{i},
              @code{j}...@code{q}), which tend to be inaccurate for classic parts. The former can
              afford higher baud rate errors up to 2.2% while for the latter AVRDUDE warns at the
              lower threshold of 0.7% baud rate error. Cassic UARTs have integer baud rate
              divisors, which can lead to high baud rate quantisation errors. Used with the feature
              @code{best} AVRDUDE can automagically replace UART I/O code with @code{swio}
              I/O code when the former exhibits too high baud rate errors. For that, AVRDUDE better
              knows the type of oscillator (@code{x} or @code{i}) that drives a board. For lowest
              baud rate errors on an individual board that runs on internal oscillators it is best
              to measure F_CPU and use the measured value with the @code{i} prefix. Alternatively,
              one can use the nominal internal F_CPU (say @w{8 MHz}) and use prefix letters that
              make the bootloader work: depending on the letter AVRDUDE subtracts from or adds to
              the nominal F_CPU multiples of 1.25%.
@item *4 @tab Dual boot is not supported for parts that lack standard SPI communication
@item *5 @tab Not all parts provide hardware bootloader support; @code{hw} renders @code{pr} meaningless
@item *6 @tab Reset vector protection is only available if flash size is a power of 2 (not ATmega406)
@item *7 @tab @code{u1}...@code{u3} is only advisory, ie, can result in any of @code{u1}...@code{u4}
@item *8 @tab @code{u1}...@code{u4} is not available for parts with the 4-page-erase quirk
@item *9 @tab The file is still written to disk in connection with @code{configs}, @code{show} or
              @code{list}. Bootloader files are per default written as Intel Hex format with
              comments. A filename of @code{-} writes the file to @code{stdout}. If a bootloader
              is a vector bootloader then the bootloader file contains a segment for
              initialising the reset vector to point to the bootloader. Tag files can be used in
              connection with the terminal @code{disasm} command.
@end multitable

@*@noindent
Baud rate quantification errors are displayed with @code{-v}. A 0.79% baud
rate error is considered OK for external oscillators but too high for
internal oscillators. Hence, AVRDUDE selects software I/O when neither
@code{uart} nor @code{swio} are explicitly requested:

@smallexample
@cartouche
$ avrdude -qv -c dryrun -p m328p -U urboot:x8mhz_56kbaud |& grep -i baud.rate
Baud rate error -0.79% for external oscillator OK

$ avrdude -qv -c dryrun -p m328p -U urboot:i8mhz_56kbaud |& grep -i baud.rate
Switching to SWIO as baud rate error -0.79% too high for internal oscillator
Baud rate error -0.10% for internal oscillator OK
@end cartouche
@end smallexample

@noindent
There is a warning when the user requests hardware UART I/O:

@smallexample
@cartouche
$ avrdude  -qvc dryrun -p m328p -U urboot:i8mhz_56kbaud_uart0 |& grep -i baud.rate
Warning: high baud rate error -0.79% for int oscillator: consider switching to swio
@end cartouche
@end smallexample

@noindent
Requesting @code{best} makes AVRDUDE switch to @code{swio} when UART quatisation errors are considered too high:

@smallexample
@cartouche
$ avrdude -qvc dryrun -p m328p -U urboot:i8mhz_56kbaud_uart0_best |& grep -i baud.rat
Switching to SWIO as baud rate error -0.79% too high for internal oscillator
Baud rate error -0.10% for internal oscillator OK
@end cartouche
@end smallexample

@noindent
Alternatively, the user can request @code{swio} on those @code{rx}/@code{tx} lines that the UART uses:

@smallexample
@cartouche
$ avrdude -qvc dryrun -p m328p -U urboot:i8mhz_56kbaud_uart0_swio |& grep -i baud.rat
Baud rate error -0.10% for internal oscillator OK
@end cartouche
@end smallexample

@noindent
Tag files can be used in connection with @code{disasm}:

@smallexample
@cartouche
$ avrdude -qqc dryrun -p m328p -U urboot:m328p_autobaud_ee_tags=/tmp/x \
    -T "disasm -gt=/tmp/x flash 0 -1"

[...]
        .equ    io.mcusr,   0x34
        .equ    io.spmcsr,  0x37
        .equ    mem.wdtcsr, 0x60
[...]
        .text
main:
__vector_reset:
L0000:  rjmp    .-386                ; L7e80 (urboot)

urmarker:                            ; Urboot marker bytes
L0002:  .byte   0x75, 0x72           ; ur

L0004:  .fill   16190, 2, 0xffff

; Rjmp from L0000
urboot:                              ; Entry point for bootloader
L7e80:  clr     r1
L7e82:  in      r2, io.mcusr
L7e84:  out     io.mcusr, r1
L7e86:  ldi     r24, 0x00            ; 0
L7e88:  rcall   set_watchdog         ; L7f5c
L7e8a:  sbrs    r2, 1                ; Bit 1 = 0x02
application:
L7e8c:  rjmp    .+470                ; L0064 (__vector_spm_ready)
serial_boot:                         ; Serial port bootloading
L7e8e:  ldi     r24, 0x0e            ; 14
L7e90:  rcall   set_watchdog         ; L7f5c

[...]

Label27:
L7fea:  clr     r1
L7fec:  ret

unused:                              ; 12 bytes for _serialno= and/or _fill=
L7fee:  .fill   6, 2, 0xffff

npages_vecnum:                       ; Usage of 3 pages; vector/spmready bootloader
L7ffa:  .byte   0x03, 0x19           ; __

L7ffc:  rjmp    pgm_write_page       ; L7f78

features_version:                    ; Encodes u8.0 weU-jPra-
L7ffe:  .byte   0xe6, 0x40           ; _@
@end cartouche
@end smallexample


@page

@c
@c Node
@c
@node Programmer Specific Information, Platform Dependent Information, Configuration Files, Top
@chapter Programmer-Specific Information
@cindex Programmer-specific information

@menu
* Atmel STK600::
* DFU Bootloader Using FLIP Version 1::
* SerialUPDI Programmer::
* Programmer LED Management::
@end menu

@c
@c Node
@c
@node Atmel STK600, DFU Bootloader Using FLIP Version 1, Programmer Specific Information, Programmer Specific Information
@cindex STK600
@section Atmel STK600
@cindex Atmel STK600

@c
@c Update the table below by running the tools/get-stk600-devices.xsl
@c XSLT transformation on targetboard.xml as shipped by the latest
@c release of AVR Studio.
@c
The following devices are supported by the respective STK600 routing
and socket card:

@multitable {@code{STK600-RCuC3A100-28}}{@code{QT600-ATMEGA324-QM64}}{ATtiny4 ATtiny5 ATtiny9 ATtiny10}
@headitem Routing card @tab Socket card @tab Devices
@item @code{} @tab @code{STK600-ATTINY10} @tab t4 t5 t9 t10
@item @code{STK600-RC008T-2} @tab @code{STK600-DIP} @tab t11 t12 t13 t13a t25 t45 t85
@item @code{STK600-RC008T-7} @tab @code{STK600-DIP} @tab t15
@item @code{STK600-RC014T-42} @tab @code{STK600-SOIC} @tab t20
@item @code{STK600-RC020T-1} @tab @code{STK600-DIP} @tab t2313 t2313a t4313
@item @code{} @tab @code{STK600-TinyX3U} @tab t43u
@item @code{STK600-RC014T-12} @tab @code{STK600-DIP} @tab t24 t44 t84 t24a t44a
@item @code{STK600-RC020T-8} @tab @code{STK600-DIP} @tab t26 t261 t261a t461 t861 t861a
@item @code{STK600-RC020T-43} @tab @code{STK600-SOIC} @tab t261 t261a t461 t461a t861 t861a
@item @code{STK600-RC020T-23} @tab @code{STK600-SOIC} @tab t87 t167
@item @code{STK600-RC028T-3} @tab @code{STK600-DIP} @tab t28
@item @code{STK600-RC028M-6} @tab @code{STK600-DIP} @tab t48 t88 m8 m8a m48 m88 m168 m48p m48pa m88p m88pa m168p m168pa m328p
@item @code{} @tab @code{QT600-ATTINY88-QT8} @tab t88
@item @code{STK600-RC040M-4} @tab @code{STK600-DIP} @tab m8515 m162
@item @code{STK600-RC044M-30} @tab @code{STK600-TQFP44} @tab m8515 m162
@item @code{STK600-RC040M-5} @tab @code{STK600-DIP} @tab m8535 m16 m16a m32 m32a m164p m164pa m324p m324pa m644 m644p m644pa m1284p
@item @code{STK600-RC044M-31} @tab @code{STK600-TQFP44} @tab m8535 m16 m16a m32 m32a m164p m164pa m324p m324pa m644 m644p m644pa m1284p
@item @code{} @tab @code{QT600-ATMEGA324-QM64} @tab m324pa
@item @code{STK600-RC032M-29} @tab @code{STK600-TQFP32} @tab m8 m8a m48 m88 m168 m48p m48pa m88p m88pa m168p m168pa m328p
@item @code{STK600-RC064M-9} @tab @code{STK600-TQFP64} @tab m64 m64a m128 m128a m1281 m2561 c32 c64 c128
@item @code{STK600-RC064M-10} @tab @code{STK600-TQFP64} @tab m165 m165p m169 m169p m169pa m325 m325p m329 m329p m645 m649 m649p
@item @code{STK600-RC100M-11} @tab @code{STK600-TQFP100} @tab m640 m1280 m2560
@item @code{} @tab @code{STK600-ATMEGA2560} @tab m2560
@item @code{STK600-RC100M-18} @tab @code{STK600-TQFP100} @tab m3250 m3250p m3290 m3290p m6450 m6490
@item @code{STK600-RC032U-20} @tab @code{STK600-TQFP32} @tab usb82 usb162 m8u2 m16u2 m32u2
@item @code{STK600-RC044U-25} @tab @code{STK600-TQFP44} @tab m16u4 m32u4
@item @code{STK600-RC064U-17} @tab @code{STK600-TQFP64} @tab m32u6 usb646 usb1286 usb647 usb1287
@item @code{STK600-RCPWM-22} @tab @code{STK600-TQFP32} @tab m32c1 m64c1 m16m1 m32m1 m64m1
@item @code{STK600-RCPWM-19} @tab @code{STK600-SOIC} @tab pwm2 pwm3 pwm2b pwm3b pwm216 pwm316
@item @code{STK600-RCPWM-26} @tab @code{STK600-SOIC} @tab pwm81
@item @code{STK600-RC044M-24} @tab @code{STK600-TSSOP44} @tab m16hvb m32hvb
@item @code{} @tab @code{STK600-HVE2} @tab m64hve
@item @code{} @tab @code{STK600-ATMEGA128RFA1} @tab m128rfa1
@item @code{STK600-RC100X-13} @tab @code{STK600-TQFP100} @tab x64a1 x128a1 x128A1revd x128a1u
@item @code{} @tab @code{STK600-ATXMEGA1281A1} @tab x128a1
@item @code{} @tab @code{QT600-ATXMEGA128A1-QT16} @tab x128a1
@item @code{STK600-RC064X-14} @tab @code{STK600-TQFP64} @tab x64a3 x128a3 x256a3 x64d3 x128d3 x192d3 x256d3
@item @code{STK600-RC064X-14} @tab @code{STK600-MLF64} @tab x256a3b
@item @code{STK600-RC044X-15} @tab @code{STK600-TQFP44} @tab x32a4 x16a4 x16d4 x32d4
@item @code{} @tab @code{STK600-ATXMEGAT0} @tab x32t0
@item @code{} @tab @code{STK600-uC3-144} @tab uc3a0512 uc3a0256b uc3a0128b
@item @code{STK600-RCUC3A144-33} @tab @code{STK600-TQFP144} @tab uc3a0512 uc3a0256b uc3a0128b
@item @code{STK600-RCuC3A100-28} @tab @code{STK600-TQFP100} @tab uc3a1512b uc3a1256b uc3a1128b
@item @code{STK600-RCuC3B0-21} @tab @code{STK600-TQFP64-2} @tab uc3b0256b uc3b0512revcb uc3b0512b uc3b0128b uc3b064b uc3d1128b
@item @code{STK600-RCuC3B48-27} @tab @code{STK600-TQFP48} @tab uc3b1256b uc3b164b
@item @code{STK600-RCUC3A144-32} @tab @code{STK600-TQFP144} @tab uc3a3512b uc3a3256b uc3a3128b uc3a364b uc3a3256sb uc3a3128sb uc3a364sb
@item @code{STK600-RCUC3C0-36} @tab @code{STK600-TQFP144} @tab uc3c0512b uc3c0256b uc3c0128b uc3c064b
@item @code{STK600-RCUC3C1-38} @tab @code{STK600-TQFP100} @tab uc3c1512b uc3c1256b uc3c1128b uc3c164b
@item @code{STK600-RCUC3C2-40} @tab @code{STK600-TQFP64-2} @tab uc3c2512b uc3c2256b uc3c2128b uc3c264b
@item @code{STK600-RCUC3C0-37} @tab @code{STK600-TQFP144} @tab uc3c0512b uc3c0256b uc3c0128b uc3c064b
@item @code{STK600-RCUC3C1-39} @tab @code{STK600-TQFP100} @tab uc3c1512b uc3c1256b uc3c1128b uc3c164b
@item @code{STK600-RCUC3C2-41} @tab @code{STK600-TQFP64-2} @tab uc3c2512b uc3c2256b uc3c2128b uc3c264b
@item @code{STK600-RCUC3L0-34} @tab @code{STK600-TQFP48} @tab uc3l064b uc3l032b uc3l016b
@item @code{} @tab @code{QT600-AT32UC3L-QM64} @tab uc3l064b
@end multitable

Ensure the correct socket and routing card are mounted @emph{before}
powering on the STK600.  While the STK600 firmware ensures the socket
and routing card mounted match each other (using a table stored
internally in nonvolatile memory), it cannot handle the case where a
wrong routing card is used, e. g. the routing card
@code{STK600-RC040M-5} (which is meant for 40-pin DIP AVRs that have
an ADC, with the power supply pins in the center of the package) was
used but an ATmega8515 inserted (which uses the ``industry standard''
pinout with Vcc and GND at opposite corners).

Note that for devices that use the routing card @code{STK600-RC008T-2},
in order to use ISP mode, the jumper for @code{AREF0} must be removed
as it would otherwise block one of the ISP signals.  High-voltage
serial programming can be used even with that jumper installed.

The ISP system of the STK600 contains a detection against shortcuts
and other wiring errors.  AVRDUDE initiates a connection check before
trying to enter ISP programming mode, and display the result if the
target is not found ready to be ISP programmed.

High-voltage programming requires the target voltage to be set to at
least 4.5 V in order to work.  This can be done using
@emph{Terminal Mode}, see @ref{Terminal Mode Operation}.

@c
@c Node
@c
@node DFU Bootloader Using FLIP Version 1, SerialUPDI Programmer , Atmel STK600, Programmer Specific Information
@section DFU Bootloader Using FLIP Version 1
@cindex DFU Bootloader using FLIP version 1

Bootloaders using the FLIP protocol version 1 experience some very
specific behaviour.

These bootloaders have no option to access memory areas other than
Flash and EEPROM.

@cindex @code{flash}
When the bootloader is started, it enters a @emph{security mode} where
the only acceptable access is to query the device configuration
parameters (which are used for the signature on AVR devices).  The
only way to leave this mode is a @emph{chip erase}.  As a chip erase
is normally implied by the @option{-U} option when reprogramming the
flash, this peculiarity might not be very obvious immediately.

Sometimes, a bootloader with security mode already disabled seems to
no longer respond with sensible configuration data, but only 0xFF for
all queries.  As these queries are used to obtain the equivalent of a
signature, AVRDUDE can only continue in that situation by forcing the
signature check to be overridden with the @option{-F} option.

@cindex @code{eeprom}
A @emph{chip erase} might leave the EEPROM unerased, at least on some
versions of the bootloader.

@c
@c Node
@c
@node SerialUPDI Programmer, Programmer LED Management, DFU Bootloader Using FLIP Version 1, Programmer Specific Information
@cindex SerialUPDI
@section SerialUPDI Programmer
@cindex SerialUPDI programmer

SerialUPDI programmer can be used for programming UPDI-only devices
using very simple serial connection.
You can read more about the details here
@url{https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md}

SerialUPDI programmer has been tested using FT232RL USB->UART interface
with the following connection layout (copied from Spence Kohde's page linked
above):

@noindent
@example
------------------                              To Target device
              DTR|                               _______________
              Rx |-----------,------------------| UPDI---\/\/------->
Tx---/\/\/\---Tx |----|<|---'          .--------| Gnd    470 ohm
  resistor    Vcc|------------------------------| Vcc
      1k      CTS|                  .`          |_______________
              Gnd|-----------------'
------------------
@end example

There are several limitations in current SerialUPDI/AVRDUDE integration,
listed below.

Currently available devices support only UPDI NVM programming model 0, 2
3 and 5, but there is also experimental implementation of model 4 - it
has been tested only on a single device, so issues with other devices are
expected. Full NVM v4 mode support will be provided once the hardware is
widely available.

@cindex @code{signature}
One of the core AVRDUDE features is verification of the connection by
reading device signature prior to any operation, but this operation
is not possible on UPDI locked devices. Therefore, to be able to
connect to such a device, you have to provide @option{-F} to override
this check.

Please note: using @option{-F} during write operation to locked device
will force chip erase. Use carefully.

@cindex @code{eeprom}
Another issue you might notice is slow performance of EEPROM writing
using SerialUPDI for AVR Dx devices. This can be addressed by changing
@emph{avrdude.conf} section for this device - changing EEPROM page
size to 0x20 (instead of default 1), like so:

@example
#------------------------------------------------------------
# AVR128DB28
#------------------------------------------------------------

part parent    ".avrdx"
    id        = "avr128db28";
    desc      = "AVR128DB28";
    signature = 0x1E 0x97 0x0E;

    memory "flash"
        size      = 0x20000;
        offset    = 0x800000;
        page_size = 0x200;
        readsize  = 0x100;
    ;

    memory "eeprom"
        size      = 0x200;
        offset    = 0x1400;
        page_size = 0x20;
        readsize  = 0x100;
    ;
;
@end example

The point of USERROW is to  provide ability to write configuration details
to already locked device and currently SerialUPDI interface supports this
feature. Please note: on locked devices it's not possible to read back
USERROW contents when written, so the automatic verification will most
likely fail and to prevent error messages, use @option{-V}.

In case you run into issues with the SerialUPDI interface, please
make sure to run the intended command with debug output enabled
(@option{-v -v -v}) and provide this verbose output with your
bug report. You can also try to perform the same action using
@emph{pymcuprog} (@url{https://github.com/microchip-pic-avr-tools/pymcuprog})
utility with @option{-v debug} and provide its output too.
You will notice that both outputs are pretty similar, and this
was implemented like that on purpose - it was supposed to make
analysis of UPDI protocol quirks easier.

@c
@c Node
@c
@node Programmer LED Management, , SerialUPDI Programmer, Programmer Specific Information
@section Programmer LED Management
@cindex Programmer LED management
@cindex LED management

Some hardware programmers have LEDs, and the firmware controls them fully
without AVRDUDE having a way to influence their LED states. Other
programmers have LEDs and expect the host downloader/uploader to handle
them, for example bit-banging programmers, ftdi-based programmers or
linuxgpio programmers. For those programmers AVRDUDE provides support of
four LEDs (RDY, ERR, PGM and VFY) which can be set via corresponding
subroutines in the code for the respective @code{-c} programmer.

The RDY LED is set once the programmer is initialised and switched off
when AVRDUDE exits. During reading, writing or erasing the target the PGM
LED flashes with around 2.5 Hz, whilst the VFY LED comes on during -U
verification of the written contents. Errors are indicated with the ERR
LED.

Assuming AVRDUDE got to the point where LEDs are accessible and the RDY
LED was switched on then, on exit, AVRDUDE will leave the LEDs in the
following states:

@multitable @columnfractions .075 .075 .075 .075 .6
@item @tab @strong{PGM} @tab @strong{VFY} @tab @strong{ERR} @tab @strong{Semantics}
@item @tab off @tab off @tab off @tab OK: all tasks done without errors
@item @tab off @tab off @tab on  @tab Some error not related to read, write or erase
@item @tab on  @tab off @tab on  @tab Read, write or erase error
@item @tab off @tab on  @tab on  @tab Verification error but no read, write or erase error
@item @tab on  @tab on  @tab on  @tab Verification error and read, write or erase error
@end multitable

@noindent
Other combinations should not show after exit.


@c
@c Node
@c
@node Platform Dependent Information, Troubleshooting, Programmer Specific Information, Top
@appendix Platform Dependent Information

@menu
* Unix::
* Windows::
@end menu

@c
@c Node
@c
@node Unix, Windows, Platform Dependent Information, Platform Dependent Information
@section Unix
@cindex Unix

@menu
* Unix Installation::
* Unix Configuration Files::
* Unix Port Names::
* Unix USB Permissions::
* Unix Documentation::
@end menu

@c
@c Node
@c
@node Unix Installation, Unix Configuration Files, Unix, Unix
@subsection Unix Installation
@cindex Unix installation
@cindex Installation

Refer to @uref{https://github.com/avrdudes/avrdude/wiki}
for the latest installation tips.

@c
@c Node
@c
@node Unix Configuration Files, Unix Port Names, Unix Installation, Unix
@subsection Unix Configuration Files
@cindex Unix configuration files
@cindex Configuration files

@noindent
When AVRDUDE is built using the default @option{--prefix} configure
option, the default configuration file for a Unix system is located at
@code{/usr/local/etc/avrdude.conf}.  This can be overridden by using the
@option{-C} command line option.  Additionally, the user's home directory
is searched for a file named @code{.avrduderc}, and if found, is used to
augment the system default configuration file.

@menu
* FreeBSD Configuration Files::
* Linux Configuration Files::
@end menu

@c
@c Node
@c
@node FreeBSD Configuration Files, Linux Configuration Files, Unix Configuration Files, Unix Configuration Files
@subsubsection FreeBSD Configuration Files
@cindex FreeBSD configuration files
@cindex Configuration files

@noindent
When AVRDUDE is installed using the FreeBSD ports system, the system
configuration file is always @code{/usr/local/etc/avrdude.conf}.

@c
@c Node
@c
@node Linux Configuration Files,  , FreeBSD Configuration Files, Unix Configuration Files
@subsubsection Linux Configuration Files
@cindex Linux configuration files
@cindex Configuration files

@noindent
When AVRDUDE is installed using from an rpm package, the system
configuration file will be always be @code{/etc/avrdude.conf}.

@c
@c Node
@c
@node Unix Port Names, Unix USB Permissions, Unix Configuration Files, Unix
@subsection Unix Port Names
@cindex Unix port names

@noindent
The parallel and serial port device file names are system specific.
macOS has no default serial port names, but available ports can be
found under @code{/dev/cu.*}. Please take note AVRDUDE does not
support parallel port programming under macOS.

The following table lists the default names for a given system.

@multitable @columnfractions .30 .30 .30
@item @strong{System}
  @tab @strong{Default Parallel Port}
  @tab @strong{Default Serial Port}
@item FreeBSD
  @tab @code{/dev/ppi0}
  @tab @code{/dev/cuad0}
@item Linux
  @tab @code{/dev/parport0}
  @tab @code{/dev/ttyS0}
@item Solaris
  @tab @code{/dev/printers/0}
  @tab @code{/dev/term/a}
@end multitable

On FreeBSD systems, AVRDUDE uses the ppi(4) interface for
accessing the parallel port and the sio(4) driver for serial port
access.

On Linux systems, AVRDUDE uses the ppdev interface for
accessing the parallel port and the tty driver for serial port
access.

On Solaris systems, AVRDUDE uses the ecpp(7D) driver for
accessing the parallel port and the asy(7D) driver for serial port
access.

@c
@c Node
@c
@node Unix USB Permissions, Unix Port Names, Unix Documentation, Unix
@subsection Unix USB Permissions
@cindex Unix USB permissions
@cindex USB permissions

In most cases the kernel driver initializes a plug-and-play device to be
owned by user @code{root} and group @code{root} with only r/w permission
for the user @code{root} rendering the device inaccessible to regular
users. Whilst users can run AVRDUDE sessions as root this is definitely
@emph{not good practice}. Giving USB plug-and-play devices the correct
permissions is much better. USB AVR programmers are normally identified by
a two-byte hexadecimal vendor ID and a two-byte hexadecimal product id.
Both are typically used to identify the device that needs new permissions.

@menu
* FreeBSD USB Permissions::
* Linux USB Permissions::
@end menu

@c
@c Node
@c
@node FreeBSD USB Permissions, Linux USB Permissions, Unix USB Permissions, Unix USB Permissions
@subsubsection FreeBSD USB Permissions
@cindex FreeBSD USB permissions
@cindex USB permissions

In FreeBSD a so-called @code{devd} config files in
@code{/usr/local/etc/devd} serve to modify permissions of plugged-in USB
devices. Here is an example how Atmel's JTAGICE3 programmer (product ID
0x2110 or 0x2140) by Atmel (vendor ID 0x0eb) can be given appropriate
permissions using a file @code{jtagice3.conf}:

@smallexample
@cartouche
notify 100 @{
  match "system" "USB";
  match "subsystem" "DEVICE";
  match "type" "ATTACH";
  match "vendor" "0x03eb";
  match "product" "(0x2110|0x2140)";
  action "chmod 660 /dev/$cdev";
  action "chgrp yourgroup /dev/$cdev";
@};
@end cartouche
@end smallexample

@noindent @code{yourgroup} would be a group that the user(s) should be
member of who wish to have access to the programmer.

@c
@c Node
@c
@node Linux USB Permissions,  , FreeBSD USB Permissions, Unix USB Permissions
@subsubsection Linux USB Permissions
@cindex Linux USB permissions
@cindex USB permissions

Linux has a special userspace @code{/dev} device manager called udev that
deals with, amongst other things, plug-and-play USB devices. It is
recommended to specify so-called udev rules to define access permissions
for these devices instead. These rules typically reside in a file with the
name @var{nn}@code{-}@var{descriptive-name}@code{.rules} in the directory
@code{/etc/udev/rules.d}. Here, @var{nn} is a two-digit number that
determines the lexical order in which the udev rule files are processed.
Rules processed later can overwrite earlier rules, but it not recommended
to put user-generated rules higher than 60, as some of the actions they
require are processed by higher-level system rules.

Here a typical udev rule for allowing an ordinary user access to the
plugged-in AVRISP mkII programmer (product ID 0x2104) by Atmel (vendor ID
0x0eb):

@smallexample
@cartouche
SUBSYSTEM=="usb", ATTRS@{idVendor@}=="03eb", ATTRS@{idProduct@}=="2104", \
  MODE="0660", TAG+="uaccess"
@end cartouche
@end smallexample

@noindent This furnishes the corresponding device node with @code{0660}
access permissions: this means r/w for the user @code{root} and any user
belonging to the group of the device, which the device driver might assign
to a different group than the default @code{root}. The key of the rule is
the attached @code{TAG} named @code{uaccess}, which has the effect that
the login daemon applies a dynamic user access control list to the device
node making the device usable for the currently logged-in user. When used
in anger, udev rules must appear on one line; above example was broken
into two lines so it fits into the example box.

AVRDUDE's developer option @code{-c }@var{programmer}@code{/u} will show
above suggested udev rule for the named programmer. Wildcards are allowed:

@smallexample
@cartouche
$ avrdude -c jtag\*/u

1. Examine the suggested udev rules below; to install run:

avrdude -c "jtag*/u" | tail -n +11 | sudo tee /etc/udev/rules.d/55-avrdude-jtagX.rules
sudo chmod 0644 /etc/udev/rules.d/55-avrdude-jtagX.rules

2. Unplug any AVRDUDE USB programmers and plug them in again
3. Enjoy user access to the USB programmer(s)

Note: To install all udev rules known to AVRDUDE follow: avrdude -c "*/u" | more

# Generated from avrdude -c "jtag*/u"

ACTION!="add|change", GOTO="avrdude_end"

# jtag2dw, jtag2fast, jtag2, jtag2isp, jtag2pdi, jtag2slow, jtagmkII, jtag2avr32
SUBSYSTEM=="usb", ATTRS@{idVendor@}=="03eb", ATTRS@{idProduct@}=="2103", \
  MODE="0660", TAG+="uaccess"

# jtag3, jtag3dw, jtag3isp, jtag3pdi, jtag3updi
SUBSYSTEM=="usb", ATTRS@{idVendor@}=="03eb", ATTRS@{idProduct@}=="2110", \
  MODE="0660", TAG+="uaccess"
KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS@{idVendor@}=="03eb", \
  ATTRS@{idProduct@}=="2110", MODE="0660", TAG+="uaccess"
SUBSYSTEM=="usb", ATTRS@{idVendor@}=="03eb", ATTRS@{idProduct@}=="2140", \
  MODE="0660", TAG+="uaccess"
KERNEL=="hidraw*", SUBSYSTEM=="hidraw", ATTRS@{idVendor@}=="03eb", \
  ATTRS@{idProduct@}=="2140", MODE="0660", TAG+="uaccess"

# jtagkey
SUBSYSTEM=="usb", ATTRS@{idVendor@}=="0403", ATTRS@{idProduct@}=="cff8", \
  MODE="0660", TAG+="uaccess"
@end cartouche
@end smallexample

@cindex USB permissions
@noindent Again, each rule must be written as one line: breaking up rules
into two lines was only done to fit AVRDUDE's output to the boxed display.
USB devices in HID mode require a second rule dealing with the
@code{hidraw} subsystem as seen above.

@c
@c Node
@c
@node Unix Documentation,  , Unix Port Names, Unix
@subsection Unix Documentation
@cindex Unix documentation

@noindent
AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
@code{/usr/local/man/man1} area, while the HTML and PDF documentation
is installed in @code{/usr/local/share/doc/avrdude} directory.  The
info manual is installed in @code{/usr/local/info/avrdude.info}.

Note that these locations can be altered by various configure options
such as @option{--prefix}.

@c
@c Node
@c
@node Windows,  , Unix, Platform Dependent Information
@section Windows
@cindex Windows

@menu
* Windows Installation::
* Windows Configuration Files::
* Windows Port Names::
@c * Documentation::
@end menu

@c
@c Node
@c
@node Windows Installation, Windows Configuration Files, Windows, Windows
@subsection Installation
@cindex Installation

@noindent
Refer to @uref{https://github.com/avrdudes/avrdude/wiki}
for the latest installation tips.

@c
@c Node
@c
@node Windows Configuration Files, Windows Port Names, Windows Installation, Windows
@subsection Windows Configuration Files
@cindex Windows configuration files

@menu
* Configuration file names::
* Windows Configuration File Location::
@end menu

@c
@c Node
@c
@node Configuration file names, Windows Configuration File Location, Windows Configuration Files, Windows Configuration Files
@subsubsection Windows Configuration File Names
@cindex Windows configuration file names

@noindent
AVRDUDE on Windows looks for a system configuration file name of
@code{avrdude.conf} and looks for a user override configuration file of
@code{avrdude.rc} in the same directory where avrdude.exe is located.

@c
@c Node
@c
@node Windows Configuration File Location,  , Configuration file names, Windows Configuration Files
@subsubsection Windows Configuration File Location
@cindex Windows configuration file location

@noindent
AVRDUDE on Windows has a different way of searching for the system and
user configuration files. Below is the search method for locating the
configuration files:

@enumerate

@item
Only for the system configuration file:
@code{<directory from which application loaded>/../etc/avrdude.conf}

@item
The directory from which the application loaded.

@item
The current directory.

@item
The Windows system directory. On Windows NT, the name of this directory
is @code{SYSTEM32}.

@item
The Windows directory.

@item
The directories that are listed in the PATH environment variable.

@end enumerate


@c
@c Node
@c
@node Windows Port Names, Windows Configuration Files, Windows
@subsection Windows Port Names
@cindex Windows port names

@menu
* Serial Ports::
* Parallel Ports::
@end menu

@c
@c Node
@c
@node Serial Ports, Parallel Ports, Windows Port Names, Windows Port Names
@subsubsection Windows Serial Ports
@cindex Windows serial ports

@noindent
When you select a serial port (i.e. when using an STK500) use the
Windows serial port device names such as: com1, com2, etc.

@c
@c Node
@c
@node Parallel Ports,  , Serial Ports, Windows Port Names
@subsubsection Windows Parallel Ports
@cindex Windows parallel ports

@noindent
AVRDUDE does not support parallel port programming in Windows.
If you need to run AVRDUDE using programmer on a parallel port,
you might want to try one of the BSDs or Linux.

@ignore
@c
@c Node
@c
@node Documentation, Windows
@subsection Documentation
@cindex Documentation

@noindent
AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
@code{/usr/local/man/man1} area, while the HTML and PDF documentation
is installed in @code{/usr/local/share/doc/avrdude} directory.  The
info manual is installed in @code{/usr/local/info/avrdude.info}.

Note that these locations can be altered by various configure options
such as @option{--prefix} and @option{--datadir}.
@end ignore


@c
@c Node
@c
@node Troubleshooting, List of Programmers, Platform Dependent Information, Top
@appendix Troubleshooting

@noindent
Please report any bugs encountered via
@url{https://github.com/avrdudes/avrdude/issues}.

AVRDUDE's wiki @url{https://github.com/avrdudes/avrdude/wiki} is a great
place to learn about installing AVRDUDE on various platforms and,
generally, to learn a few tricks of the trade. In paticular, the
@url{https://github.com/avrdudes/avrdude/wiki/FAQ, FAQ} and the
@url{https://github.com/avrdudes/avrdude/wiki/Known-limitations-of-avrdude,
known limitations} of avrdude are worth reading.

Here a few examples for things that can go wrong and what to do:

@itemize @bullet

@item
Problem: I'm using a serial programmer under Windows and get the following
error:

@code{avrdude: serial_open(): can't set attributes for device "com1"},

Solution: This problem seems to appear with certain versions of Cygwin. Specifying
@code{"/dev/com1"} instead of @code{"com1"} should help.


@item
Problem: I'm using Linux and my AVR910 programmer is really slow.

Solution (short): @code{setserial @var{port} low_latency}

Solution (long):
There are two problems here. First, the system may wait some time before it
passes data from the serial port to the program. Under Linux the following
command works around this (you may need root privileges for this).

@code{setserial @var{port} low_latency}

Secondly, the serial interface chip may delay the interrupt for some time.
This behaviour can be changed by setting the FIFO-threshold to one. Under Linux this
can only be done by changing the kernel source in @code{drivers/char/serial.c}.
Search the file for @code{UART_FCR_TRIGGER_8} and replace it with @code{UART_FCR_TRIGGER_1}. Note that overall performance might suffer if there
is high throughput on serial lines. Also note that you are modifying the kernel at
your own risk.


@item
Problem: I'm not using Linux and my AVR910 programmer is really slow.

Solutions: The reasons for this are the same as above.
If you know how to work around this on your OS, please let us know.

@cindex @code{eeprom}
@item
Problem: Page-mode programming the EEPROM using the -U option does
not erase EEPROM cells before writing, and thus cannot necessarily overwrite
non-0xff values.

Solution: This is an inherent feature of how JTAG EEPROM programming
works, and is documented as such in the datasheets. In order to
successfully program the EEPROM, a prior chip erase with the EESAVE fuse
unprogrammed is required. This also applies to the STK500 and STK600 in
high-voltage programming mode.

The terminal, however, recognises that the programmer struggles to write
to EEPROM. It then reads flash, EEPROM and, if present, bootrow contents,
performs a chip erase and then writes these memories back. This happens
when flushing the cache or leaving the terminal and takes some time.
EESAVE needs to be unprogrammed for this.

@item
Problem: How do I turn off the @var{DWEN} fuse?

Solution: If the @var{DWEN} (debugWIRE enable) fuse is activated,
the @var{/RESET} pin is not functional anymore, so normal ISP
communication cannot be established.
There are two options to deactivate that fuse again: high-voltage
programming, or getting the JTAG ICE mkII talk debugWIRE, and
prepare the target AVR to accept normal ISP communication again.

The first option requires a programmer that is capable of high-voltage
programming (either serial or parallel, depending on the AVR device),
for example the STK500.  In high-voltage programming mode, the
@var{/RESET} pin is activated initially using a 12 V pulse (thus the
name @emph{high voltage}), so the target AVR can subsequently be
reprogrammed, and the @var{DWEN} fuse can be cleared.  Typically, this
operation cannot be performed while the AVR is located in the target
circuit though.

The second option requires a JTAG ICE mkII that can talk the debugWIRE
protocol.  The ICE needs to be connected to the target using the
JTAG-to-ISP adapter, so the JTAG ICE mkII can be used as a debugWIRE
initiator as well as an ISP programmer.  AVRDUDE will then be activated
using the @var{jtag2isp} programmer type.  The initial ISP
communication attempt will fail, but AVRDUDE then tries to initiate a
debugWIRE reset.  When successful, this will leave the target AVR in a
state where it can accept standard ISP communication.  The ICE is then
signed off (which will make it signing off from the USB as well), so
AVRDUDE has to be called again afterwards.  This time, standard ISP
communication can work, so the @var{DWEN} fuse can be cleared.

The pin mapping for the JTAG-to-ISP adapter is:

@multitable @columnfractions .2 .2
@item @strong{JTAG pin} @tab @strong{ISP pin}
@item 1 @tab 3
@item 2 @tab 6
@item 3 @tab 1
@item 4 @tab 2
@item 6 @tab 5
@item 9 @tab 4
@end multitable

@item
Problem: Differentiate Multiple USBtinyISP (or USBasp) programmers

Solution: The @var{-c usbtiny} programmer supports distinguishing multiple
physical USBtinyISP devices based on their bus:device pairs that describes
their place in the USB hierarchy on a specific host.  This pair can be
specified in the @var{-P usb:<bus>:<device>} option.

The actual naming convention for the bus and device names is
operating-system dependent; AVRDUDE will print out what it found
on the bus when running it with (at least) one @var{-v} option.
By specifying a string that cannot match any existing device,
for example, @var{-P usb:xyz}, the scan will list all possible
candidate devices found on the bus.

Examples:
@example
avrdude -c usbtiny -p atmega8 -P usb:003:025 (Linux)
avrdude -c usbtiny -p atmega8 -P usb:/dev/usb:/dev/ugen1.3 (FreeBSD 8+)
avrdude -c usbtiny -p atmega8 \
  -P usb:bus-0:\\.\libusb0-0001--0x1781-0x0c9f (Windows)
@end example

For USBasp, the same format for @var{-P usb} can be used to match usb bus:device. Alternatively,
device serial number can be specified as follows (for serial number '1234').

@example
avrdude -c USBasp -p atmega8 -P usb:1234
@end example


@item
Problem: I cannot do @dots{} when the target is in debugWIRE mode.

Solution: debugWIRE mode imposes several limitations.

The debugWIRE protocol is Atmel's proprietary one-wire (plus ground)
protocol to allow an in-circuit emulation of the smaller AVR devices,
using the @var{/RESET} line.
DebugWIRE mode is initiated by activating the @var{DWEN}
fuse, and then power-cycling the target.
While this mode is mainly intended for debugging/emulation, it
also offers limited programming capabilities.
Effectively, the only memory areas that can be read or programmed
in this mode are flash and EEPROM.
It is also possible to read out the signature.
All other memory areas cannot be accessed.
There is no
@emph{chip erase}
functionality in debugWIRE mode; instead, while reprogramming the
flash, each flash page is erased right before updating it.
This is done transparently by the JTAG ICE mkII (or AVR Dragon).
The only way back from debugWIRE mode is to initiate a special
sequence of commands to the JTAG ICE mkII (or AVR Dragon), so the
debugWIRE mode will be temporarily disabled, and the target can
be accessed using normal ISP programming.
This sequence is automatically initiated by using the JTAG ICE mkII
or AVR Dragon in ISP mode, when they detect that ISP mode cannot be
entered.

@item
Problem: I want to use my JTAG ICE mkII to program an
Xmega device through PDI.  The documentation tells me to use the
@emph{XMEGA PDI adapter for JTAGICE mkII} that is supposed to ship
with the kit, yet I don't have it.

Solution: Use the following pin mapping:

@multitable @columnfractions .2 .2 .2 .2
@item @strong{JTAGICE} @tab @strong{Target} @tab @strong{Squid cab-} @tab @strong{PDI}
@item @strong{mkII probe} @tab @strong{pins} @tab @strong{le colors} @tab @strong{header}
@item 1 (TCK)   @tab         @tab Black  @tab
@item 2 (GND)   @tab GND     @tab White  @tab 6
@item 3 (TDO)   @tab         @tab Grey   @tab
@item 4 (VTref) @tab VTref   @tab Purple @tab 2
@item 5 (TMS)   @tab         @tab Blue   @tab
@item 6 (nSRST) @tab PDI_CLK @tab Green  @tab 5
@item 7 (N.C.)  @tab         @tab Yellow @tab
@item 8 (nTRST) @tab         @tab Orange @tab
@item 9 (TDI)   @tab PDI_DATA @tab Red   @tab 1
@item 10 (GND)  @tab         @tab Brown  @tab
@end multitable

@item
Problem: I want to use my AVR Dragon to program an
Xmega device through PDI.

Solution: Use the 6 pin ISP header on the Dragon and the following pin mapping:

@multitable @columnfractions .2 .2
@item @strong{Dragon} @tab @strong{Target}
@item @strong{ISP Header} @tab @strong{pins}
@item 1 (SDI)   @tab PDI_DATA
@item 2 (VCC)   @tab VCC
@item 3 (SCK)   @tab
@item 4 (SDO)   @tab
@item 5 (RESET) @tab PDI_CLK / RST
@item 6 (GND)   @tab GND
@end multitable

@item
Problem: I want to use my AVRISP mkII to program an
ATtiny4/5/9/10 device through TPI.  How to connect the pins?

Solution: Use the following pin mapping:

@multitable @columnfractions .2 .2 .2
@item @strong{AVRISP} @tab @strong{Target} @tab @strong{ATtiny}
@item @strong{connector} @tab @strong{pins} @tab @strong{pin #}
@item 1 (SDI)   @tab TPIDATA  @tab 1
@item 2 (VTref) @tab Vcc      @tab 5
@item 3 (SCK)   @tab TPICLK   @tab 3
@item 4 (SDO)   @tab          @tab
@item 5 (RESET) @tab /RESET   @tab 6
@item 6 (GND)   @tab GND      @tab 2
@end multitable

@item
Problem: I want to program an ATtiny4/5/9/10 device using a serial/parallel
bitbang programmer.  How to connect the pins?

Solution: Since TPI has only 1 pin for bi-directional data transfer, both
@var{SDI} and @var{SDO} pins should be connected to the @var{TPIDATA} pin
on the ATtiny device.
However, a 1K resistor should be placed between the @var{SDO} and @var{TPIDATA}.
The @var{SDI} pin connects to @var{TPIDATA} directly.
The @var{SCK} pin is connected to @var{TPICLK}.

In addition, the @var{Vcc}, @var{/RESET} and @var{GND} pins should
be connected to their respective ports on the ATtiny device.

@item
Problem: How can I use a FTDI FT232R USB-to-Serial device for bitbang programming?

Solution: When connecting the FT232 directly to the pins of the target Atmel device,
the polarity of the pins defined in the @code{programmer} definition should be
inverted by prefixing a tilde. For example, the @var{dasa} programmer would
look like this when connected via a FT232R device (notice the tildes in
front of pins 7, 4, 3 and 8):

@example
programmer
  id    = "dasa_ftdi";
  desc  = "serial port banging, reset=rts sck=dtr sdo=txd sdi=cts";
  type  = serbb;
  reset = ~7;
  sck   = ~4;
  sdo   = ~3;
  sdi   = ~8;
;
@end example

Note that this uses the FT232 device as a normal serial port, not using the
FTDI drivers in the special bitbang mode.

@item
Problem: My ATtiny4/5/9/10 reads out fine, but any attempt to program
it (through TPI) fails.  Instead, the memory retains the old contents.

Solution: Mind the limited programming supply voltage range of these
devices.

In-circuit programming through TPI is only guaranteed by the datasheet
at Vcc = 5 V.

@item
Problem: My ATxmega@dots{}A1/A2/A3 cannot be programmed through PDI with
my AVR Dragon.  Programming through a JTAG ICE mkII works though, as does
programming through JTAG.

Solution: None by this time (2010 Q1).

It is said that the AVR Dragon can only program devices from the A4
Xmega sub-family.

@item
Problem: when programming with an AVRISPmkII or STK600, AVRDUDE hangs
when programming files of a certain size (e.g. 246 bytes).  Other
(larger or smaller) sizes work though.

Solution: This is a bug caused by an incorrect handling of zero-length
packets (ZLPs) in some versions of the libusb 0.1 API wrapper that ships
with libusb 1.x in certain Linux distributions.  All Linux systems with
kernel versions < 2.6.31 and libusb >= 1.0.0 < 1.0.3 are reported to be
affected by this.

See also: @url{http://www.libusb.org/ticket/6}

@item
Problem: after flashing a firmware that reduces the target's clock
speed (e.g. through the @code{CLKPR} register), further ISP connection
attempts fail.  Or a programmer cannot initialize communication with
a brand new chip.

Solution: Even though ISP starts with pulling @var{/RESET} low, the
target continues to run at the internal clock speed either as defined by
the firmware running before or as set by the factory.  Therefore, the
ISP clock speed must be reduced appropriately (to less than 1/4 of the
internal clock speed) using the -B option before the ISP initialization
sequence will succeed.

As that slows down the entire subsequent ISP session, it might make
sense to just issue a @emph{chip erase} using the slow ISP clock
(option @code{-e}), and then start a new session at higher speed.
Option @code{-D} might be used there, to prevent another unneeded
erase cycle.

@end itemize

@c
@c Node
@c
@node List of Programmers, List of Parts, Troubleshooting, Top
@appendix List of Programmers

@cindex Programmers supported

AVRDUDE supports the programmers below: the left column lists the
programmer's id as used for @code{-c}, whilst the right column contains a
short description and the list of available programming interface(s) in
brackets; see @ref{Programmer Definitions}). There is more detail about
each programmer in the AVRDUDE configuration file.

@multitable @columnfractions .24 .75
@include programmers.texi
@end multitable

@c
@c Node
@c
@node List of Parts, List of Memories, List of Programmers, Top
@appendix List of Parts

AVRDUDE supports the parts below: the left column lists the part's id,
whilst the right column contains its official part name;  alternative
names, if any; and the list of available programming interfaces in
brackets; see @ref{Programmer Definitions}).  There is more detail about
each part in the AVRDUDE configuration file.

@multitable @columnfractions .15 .80
@include parts.texi
@end multitable

@noindent
@strong{Notes}

@noindent
1. Support of 32-bit AVR (via aWire or AVT32JTAG) is experimental at best.

@noindent
2. Flash addressing above 128 KB is not supported by all programming
hardware, though most will support it.

@noindent
3. The ISP programming protocol of the AT90S1200 differs in subtle ways from
that of other AVRs.  Thus, not all ISP programmers support this device.
Known to work are all direct bitbang programmers, and all programmers
talking the STK500v2 protocol.

@noindent
4. Not all programmers can serve all memories that a part has.
Bootloader can never write to fuses, for example.

@c
@c Node
@c
@node List of Memories, List of Parts, Index, Top
@appendix List of Memories

@menu
* Classic Parts::
* ATxmegas::
* Modern AVR Parts::
@end menu

@node Classic Parts, ATxmegas, List of Memories, List of Memories
@section Classic parts
@cindex Memories of classic parts

@noindent
@cindex @code{signature}
@cindex @code{flash}
@cindex @code{eeprom}
Classic devices may have the following memories in addition to
@code{eeprom}, @code{flash}, @code{signature} and @code{lock}:
@table @code
@cindex @code{calibration}
@item calibration
One or more bytes of RC oscillator calibration data
@item efuse
Extended fuse byte
@item fuse
Fuse byte in devices that have only a single fuse byte
@item hfuse
High fuse byte
@item lfuse
Low fuse byte
@item prodsig
Signature, calibration byte and serial number in a small read-only memory,
which is only documented to be available for ATmega324PB, ATmega328PB,
ATtiny102 and ATtiny104; AVRDUDE generally tries to make this memory
available, also for parts where it is not documented, but not all
programmers may be able to read this memory
@item sigrow
Memory alias for prodsig
@item sernum
The serial number part of prodsig; owing to scarce documentation this may not
actually turn out to be a serial number or be readable by some programmers
@item usersig
@cindex @code{flash}
Three extra flash pages for firmware settings; this memory is not erased
during a chip erase. Only some classic parts,
ATmega(64|128|256|644|1284|2564)RFR2, have a usersig memory. Usersig is
different to flash in the sense that it can neither be accessed with ISP
serial programming nor written to by bootloaders. AVRDUDE offers JTAG
programming of classic-part usersig memories. As with all flash-type
memories the @code{-U} option can only write 0-bits but not 1-bits.
Hence, usersig needs to be erased before a file can be written to this
memory region, e.g., using @code{-T "erase usersig" -U
usersig:w:parameters.hex:i}
@item io
Volatile register memory; it cannot be accessed by external programming
methods only by bootloaders, which has limited use unless the bootloader
jumps to the application directly, i.e., without a WDT reset
@item sram
Volatile RAM memory; like @code{io} it cannot be accessed by external
programming
@end table

@node ATxmegas, Modern AVR Parts, Classic Parts, List of Memories
@section ATxmegas
@cindex Memories of ATxmegas

@cindex @code{signature}
@cindex @code{flash}
@cindex @code{eeprom}
ATxmega devices have the following memories in addition to
@code{eeprom}, @code{flash}, @code{signature} and @code{lock}:
@table @code
@cindex @code{flash}
@cindex @code{application}
@item application
Application flash area
@cindex @code{flash}
@cindex @code{apptable}
@item apptable
Application table flash area
@cindex @code{flash}
@cindex @code{boot}
@item boot
Boot flash area
@cindex @code{calibration}
@cindex @code{calibration}
@item calibration
An area of 4 (ATxmega-A series) or 5 bytes (ATxmega-B/C/D/E) with
oscillator calibration values; this is a sub-memory of @code{prodsig}
@cindex @code{fuses}
@item fuses
A logical memory of 7 bytes containing all @code{fuse}X of a part, which
can be used to program all fuses at the same time; note that some of the
fuse bytes will be reserved, though
@cindex @code{fuse0}
@item fuse0
A.k.a. @code{jtaguid}: JTAG user ID for some devices
@cindex @code{fuse1}
@item fuse1
Watchdog configuration
@cindex @code{fuse6}
@item fuse6
Fault detection action configuration TC4/5 for ATxmega E series parts
@item fuse@emph{N}
Other fuse bytes of ATxmega devices, where @emph{N} is 2, 4 or 5, for system configuration
@cindex @code{prodsig}
@item prodsig
The production signature row is a read-only memory section for factory
programmed data such as calibration values for oscillators or analogue
modules; it also contains a serial number that consists of the production
lot number, wafer number and wafer coordinates for the part
@cindex @code{sernum}
@item sernum
Serial number with a unique ID for the part consisting of 10 bytes; these
are part of the @code{prodsig} memory above
@cindex @code{sigrow}
@item sigrow
Memory alias for prodsig
@cindex @code{tempsense}
@item tempsense
A two-byte memory, which is located within @code{prodsig}; it contains a 12-bit
temperature sensor calibration value
@cindex @code{flash}
@cindex @code{usersig}
@item usersig
Additional flash memory page that can be used for firmware settings; this
memory is not erased during a chip erase
@cindex @code{io}
@item io
Volatile register memory; AVRDUDE can read this memory but not write to it
using external programming
@cindex @code{sram}
@item sram
Volatile RAM memory; cannot be usefully accessed by external programming
@end table

@node Modern AVR Parts, , ATxmegas, List of Memories
@section Modern AVR Parts
@cindex Memories of modern AVR parts

@cindex @code{signature}
@cindex @code{flash}
@cindex @code{eeprom}
Modern 8-bit AVR devices have the following memories in addition to
@code{eeprom}, @code{flash}, @code{signature} and @code{lock}:
@table @code
@cindex @code{wdtcfg}
@item fuse0
A.k.a. @code{wdtcfg}: watchdog configuration
@cindex @code{bodcfg}
@item fuse1
A.k.a. @code{bodcfg}: brownout detection configuration
@cindex @code{osccfg}
@item fuse2
A.k.a. @code{osccfg}: oscillator configuration
@cindex @code{tcd0cfg}
@item fuse4
A.k.a. @code{tcd0cfg} (not all devices): timer counter type D configuration
@cindex @code{syscfg0}
@item fuse5
A.k.a. @code{syscfg0}: system configuration 0
@cindex @code{syscfg1}
@item fuse6
A.k.a. @code{syscfg1}: system configuration 1
@cindex @code{append}
@cindex @code{codesize}
@item fuse7
A.k.a. @code{append} or @code{codesize}: either the end of the application code section or the code size in blocks of 256/512 bytes
@cindex @code{bootend}
@cindex @code{bootsize}
@item fuse8
A.k.a. @code{bootend} or @code{bootsize}: end of the boot section or the boot size in blocks of 256/512 bytes
@cindex @code{pdicfg}
@item fusea
A.k.a. @code{pdicfg}: configures/locks updi access; it is the only fuse that consists of two bytes
@cindex @code{fuses}
@item fuses
A logical memory of up to 16 bytes containing all fuseX of a part, which can be used to program all fuses at the same time
@cindex @code{osc16err}
@item osc16err
Two bytes typically describing the 16 MHz oscillator frequency error at 3 V and 5 V, respectively
@cindex @code{osc20err}
@item osc20err
Two bytes typically describing the 20 MHz oscillator frequency error at 3 V and 5 V, respectively
@cindex @code{osccal16}
@item osccal16
@cindex @code{calibration}
Two oscillator calibration bytes for 16 MHz
@cindex @code{osccal20}
@item osccal20
@cindex @code{calibration}
Two oscillator calibration bytes for 20 MHz
@cindex @code{prodsig}
@item prodsig
@cindex @code{signature}
Read-only memory section for factory programmed data such as the
signature, calibration values and serial number
@cindex @code{sigrow}
@item sigrow
Memory alias for prodsig
@cindex @code{sernum}
@item sernum
Serial number with a unique ID for the part (10 or 16 bytes)
@cindex @code{tempsense}
@item tempsense
@cindex @code{calibration}
Temperature sensor calibration values
@cindex @code{bootrow}
@item bootrow
Extra page of memory that is only accessible by the MCU in bootloader
code; UDPI can read and write this memory only when the device is
unlocked
@cindex @code{eeprom}
@cindex @code{userrow}
@item userrow
Extra page of EEPROM memory that can be used for firmware settings; this
memory is not erased during a chip erase
@cindex @code{sib}
@item sib
Special system information block memory with information about AVR family, chip revision etc.
@cindex @code{io}
@item io
Volatile register memory; AVRDUDE can program this memory but this is of
limited utility because anything written to the io memory will be undefined or
lost after reset; writing to individual registers in the terminal can
still be used, e.g., to test I/O ports
@cindex @code{sram}
@item sram
Volatile RAM memory; can be read and written but contents will be lost after reset
@end table


@c
@c Node
@c
@node Index, , List of Memories, Top
@unnumbered Concept Index

@printindex cp

@bye
