%% -*-texinfo-*-
\input texinfo

@c $Id$

@setfilename avrdude.info
@settitle AVRDUDE
@finalout

@include version.texi

@c
@c These are set in version.texi which is automatically generated by automake.
@c
@c @set UPDATED 26 Febuary 2003
@c @set EDITION 3.2.0
@c @set VERSION 3.2.0

@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.
@dircategory AVR Programming & development tools.
@direntry
* AvrDude: (avrdude).            AVR program downloader/uploader.
@end direntry

@ifinfo
This file documents the avrdude program.

For avrdude version @value{VERSION}, @value{UPDATED}.

Copyright @copyright{} Brian Dean, J@"org Wunsch

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.

Alternatively, this documentation may be copied and distributed under
the terms of the GNU Free Documentation License (FDL), version 1.3.
@end ifinfo

@titlepage
@title AVRDUDE
@subtitle A program for download/uploading AVR microcontroller flash and eeprom.
@subtitle For AVRDUDE, Version @value{VERSION}, @value{UPDATED}.
@author by Brian S. Dean

@page

Use @uref{https://github.com/avrdudes/avrdude/issues} to report bugs and ask questions.

Copyright @copyright{} Brian S. Dean, J@"org Wunsch
@sp 2

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end titlepage

@contents

@c
@c Top Node
@c
@node Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up

@ifinfo
This file documents the avrdude program for downloading/uploading
programs to Atmel AVR microcontrollers.

For avrdude version @value{VERSION}, @value{UPDATED}.

Use @uref{https://github.com/avrdudes/avrdude/issues} to report bugs and ask questions.

Copyright @copyright{} Brian S. Dean, J@"org Wunsch
@end ifinfo

@menu
* Introduction::                
* Command Line Options::
* Terminal Mode Operation::
* Configuration File::          
* Programmer Specific Information::
* Platform Dependent Information::
* Troubleshooting::
* Index::
@end menu

@c
@c Node
@c
@node Introduction, Command Line Options, Top, Top
@comment  node-name,  next,  previous,  up
@chapter Introduction
@cindex Introduction

AVRDUDE - AVR Downloader Uploader - is a program for downloading and
uploading the on-chip memories of Atmel's AVR microcontrollers. It can
program the Flash and EEPROM, and where supported by the serial
programming protocol, it can program fuse and lock bits. AVRDUDE also
supplies a direct instruction mode allowing one to issue any programming
instruction to the AVR chip regardless of whether AVRDUDE implements
that specific feature of a particular chip.

AVRDUDE can be used effectively via the command line to read or write
all chip memory types (eeprom, flash, fuse bits, lock bits, signature
bytes) or via an interactive (terminal) mode. Using AVRDUDE from the
command line works well for programming the entire memory of the chip
from the contents of a file, while interactive mode is useful for
exploring memory contents, modifying individual bytes of eeprom,
programming fuse/lock bits, etc.

@cindex Programmers supported

AVRDUDE supports the following basic programmer types: Atmel's STK500,
Atmel's AVRISP and AVRISP mkII devices,
Atmel's STK600,
Atmel's JTAG ICE (the original one, mkII, and 3, the latter two also in ISP mode), appnote
avr910, appnote avr109 (including the AVR Butterfly),
serial bit-bang adapters,
and the PPI (parallel port interface). PPI represents a class
of simple programmers where the programming lines are directly
connected to the PC parallel port. Several pin configurations exist
for several variations of the PPI programmers, and AVRDUDE can be
configured to work with them by either specifying the appropriate
programmer on the command line or by creating a new entry in its
configuration file. All that's usually required for a new entry is to
tell AVRDUDE which pins to use for each programming function.

A number of equally simple bit-bang programming adapters that connect
to a serial port are supported as well, among them the popular
Ponyprog serial adapter, and the DASA and DASA3 adapters that used to
be supported by uisp(1).  Note that these adapters are meant to be
attached to a physical serial port.  Connecting to a serial port
emulated on top of USB is likely to not work at all, or to work
abysmally slow.

If you happen to have a Linux system with at least 4 hardware GPIOs 
available (like almost all embedded Linux boards) you can do without any
additional hardware - just connect them to the SDO, SDI, RESET and SCK
pins of the AVR's SPI interface and use the linuxgpio programmer
type. Older boards might use the labels MOSI for SDO and MISO for SDI. It bitbangs
the lines using the Linux sysfs GPIO interface. Of course, care should
be taken about voltage level compatibility. Also, although not strictly 
required, it is strongly advisable to protect the GPIO pins from 
overcurrent situations in some way. The simplest would be to just put
some resistors in series or better yet use a 3-state buffer driver like
the 74HC244. Have a look at http://kolev.info/blog/2013/01/06/avrdude-linuxgpio/ for a more
detailed tutorial about using this programmer type.

Under a Linux installation with direct access to the SPI bus and GPIO
pins, such as would be found on a Raspberry Pi, the ``linuxspi''
programmer type can be used to directly connect to and program a chip
using the built in interfaces on the computer. The requirements to use
this type are that an SPI interface is exposed along with one GPIO
pin. The GPIO serves as the reset output since the Linux SPI drivers
do not hold chip select down when a transfer is not occuring and thus
it cannot be used as the reset pin. A readily available level
translator should be used between the SPI bus/reset GPIO and the chip
to avoid potentially damaging the computer's SPI controller in the
event that the chip is running at 5V and the SPI runs at 3.3V. The
GPIO chosen for reset can be configured in the avrdude configuration
file using the @code{reset} entry under the linuxspi programmer, or
directly in the port specification. An external pull-up resistor
should be connected between the AVR's reset pin and Vcc. If Vcc is not
the same as the SPI voltage, this should be done on the AVR side of
the level translator to protect the hardware from damage.

On a Raspberry Pi, header J8 provides access to the SPI and GPIO
lines.

Typically, pins 19, 21, and 23 are SPI SDO, SDI, and SCK, while
pins 24 and 26 would serve as CE outputs. So, close to these pins
is pin 22 as GPIO25 which can be used as /RESET, and pin 25 can
be used as GND.

A typical programming cable would then look like:

@multitable @columnfractions .15 .15 .3
@item @code{J8 pin} @tab @code{ISP pin} @tab @code{Name}
@item @code{21}     @tab @code{1}   @tab @code{SDI}
@item @code{-}      @tab @code{2}   @tab @code{Vcc - leave open}
@item @code{23}     @tab @code{3}   @tab @code{SCK}
@item @code{19}     @tab @code{4}   @tab @code{SDO}
@item @code{22}     @tab @code{5}   @tab @code{/RESET}
@item @code{25}     @tab @code{6}   @tab @code{GND}
@end multitable

(Mind the 3.3 V voltage level of the Raspberry Pi!)

The @code{-P @var{portname}} option defaults to
@code{/dev/spidev0.0:/dev/gpiochip0} for this programmer.

The STK500, JTAG ICE, avr910, and avr109/butterfly use the serial port to communicate with the PC.
The STK600, JTAG ICE mkII/3, AVRISP mkII, USBasp, avrftdi (and derivatives), and USBtinyISP
programmers communicate through the USB, using @code{libusb} as a
platform abstraction layer.
The avrftdi adds support for the FT2232C/D, FT2232H, and FT4232H devices. These all use 
the MPSSE mode, which has a specific pin mapping. Bit 0 (the lsb of the byte in the config
file) is SCK. Bit 1 is SDO, and Bit 2 is SDI. Bit 3 usually reset. The 2232C/D parts
are only supported on interface A, but the H parts can be either A or B (specified by the
usbdev config parameter).
The STK500, STK600, JTAG ICE, and avr910 contain on-board logic to control the programming of the target
device.
The avr109 bootloader implements a protocol similar to avr910, but is
actually implemented in the boot area of the target's flash ROM, as
opposed to being an external device.
The fundamental difference between the two types lies in the
protocol used to control the programmer. The avr910 protocol is very
simplistic and can easily be used as the basis for a simple, home made
programmer since the firmware is available online. On the other hand,
the STK500 protocol is more robust and complicated and the firmware is
not openly available.
The JTAG ICE also uses a serial communication protocol which is similar
to the STK500 firmware version 2 one.  However, as the JTAG ICE is
intended to allow on-chip debugging as well as memory programming, the
protocol is more sophisticated.
(The JTAG ICE mkII protocol can also be run on top of USB.)
Only the memory programming functionality of the JTAG ICE is supported
by AVRDUDE.
For the JTAG ICE mkII/3, JTAG, debugWire and ISP mode are supported, provided
it has a firmware revision of at least 4.14 (decimal).
See below for the limitations of debugWire.
For ATxmega devices, the JTAG ICE mkII/3 is supported in PDI mode, provided it
has a revision 1 hardware and firmware version of at least 5.37 (decimal).

The Atmel-ICE (ARM/AVR) is supported (JTAG, PDI for Xmega, debugWIRE, ISP,
UPDI).

Atmel's XplainedPro boards, using EDBG protocol (CMSIS-DAP compliant), are
supported by the ``jtag3'' programmer type.

Atmel's XplainedMini boards, using mEDBG protocol, are also
supported by the ``jtag3'' programmer type.

The AVR Dragon is supported in all modes (ISP, JTAG, PDI, HVSP, PP, debugWire).
When used in JTAG and debugWire mode, the AVR Dragon behaves similar to a
JTAG ICE mkII, so all device-specific comments for that device
will apply as well.
When used in ISP and PDI mode, the AVR Dragon behaves similar to an
AVRISP mkII (or JTAG ICE mkII in ISP mode), so all device-specific
comments will apply there.
In particular, the Dragon starts out with a rather fast ISP clock
frequency, so the @code{-B @var{bitclock}}
option might be required to achieve a stable ISP communication.
For ATxmega devices, the AVR Dragon is supported in PDI mode, provided it
has a firmware version of at least 6.11 (decimal).

Wiring boards (e.g. Arduino Mega 2560 Rev3) are supported, utilizing
STK500 V2.x protocol, but a simple DTR/RTS toggle to set the boards
into programming mode.  The programmer type is ``wiring''. Note that
the -D option will likely be required in this case, because the
bootloader will rewrite the program memory, but no true chip erase can
be performed.

Serial bootloaders that run a skeleton of the STK500 1.x protocol are supported via
their own programmer type specification ``arduino''.  This programmer works for
the Arduino Uno Rev3 or any AVR that runs the Optiboot bootloader.
The number of connection retry attempts can be specified as an
extended parameter. See the section on
@emph{extended parameters}
below for details.

Urprotocol is a leaner version of the STK500 1.x protocol that is designed
to be backwards compatible with STK500 v1.x; it allows bootloaders to be
much smaller, e.g., as implemented in the urboot project
@uref{https://github.com/stefanrueger/urboot}. The programmer type ``urclock''
caters for these urboot bootloaders. Owing to its backward compatibility,
bootloaders that can be served by the arduino programmer can normally also
be served by the urclock programmer. This may require specifying the size
of (to AVRDUDE) @emph{unknown} bootloaders in bytes using the @code{-x
bootsize=<n>} option, which is necessary for the urclock programmer to
enable it to protect the bootloader from being overwritten. If an unknown
bootloader has EEPROM read/write capability then the option @code{-x eepromrw}
informs @code{avrdude -c urclock} of that capability.

The BusPirate is a versatile tool that can also be used as an AVR programmer.
A single BusPirate can be connected to up to 3 independent AVRs. See
the section on
@emph{extended parameters}
below for details.

The USBasp ISP, USBtinyISP and CH341A adapters are also supported, provided
AVRDUDE has been compiled with libusb support.
They former two feature simple firmware-only USB implementations, running on
an ATmega8 (or ATmega88), or ATtiny2313, respectively.
CH341A programmers connect directly to the AVR target. Their SPI bit clock
is approximately 1.7@w{ }MHz and cannot be changed. As a consequence, the
AVR target must have a CPU frequency of 6.8@w{ }MHz or more: factory-set
AVR parts, which typically run on an internal oscillator between 1 MHz and
1.6 MHz, cannot be programmed using @code{-c ch341a}.

The Atmel DFU bootloader is supported in both, FLIP protocol version 1
(AT90USB* and ATmega*U* devices), as well as version 2 (Xmega devices).
See below for some hints about FLIP version 1 protocol behaviour.

The MPLAB(R) PICkit 4 and MPLAB(R) SNAP are supported in JTAG, TPI, ISP, PDI and UPDI mode.
The Curiosity Nano board is supported in UPDI mode. It is dubbed ``PICkit on
Board'', thus the name @code{pkobn_updi}.

SerialUPDI programmer implementation is based on Microchip's 
@emph{pymcuprog} (@url{https://github.com/microchip-pic-avr-tools/pymcuprog}) 
utility, but it also contains some performance improvements included in
Spence Konde's @emph{DxCore} Arduino core (@url{https://github.com/SpenceKonde/DxCore}).
In a nutshell, this programmer consists of simple USB->UART adapter, diode 
and couple of resistors. It uses serial connection to provide UPDI interface. 
@xref{SerialUPDI programmer} for more details and known issues.

The jtag2updi programmer is supported,
and can program AVRs with a UPDI interface.
Jtag2updi is just a firmware that can be uploaded to an AVR,
which enables it to interface with avrdude using the jtagice mkii protocol
via a serial link (@url{https://github.com/ElTangas/jtag2updi}).

The Micronucleus bootloader is supported for both protocol version V1
and V2. As the bootloader does not support reading from flash memory,
use the @code{-V} option to prevent AVRDUDE from verifying the flash memory.
See the section on @emph{extended parameters}
below for Micronucleus specific options.

The Teensy bootloader is supported for all AVR boards.
As the bootloader does not support reading from flash memory,
use the @code{-V} option to prevent AVRDUDE from verifying the flash memory.
See the section on @emph{extended parameters}
below for Teensy specific options.

@menu
* History::                     
@end menu

@c
@c Node
@c
@node History,  , Introduction, Introduction
@cindex History
@section History and Credits

AVRDUDE was written by Brian S. Dean under the name of AVRPROG to run on
the FreeBSD Operating System.  Brian renamed the software to be called
AVRDUDE when interest grew in a Windows port of the software so that the
name did not conflict with AVRPROG.EXE which is the name of Atmel's
Windows programming software.

For many years, the AVRDUDE source resided in public repositories on
savannah.nongnu.org,
where it continued to be enhanced and ported to other systems.  In
addition to FreeBSD, AVRDUDE now runs on Linux and Windows.  The
developers behind the porting effort primarily were Ted Roth, Eric
Weddington, and Joerg Wunsch.

In 2022, the project moved to Github (@url{https://github.com/avrdudes/avrdude/}).

And in the spirit of many open source projects, this manual also draws
on the work of others.  The initial revision was composed of parts of
the original Unix manual page written by Joerg Wunsch, the original web
site documentation by Brian Dean, and from the comments describing the
fields in the AVRDUDE configuration file by Brian Dean.  The texi
formatting was modeled after that of the Simulavr documentation by Ted
Roth.


@c
@c Node
@c
@node Command Line Options, Terminal Mode Operation, Introduction, Top
@chapter Command Line Options

@menu
* Option Descriptions::
* Programmers accepting extended parameters::
* Example Command Line Invocations::
@end menu

@c
@c Node
@c
@node Option Descriptions, Programmers accepting extended parameters, Command Line Options, Command Line Options
@cindex Options (command-line)
@section Option Descriptions

@noindent
AVRDUDE is a command line tool, used as follows:

@smallexample
avrdude -p partno @var{options} @dots{}
@end smallexample

@noindent
Command line options are used to control AVRDUDE's behaviour.  The
following options are recognized:

@table @code
@item -p @var{partno}
This option tells AVRDUDE what part (MCU) is connected to the programmer. The
@var{partno} parameter is the part's id listed in the configuration file. To
see a list of currently supported MCUs use ? as partno, which will print the
part ids and official part names. In connection with -v, this will also print a
list of variant part names followed by an optional colon, the package code and
some absolute maximum ratings. The part id, their official part name, any of
the full variant part names or their initial part up to a dash can be used to
specify a part with the -p option. If a part is unknown to AVRDUDE, it means
that there is no config file entry for that part, but it can be added to the
configuration file if you have the Atmel datasheet so that you can enter the
programming specifications. If @code{-p ?} is specified with a specific
programmer, see @code{-c} below, then only those parts are output that the
programmer expects to be able to handle, together with the programming
interface(s) that can be used in that combination. In reality there can be
deviations from this list, particularly if programming is directly via a
bootloader. Currently, the following MCU types are understood:

@cindex Device support

@multitable @columnfractions .15 .45
@include parts.texi
@end multitable

(*)   The AT90S2323 and ATtiny22 use the same algorithm.

(**)  Flash addressing above 128 KB is not supported by all
programming hardware.  Known to work are jtag2, stk500v2,
and bit-bang programmers.

(***)
The ATtiny11 can only be
programmed in high-voltage serial mode.

(****)
The ISP programming protocol of the AT90S1200 differs in subtle ways
from that of other AVRs.  Thus, not all programmers support this
device.  Known to work are all direct bitbang programmers, and all
programmers talking the STK500v2 protocol.

@item -p @var{wildcard/flags}
Run developer options for MCUs that are matched by @var{wildcard}. Whilst
their main use is for developers some @var{flags} can be of utility for
users, e.g.,  @code{avrdude -p m328p/S} outputs AVRDUDE's understanding of
ATmega328P MCU properties; for more information run @code{avrdude -p x/h}.

@item -b @var{baudrate}
Override the RS-232 connection baud rate specified in the respective
programmer's entry of the configuration file.

@item -B @var{bitclock}
Specify the bit clock period for the JTAG, PDI, TPI, UPDI, or ISP
interface. The value is a floating-point number in microseconds.
Alternatively, the value might be suffixed with "Hz", "kHz" or
"MHz" in order to specify the bit clock frequency rather than a
period. Some programmers default their bit clock value to a 1
microsecond bit clock period, suitable for target MCUs running at 4
MHz clock and above. Slower MCUs need a correspondingly higher bit
clock period. Some programmers reset their bit clock value to the
default value when the programming software signs off, whilst
others store the last used bit clock value. It is recommended to
always specify the bit clock if read/write speed is important.  You
can use the 'default_bitclock' keyword in your
@code{~/.config/avrdude/avrdude.rc} or @code{~/.avrduderc}
configuration file to assign a default value to keep from having to
specify this option on every invocation.

Note that some official Microchip programmers store the bitclock setting and
will continue to use it until a different value is provided. This applies to
"2nd gen" programmers (AVRISPmkII, AVR Dragon, JTAG ICE mkII, STK600) and
"3rd gen"programmers (JTAGICE3, Atmel ICE, Power Debugger). "4th gen"
programmers (PICkit 4, MPLAB SNAP) will store the last user-specified bitclock
until the programmer is disconnected from the computer.

@item -c @var{programmer-id}
Specify the programmer to be used.  AVRDUDE knows about several common
programmers.  Use this option to specify which one to use.  The
@var{programmer-id} parameter is the programmer's id listed in the
configuration file.  Specify -c ? to list all programmers in the
configuration file.  If you have a programmer that is unknown to
AVRDUDE, and the programmer is controlled via the PC parallel port,
there's a good chance that it can be easily added to the configuration
file without any code changes to AVRDUDE.  Simply copy an existing entry
and change the pin definitions to match that of the unknown programmer.
If @code{-c ?} is specified with a specific part, see @code{-p} above, then
only those programmers are output that expect to be able to handle this part,
together with the programming interface(s) that can be used in that
combination. In reality there can be deviations from this list, particularly
if programming is directly via a bootloader. Currently, the following
programmer ids are understood and supported:

@cindex Programmer support

@multitable @columnfractions .3 .68
@include programmers.texi
@end multitable



@item -c @var{wildcard/flags}
Run developer options for programmers that are matched by @var{wildcard}.
Whilst their main use is for developers some @var{flags} can be of utility
for users, e.g., @code{avrdude -c usbtiny/S} shows AVRDUDE's understanding of
usbtiny's properties; for more information run @code{avrdude -c x/h}.

@item -C @var{config-file}
Use the specified config file for configuration data.  This file
contains all programmer and part definitions that AVRDUDE knows about.
If not specified, AVRDUDE looks for the configuration file in the following
two locations:

@enumerate

@item
@code{<directory from which application loaded>/../etc/avrdude.conf}

@item
@code{<directory from which application loaded>/avrdude.conf}

@end enumerate

If not found there, the lookup procedure becomes platform dependent. On FreeBSD
and Linux, AVRDUDE looks at @code{/usr/local/etc/avrdude.conf}. See Appendix A
for the method of searching on Windows.

If @var{config-file} is written as @var{+filename}
then this file is read after the system wide and user configuration 
files. This can be used to add entries to the configuration
without patching your system wide configuration file. It can be used 
several times, the files are read in same order as given on the command 
line.

@item -A
Disable the automatic removal of trailing-0xFF sequences in file
input that is to be programmed to flash and in AVR reads from
flash memory. Normally, trailing 0xFFs can be discarded, as flash
programming requires the memory be erased to 0xFF beforehand. -A
should be used when the programmer hardware, or bootloader
software for that matter, does not carry out chip erase and
instead handles the memory erase on a page level. The popular
Arduino bootloader exhibits this behaviour; for this reason -A is
engaged by default when specifying -c arduino.

@item -D
Disable auto erase for flash.  When the -U option with flash memory is 
specified, avrdude will perform a chip erase before starting any of the 
programming operations, since it generally is a mistake to program the flash
without performing an erase first.  This option disables that.
Auto erase is not used for ATxmega devices as these devices can
use page erase before writing each page so no explicit chip erase
is required.
Note however that any page not affected by the current operation
will retain its previous contents.
Setting -D implies -A.

@item -e
Causes a chip erase to be executed.  This will reset the contents of the
flash ROM and EEPROM to the value `0xff', and clear all lock bits.
Except for ATxmega devices which can use page erase,
it is basically a
prerequisite command before the flash ROM can be reprogrammed again.
The only exception would be if the new contents would exclusively cause
bits to be programmed from the value `1' to `0'.  Note that in order
to reprogram EERPOM cells, no explicit prior chip erase is required
since the MCU provides an auto-erase cycle in that case before
programming the cell.


@item -E @var{exitspec}[,@dots{}]
By default, AVRDUDE leaves the parallel port in the same state at exit
as it has been found at startup.  This option modifies the state of the
`/RESET' and `Vcc' lines the parallel port is left at, according to
the exitspec arguments provided, as follows:

@table @code
@item reset
The `/RESET' signal will be left activated at program exit, that is it
will be held low, in order to keep the MCU in reset state afterwards.
Note in particular that the programming algorithm for the AT90S1200
device mandates that the `/RESET' signal is active before powering up
the MCU, so in case an external power supply is used for this MCU type,
a previous invocation of AVRDUDE with this option specified is one of
the possible ways to guarantee this condition. @code{reset} is supported
by the @code{linuxspi} and @code{flip2} programmer options, as well as
all parallel port based programmers.

@item noreset
The `/RESET' line will be deactivated at program exit, thus allowing the
MCU target program to run while the programming hardware remains
connected. @code{noreset} is supported by the @code{linuxspi} and
@code{flip2} programmer options, as well as all parallel port based
programmers.

@item vcc
This option will leave those parallel port pins active (i. e. high) that
can be used to supply `Vcc' power to the MCU.

@item novcc
This option will pull the `Vcc' pins of the parallel port down at
program exit.

@item d_high
This option will leave the 8 data pins on the parallel port active
(i. e. high).

@item d_low
This option will leave the 8 data pins on the parallel port inactive
(i. e. low).

@end table

Multiple @var{exitspec} arguments can be separated with commas.


@item -F
Normally, AVRDUDE tries to verify that the device signature read from
the part is reasonable before continuing.  Since it can happen from time
to time that a device has a broken (erased or overwritten) device
signature but is otherwise operating normally, this options is provided
to override the check.
Also, for programmers like the Atmel STK500 and STK600 which can
adjust parameters local to the programming tool (independent of an
actual connection to a target controller), this option can be used
together with @option{-t} to continue in terminal mode.
Moreover, the option allows to continue despite failed initialization
of connection between a programmer and a target.

@item -i @var{delay}
For bitbang-type programmers, delay for approximately
@var{delay}
microseconds between each bit state change.
If the host system is very fast, or the target runs off a slow clock
(like a 32 kHz crystal, or the 128 kHz internal RC oscillator), this
can become necessary to satisfy the requirement that the ISP clock
frequency must not be higher than 1/4 of the CPU clock frequency.
This is implemented as a spin-loop delay to allow even for very
short delays.
On Unix-style operating systems, the spin loop is initially calibrated
against a system timer, so the number of microseconds might be rather
realistic, assuming a constant system load while AVRDUDE is running.
On Win32 operating systems, a preconfigured number of cycles per
microsecond is assumed that might be off a bit for very fast or very
slow machines.

@item -l @var{logfile}
Use @var{logfile} rather than @var{stderr} for diagnostics output.
Note that initial diagnostic messages (during option parsing) are still
written to @var{stderr} anyway.

@item -n
No-write - disables actually writing data to the MCU (useful for
debugging AVRDUDE).

@item -O
Perform a RC oscillator run-time calibration according to Atmel
application note AVR053.
This is only supported on the STK500v2, AVRISP mkII, and JTAG ICE mkII
hardware.
Note that the result will be stored in the EEPROM cell at address 0.

@item -P @var{port}
Use port to identify the device to which the programmer is attached.
Normally, the default parallel port is used, but if the programmer type
normally connects to the serial port, the default serial port will be
used. See Appendix A, Platform Dependent Information, to find out the
default port names for your platform. If you need to use a different
parallel or serial port, use this option to specify the alternate port name.

On Win32 operating systems, the parallel ports are referred to as lpt1
through lpt3, referring to the addresses 0x378, 0x278, and 0x3BC,
respectively.  If the parallel port can be accessed through a different
address, this address can be specified directly, using the common C
language notation (i. e., hexadecimal values are prefixed by @var{0x}).

For the JTAG ICE mkII, if AVRDUDE has been built with libusb support,
@var{port} may alternatively be specified as
@code{usb}[:@var{serialno}].  In that case, the JTAG ICE mkII will be
looked up on USB.  If @var{serialno} is also specified, it will be
matched against the serial number read from any JTAG ICE mkII found on
USB.  The match is done after stripping any existing colons from the
given serial number, and right-to-left, so only the least significant
bytes from the serial number need to be given.
For a trick how to find out the serial numbers of all JTAG ICEs
attached to USB, see @ref{Example Command Line Invocations}.

As the AVRISP mkII device can only be talked to over USB, the very
same method of specifying the port is required there.

For the USB programmer "AVR-Doper" running in HID mode, the port must
be specified as @var{avrdoper}. Libhidapi support is required on Unix
and Mac OS but not on Windows. For more information about AVR-Doper see
@url{http://www.obdev.at/avrusb/avrdoper.html}.

For the USBtinyISP, which is a simplistic device not implementing
serial numbers, multiple devices can be distinguished by their
location in the USB hierarchy.
See the respective
@xref{Troubleshooting} entry for examples.

For the XBee programmer the target MCU is to be programmed wirelessly
over a ZigBee mesh using the XBeeBoot bootloader.  The ZigBee 64-bit
address for the target MCU's own XBee device must be supplied as a
16-character hexadecimal value as a port prefix, followed by the
@code{@@} character, and the serial device to connect to a second
directly contactable XBee device associated with the same mesh (with
a default baud rate of 9600).  This may look similar to:
@code{0013a20000000001@/dev/tty.serial}.

For diagnostic purposes, if the target MCU with an XBeeBoot
bootloader is connected directly to the serial port, the
64-bit address field can be omitted.  In this mode the
default baud rate will be 19200.

For programmers that attach to a serial port using some kind of
higher level protocol (as opposed to bit-bang style programmers),
@var{port} can be specified as @code{net}:@var{host}:@var{port}.
In this case, instead of trying to open a local device, a TCP
network connection to (TCP) @var{port} on @var{host}
is established.
Square brackets may be placed around @var{host} to improve
readability for numeric IPv6 addresses (e.g.
@code{net:[2001:db8::42]:1337}).
The remote endpoint is assumed to be a terminal or console server
that connects the network stream to a local serial port where the
actual programmer has been attached to.
The port is assumed to be properly configured, for example using a
transparent 8-bit data connection without parity at 115200 Baud
for a STK500.

Note: The ability to handle IPv6 hostnames and addresses is limited to
Posix systems (by now).

@item -q
Disable (or quell) output of the progress bar while reading or writing
to the device.  Specify it a second time for even quieter operation.

@item -s, -u
These options used to control the obsolete "safemode" feature which
is no longer present. They are silently ignored for backwards compatibility.

@item -t
Tells AVRDUDE to enter the interactive ``terminal'' mode instead of up-
or downloading files.  See below for a detailed description of the
terminal mode.

@item -U @var{memtype}:@var{op}:@var{filename}[:@var{format}]
Perform a memory operation.
Multiple @option{-U} options can be specified in order to operate on
multiple memories on the same command-line invocation.  The
@var{memtype} field specifies the memory type to operate on. Use
the @option{-v} option on the command line or the @code{part} command from
terminal mode to display all the memory types supported by a particular
device.
Typically, a device's memory configuration at least contains
the memory types
@code{flash}
and
@code{eeprom}.
All memory types currently known are:
@table @code
@item calibration
One or more bytes of RC oscillator calibration data.
@item eeprom
The EEPROM of the device.
@item efuse
The extended fuse byte.
@item flash
The flash ROM of the device.
@item fuse
The fuse byte in devices that have only a single fuse byte.
@item hfuse
The high fuse byte.
@item lfuse
The low fuse byte.
@item lock
The lock byte.
@item signature
The three device signature bytes (device ID).
@item fuse@emph{N}
The fuse bytes of ATxmega devices, @emph{N} is an integer number
for each fuse supported by the device.
@item application
The application flash area of ATxmega devices.
@item apptable
The application table flash area of ATxmega devices.
@item boot
The boot flash area of ATxmega devices.
@item prodsig
The production signature (calibration) area of ATxmega devices.
@item usersig
The user signature area of ATxmega devices.
@end table

The @var{op} field specifies what operation to perform:

@table @code
@item r
read the specified device memory and write to the specified file

@item w
read the specified file and write it to the specified device memory

@item v
read the specified device memory and the specified file and perform a verify operation

@end table

The @var{filename} field indicates the name of the file to read or
write.  The @var{format} field is optional and contains the format of
the file to read or write.  Possible values are:

@table @code
@item i
Intel Hex

@item I
Intel Hex with comments on download and tolerance of checksum errors on upload

@item s
Motorola S-record

@item r
raw binary; little-endian byte order, in the case of the flash ROM data

@item e
ELF (Executable and Linkable Format), the final output file from the
linker; currently only accepted as an input file

@item m
immediate mode; actual byte values specified on the command line,
separated by commas or spaces in place of the @var{filename} field of
the @option{-U} option.  This is useful
for programming fuse bytes without having to create a single-byte file
or enter terminal mode.  If the number specified begins with @code{0x},
it is treated as a hex value.  If the number otherwise begins with a
leading zero (@code{0}) it is treated as octal.  Otherwise, the value is
treated as decimal.

@item a
auto detect; valid for input only, and only if the input is not provided
at stdin.

@item d
decimal; this and the following formats are only valid on output.
They generate one line of output for the respective memory section,
forming a comma-separated list of the values.
This can be particularly useful for subsequent processing, like for
fuse bit settings.

@item h
hexadecimal; each value will get the string @emph{0x} prepended.
Only valid on output.

@item o
octal; each value will get a @emph{0}
prepended unless it is less than 8 in which case it gets no prefix.
Only valid on output.

@item b
binary; each value will get the string @emph{0b} prepended.
Only valid on output.

@end table

The default is to use auto detection for input files, and raw binary
format for output files.

Note that if @var{filename} contains a colon, the @var{format} field is
no longer optional since the filename part following the colon would
otherwise be misinterpreted as @var{format}.

When reading any kind of flash memory area (including the various sub-areas
in Xmega devices), the resulting output file will be truncated to not contain
trailing 0xFF bytes which indicate unprogrammed (erased) memory.
Thus, if the entire memory is unprogrammed, this will result in an output
file that has no contents at all.

As an abbreviation, the form @code{-U} @var{filename}
is equivalent to specifying
@code{-U} @emph{flash:w:}@var{filename}@emph{:a}.
This will only work if @var{filename} does not have a colon in it.

@item -v
Enable verbose output.
More @code{-v} options increase verbosity level.

@item -V
Disable automatic verify check when uploading data.

@item -x @var{extended_param}
Pass @var{extended_param} to the chosen programmer implementation as
an extended parameter.  The interpretation of the extended parameter
depends on the programmer itself.  See below for a list of programmers
accepting extended parameters.

@end table

@page
@c
@c Node
@c
@node Programmers accepting extended parameters, Example Command Line Invocations, Option Descriptions, Command Line Options
@section Programmers accepting extended parameters
@cindex @code{-x} AVR Dragon
@table @code

@item JTAG ICE mkII/3
@itemx Atmel-ICE
@itemx PICkit 4
@itemx MPLAB SNAP
@itemx Power Debugger
@itemx AVR Dragon

When using the JTAG ICE mkII, JTAGICE3, Atmel-ICE, PICkit 4, MPLAB SNAP,
Power Debugger or AVR Dragon in JTAG mode, the following extended parameter
is accepted:
@table @code
@item @samp{jtagchain=UB,UA,BB,BA}
Setup the JTAG scan chain for @var{UB} units before, @var{UA} units
after, @var{BB} bits before, and @var{BA} bits after the target AVR,
respectively.
Each AVR unit within the chain shifts by 4 bits.
Other JTAG units might require a different bit shift count.

@item @samp{hvupdi}
@var{Power Debugger and Pickit 4 only}
@*
High-voltage UPDI programming is used to enable a UPDI pin that has previously
been set to RESET or GPIO mode. Use @samp{-xhvupdi} to enable high-voltage UPDI
initialization for supported targets.

@item @samp{vtarg=VALUE, vtarg}
@var{Power Debugger only}
@*
The voltage generator can be enabled by setting a target voltage.
The current set-voltage can be read by @samp{-xvtarg} alone.

@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Xplained Mini
@item Xplained Mini

The Xplained Mini/Nano programmer (ISP or UPDI, not TPI) type accepts the
following extended parameters:

@table @code
@item @samp{suffer=VALUE}, @samp{suffer}
The SUFFER register allows the user to modify the behavior of the on-board mEDBG.
The current state can be read by @samp{-xsuffer} alone.
@table @code
@item Bit 7 ARDUINO:
Adds control of extra LEDs when set to 0
@item Bit 6..3:
Reserved (must be set to 1)
@item Bit 2 EOF:
Agressive power-down, sleep after 5 seconds if no USB enumeration when set to 0
@item Bit 1 LOWP:
forc running the mEDBG at 1 MHz when bit set to 0
@item Bit 0 FUSE:
Fuses are safe-masked when bit sent to 1. Fuses are unprotected when set to 0
@end table
@end table

@table @code
@item @samp{vtarg_switch=VALUE}, @samp{vtarg_switch}
The on-board target voltage switch can be turned on or off by writing a 1 or
a 0. The current state can be read by @samp{-xvtarg_switch} alone.
Note that the target power switch will always be on after a power cycle.
Also note that the smaller Xplained Nano boards does not have a target power switch.

@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Curiosity Nano
@item Curiosity Nano

The Curiosity Nano board accepts the following extended parameter:
@table @code
@item @samp{vtarg=VALUE, vtarg}
The generated on-board target voltage can be changed by specifying a new voltage.
The current set-voltage can be read by @samp{-xvtarg} alone.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} STK500
@cindex @code{-x} STK600
@item STK500
@item STK600

The STK500 and STK600 boards accept the following extended parameters:
@table @code
@item @samp{vtarg=VALUE, vtarg}
The generated on-board target voltage can be changed by specifying a new voltage.
The current set-voltage can be read by @samp{-xvtarg} alone.
@item @samp{fosc=VALUE[MHz|M|kHz|k|Hz], fosc}
Set the programmable oscillator frequency in MHz, kHz or Hz.
The current frequency can be read by @samp{-xfosc} alone.
@item @samp{varef=VALUE, varef}
The generated on-board analog reference voltage can be changed by specifying
a new reference voltage. The current reference voltage can be read by
@samp{-xvaref} alone.
@item @samp{varef[0,1]=VALUE, varef[0,1]}
@var{STK600 only}
@*
The generated on-board analog reference voltage for channel 0 or channel 1 can
be changed by specifying a new reference voltage.
The current reference voltage can be read by @samp{-xvaref0} or
@samp{-xvaref1} alone.
@item @samp{attemps[=<1..99>]}
@var{STK500V1 only}
@*
Specify how many connection retry attemps to perform before exiting.
Defaults to 10 if not specified.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} AVR910
@item AVR910

The AVR910 programmer type accepts the following extended parameter:
@table @code
@item @samp{devcode=VALUE}
Override the device code selection by using @var{VALUE}
as the device code.
The programmer is not queried for the list of supported
device codes, and the specified @var{VALUE}
is not verified but used directly within the
@code{T} command sent to the programmer.
@var{VALUE} can be specified using the conventional number notation of the
C programming language.
@item @samp{no_blockmode}
Disables the default checking for block transfer capability.
Use 
@samp{no_blockmode} only if your @samp{AVR910} 
programmer creates errors during initial sequence.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Arduino
@item Arduino

The Arduino programmer type accepts the following extended parameter:
@table @code
@item @samp{attemps=VALUE}
Overide the default number of connection retry attempt by using @var{VALUE}.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Urclock
@item Urclock

The urclock programmer type accepts the following extended parameters:
@table @code
@item @samp{showall}
Show all info for the connected part, then exit. The @code{-xshow...} options
below can be used to assemble a bespoke response consisting of a subset
(or only one item) of all available relevant information about the
connected part and bootloader.
@item @samp{showid}
Show a unique Urclock ID stored in either flash or EEPROM of the MCU, then exit.
@item @samp{id=<E|F>.<addr>.<len>}
Historically, the Urclock ID was a six-byte unique little-endian number
stored in Urclock boards at EEPROM address 257. The location of this
number can be set by the @code{-xid=<E|F>.<addr>.<len>} extended parameter. @code{E}
stands for EEPROM and @code{F} stands for flash. A negative address addr counts
from the end of EEPROM and flash, respectively. The length len of the
Urclock ID can be between 1 and 8 bytes.
@item @samp{showdate}
Show the last-modified date of the input file for the flash application,
then exit. If the input file was stdin, the date will be that of the
programming. Date and filename are part of the metadata that the urclock
programmer stores by default in high flash just under the bootloader; see also
@code{-xnometadata}.
@item @samp{showfilename}
Show the input filename (or title) of the last flash writing session, then exit.
@item @samp{title=<string>}
When set, <string> will be used in lieu of the input filename. The maximum
string length for the title/filename field is 254 bytes including
terminating nul.
@item @samp{showapp}
Show the size of the programmed application, then exit.
@item @samp{showstore}
Show the size of the unused flash between the application and metadata, then exit.
@item @samp{showmeta}
Show the size of the metadata just below the bootloader, then exit.
@item @samp{showboot}
Show the size of the bootloader, then exit.
@item @samp{showversion}
Show bootloader version and capabilities, then exit.
@item @samp{showvector}
Show the vector number and name of the interrupt table vector used by the
bootloader for starting the application, then exit. For hardware-supported
bootloaders this will be vector 0 (Reset), and for vector bootloaders this
will be any other vector number of the interrupt vector table or the slot
just behind the vector table with the name @code{VBL_ADDITIONAL_VECTOR}.
@item @samp{showpart}
Show the part for which the bootloader was compiled, then exit.
@item @samp{bootsize=<size>}
Manual override for bootloader size. Urboot bootloaders put the number of
used bootloader pages into a table at the top of the bootloader section,
ie, typically top of flash, so the urclock programmer can look up the
bootloader size itself. In backward-compatibility mode, when programming
via other bootloaders, this option can be used to tell the programmer the
size, and therefore the location, of the bootloader.
@item @samp{vectornum=<arg>}
Manual override for vector number. Urboot bootloaders put the vector
number used by a vector bootloader into a table at the top of flash, so
this option is normally not needed for urboot bootloaders. However, it is
useful in backward-compatibility mode (or when the urboot bootloader does
not offer flash read). Specifying a vector number in these circumstances
implies a vector bootloader whilst the default assumption would be a
hardware-supported bootloader.
@item @samp{eepromrw}
Manual override for asserting EEPROM read/write capability. Not normally
needed for urboot bootloaders, but useful for in backward-compatibility
mode if the bootloader offers EEPROM read/write.
@item @samp{emulate_ce}
If an urboot bootloader does not offer a chip erase command it will tell
the urclock programmer so during handshake. In this case the urclock
programmer emulates a chip erase, if warranted by user command line
options, by filling the remainder of unused flash below the bootloader
with 0xff. If this option is specified, the urclock programmer will assume
that the bootloader cannot erase the chip itself. The option is useful
for backwards-compatible bootloaders that do not implement chip erase.
@item @samp{restore}
Upload unchanged flash input files and trim below the bootloader if
needed. This is most useful when one has a backup of the full flash and
wants to play that back onto the device. No metadata are written in this
case and no vector patching happens either if it is a vector bootloader.
However, for vector bootloaders, even under the option @code{-xrestore} an
input file will not be uploaded for which the reset vector does not point
to the vector bootloader. This is to avoid writing an input file to the
device that would render the vector bootloader not functional as it would
not be reached after reset.
@item @samp{initstore}
On writing to flash fill the store space between the flash application and
the metadata section with 0xff.
@item @samp{nofilename}
On writing to flash do not store the application input filename (nor a title).
@item @samp{nodate}
On writing to flash do not store the application input filename (nor a
title) and no date either.
@item @samp{nometadata}
On writing to flash do not store any metadata. The full flash below the
bootloader is available for the application. In particular, no data store
frame is programmed.
@item @samp{delay=<n>}
Add a <n> ms delay after reset. This can be useful if a board takes a
particularly long time to exit from external reset. <n> can be negative,
in which case the default 120 ms delay after issuing reset will be
shortened accordingly.
@item @samp{strict}
Urclock has a faster, but slightly different strategy than -c arduino to
synchronise with the bootloader; some stk500v1 bootloaders cannot cope
with this, and they need the @code{-xstrict} option.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Buspirate
@item BusPirate

The BusPirate programmer type accepts the following extended parameters:
@table @code
@item @samp{reset=cs,aux,aux2}
The default setup assumes the BusPirate's CS output pin connected to
the RESET pin on AVR side. It is however possible to have multiple AVRs
connected to the same BP with SDI, SDO and SCK lines common for all of them.
In such a case one AVR should have its RESET connected to BusPirate's
@emph{CS}
pin, second AVR's RESET connected to BusPirate's
@emph{AUX}
pin and if your BusPirate has an
@emph{AUX2}
pin (only available on BusPirate version v1a with firmware 3.0 or newer)
use that to activate RESET on the third AVR.

It may be a good idea to decouple the BusPirate and the AVR's SPI buses from
each other using a 3-state bus buffer. For example 74HC125 or 74HC244 are some
good candidates with the latches driven by the appropriate reset pin (cs,
aux or aux2). Otherwise the SPI traffic in one active circuit may interfere
with programming the AVR in the other design.

@item @samp{spifreq=@var{0..7}}
@multitable @columnfractions .05 .3
@item @code{0} @tab  30 kHz (default)
@item @code{1} @tab 125 kHz
@item @code{2} @tab 250 kHz
@item @code{3} @tab   1 MHz
@item @code{4} @tab   2 MHz
@item @code{5} @tab   2.6 MHz
@item @code{6} @tab   4 MHz
@item @code{7} @tab   8 MHz
@end multitable

@item @samp{rawfreq=0..3}
Sets the SPI speed and uses the Bus Pirate's binary ``raw-wire'' mode instead
of the default binary SPI mode:

@multitable @columnfractions .05 .3
@item @code{0} @tab 5 kHz
@item @code{1} @tab 50 kHz
@item @code{2} @tab 100 kHz (Firmware v4.2+ only)
@item @code{3} @tab 400 kHz (v4.2+)
@end multitable

The only advantage of the ``raw-wire'' mode is that different SPI frequencies
are available. Paged writing is not implemented in this mode.

@item @samp{ascii}
Attempt to use ASCII mode even when the firmware supports BinMode (binary
mode).
BinMode is supported in firmware 2.7 and newer, older FW's either don't
have BinMode or their BinMode is buggy. ASCII mode is slower and makes
the above
@samp{reset=}, @samp{spifreq=}
and
@samp{rawfreq=}
parameters unavailable. Be aware that ASCII mode is not guaranteed to work
with newer firmware versions, and is retained only to maintain compatibility
with older firmware versions.

@item @samp{nopagedwrite}
Firmware versions 5.10 and newer support a binary mode SPI command that enables
whole pages to be written to AVR flash memory at once, resulting in a
significant write speed increase. If use of this mode is not desirable for some
reason, this option disables it.

@item @samp{nopagedread}
Newer firmware versions support in binary mode SPI command some AVR Extended 
Commands. Using the ``Bulk Memory Read from Flash'' results in a
significant read speed increase. If use of this mode is not desirable for some
reason, this option disables it.

@item @samp{cpufreq=@var{125..4000}}
This sets the @emph{AUX}  pin to output a frequency of @var{n} kHz. Connecting
the @emph{AUX} pin to the XTAL1 pin of your MCU, you can provide it a clock, 
for example when it needs an external clock because of wrong fuses settings.
Make sure the CPU frequency is at least four times the SPI frequency.  

@item @samp{serial_recv_timeout=@var{1...}}
This sets the serial receive timeout to the given value. 
The timeout happens every time avrdude waits for the BusPirate prompt. 
Especially in ascii mode this happens very often, so setting a smaller value 
can speed up programming a lot. 
The default value is 100ms. Using 10ms might work in most cases.  

@item @samp{help}
Show help menu and exit.

@end table

@cindex @code{-x} Micronucleus bootloader
@item Micronucleus bootloader

The Micronucleus programmer type accepts the following extended parameter:
@table @code
@item @samp{wait=@var{timeout}}
If the device is not connected, wait for the device to be plugged in.
The optional @var{timeout} specifies the connection time-out in seconds.
If no time-out is specified, AVRDUDE will wait indefinitely until the
device is plugged in.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Teensy bootloader
@item Teensy bootloader

The Teensy programmer type accepts the following extended parameter:
@table @code
@item @samp{wait=@var{timeout}}
If the device is not connected, wait for the device to be plugged in.
The optional @var{timeout} specifies the connection time-out in seconds.
If no time-out is specified, AVRDUDE will wait indefinitely until the
device is plugged in.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} Wiring
@item Wiring

The Wiring programmer type accepts the following extended parameter:
@table @code
@item @samp{snooze=@var{0..32767}}
After performing the port open phase, AVRDUDE will wait/snooze for
@var{snooze} milliseconds before continuing to the protocol sync phase.
No toggling of DTR/RTS is performed if @var{snooze} > 0.
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} PICkit2
@item PICkit2
Connection to the PICkit2 programmer:
@multitable @columnfractions .05 .3
@item @code{(AVR)} @tab      @code{(PICkit2)}
@item @code{RST} @tab      @code{VPP/MCLR (1) }
@item @code{VDD} @tab      @code{VDD Target (2) -- possibly optional if AVR self powered }
@item @code{GND} @tab      @code{GND (3) }
@item @code{SDI} @tab      @code{PGD (4) }
@item @code{SCLK} @tab      @code{PDC (5) }
@item @code{OSI} @tab      @code{AUX (6) }
@end multitable

The PICkit2 programmer type accepts the following extended parameters:
@table @code
@item @samp{clockrate=@var{rate}}
Sets the SPI clocking rate in Hz (default is 100kHz). Alternately the -B or -i options can be used to set the period.
@item @samp{timeout=@var{usb-transaction-timeout}}
Sets the timeout for USB reads and writes in milliseconds (default is 1500 ms).
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} USBasp
@item USBasp

The USBasp programmer type accepts the following extended parameter:
@table @code
@item @samp{section_config}
Programmer will erase
configuration section with option '-e' (chip erase),
rather than entire chip.
Only applicable to TPI devices (ATtiny 4/5/9/10/20/40).
@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} xbee
@item xbee

The xbee programmer type accepts the following extended parameter:
@table @code
@item @samp{xbeeresetpin=@var{1..7}}
Select the XBee pin @code{DIO<1..7>} that is connected to the MCU's
/RESET line.  The programmer needs to know which DIO pin to use to
reset into the bootloader.  The default (3) is the @code{DIO3} pin
(XBee pin 17), but some commercial products use a different XBee
pin.

The remaining two necessary XBee-to-MCU connections are not selectable
- the XBee @code{DOUT} pin (pin 2) must be connected to the MCU's
RXD line, and the XBee @code{DIN} pin (pin 3) must be connected to
the MCU's TXD line.

@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} serialupdi
@item serialupdi

The serialupdi programmer type accepts the following extended parameter:
@table @code
@item @samp{rtsdtr=low,high}
Forces RTS/DTR lines to assume low or high state during the whole
programming session. Some programmers might use this signal to
indicate UPDI programming state, but this is strictly hardware
specific.

When not provided, driver/OS default value will be used.

@item @samp{help}
Show help menu and exit.
@end table

@cindex @code{-x} linuxspi
@item linuxspi

The linuxspi programmer type accepts the following extended parameter:
@table @code
@item @samp{disable_no_cs}
Ensures the programmer does not use the SPI_NO_CS bit for the SPI
driver. This parameter is useful for kernels that do not support
the CS line being managed outside the application.
@item @samp{help}
Show help menu and exit.
@end table

@end table

@page
@c
@c Node
@c
@node Example Command Line Invocations,  , Programmers accepting extended parameters, Command Line Options
@section Example Command Line Invocations

@noindent
Download the file @code{diag.hex} to the ATmega128 chip using the
STK500 programmer connected to the default serial port:

@smallexample
@cartouche
% avrdude -p m128 -c stk500 -e -U flash:w:diag.hex 

avrdude: AVR device initialized and ready to accept instructions
avrdude: device signature = 0x1e9702 (probably m128)
avrdude: erasing chip
avrdude: reading input file diag.hex for flash
         with 19278 bytes in 74 section within [0, 0x4b4e]
avrdude: writing 19278 bytes flash ...
Writing | ################################################## | 100% 7.60 s
avrdude: 19278 bytes of flash written
avrdude: verifying flash memory against diag.hex
Reading | ################################################## | 100% 6.83 s
avrdude: 19278 bytes of flash verified

avrdude done.  Thank you.

@end cartouche
@end smallexample

@page
@noindent
Upload the flash memory from the ATmega128 connected to the STK500
programmer and save it in raw binary format in the file named
@code{c:/diag flash.bin}:

@smallexample
@cartouche
% avrdude -p m128 -c stk500 -U flash:r:"c:/diag flash.bin":r 

avrdude: AVR device initialized and ready to accept instructions
avrdude: device signature = 0x1e9702 (probably m128)
avrdude: reading flash memory ...
Reading | ################################################## | 100% 46.10s
avrdude: writing output file c:/diag flash.bin

avrdude done.  Thank you.

@end cartouche
@end smallexample

@page
@noindent
Using the default programmer, download the file @code{diag.hex} to
flash, @code{eeprom.hex} to EEPROM, and set the extended, high, and low
fuse bytes to 0xff, 0x89, and 0x2e respectively:

@smallexample
@cartouche

% avrdude -p m128 -U flash:w:diag.hex    \
>                 -U eeprom:w:eeprom.hex \
>                 -U efuse:w:0xff:m      \
>                 -U hfuse:w:0x89:m      \
>                 -U lfuse:w:0x2e:m

avrdude: AVR device initialized and ready to accept instructions
avrdude: device signature = 0x1e9702 (probably m128)
avrdude: Note: flash memory has been specified, an erase cycle will be performed.
         To disable this feature, specify the -D option.
avrdude: erasing chip
avrdude: reading input file diag.hex for flash
         with 19278 bytes in 74 section within [0, 0x4b4e]
avrdude: writing 19278 bytes flash ...
Writing | ################################################## | 100% 7.60 s
avrdude: 19278 bytes of flash written
avrdude: verifying flash memory against diag.hex
Reading | ################################################## | 100% 6.83 s
avrdude: 19278 bytes of flash verified

[ ... other memory status output skipped for brevity ... ]

avrdude done.  Thank you.

@end cartouche
@end smallexample

@page
@noindent
Connect to the JTAG ICE mkII which serial number ends up in 1C37 via
USB, and enter terminal mode:

@smallexample
@cartouche

% avrdude -c jtag2 -p m649 -P usb:1c:37 -t

avrdude: AVR device initialized and ready to accept instructions
avrdude: Device signature = 0x1e9603

[ ... terminal mode output skipped for brevity ... ]

avrdude done.  Thank you.

@end cartouche
@end smallexample

@noindent
List the serial numbers of all JTAG ICEs attached to USB.  This is
done by specifying an invalid serial number, and increasing the
verbosity level.

@smallexample
@cartouche

% avrdude -c jtag2 -p m128 -P usb:xx -v
[...]
         Using Port            : usb:xxx
         Using Programmer      : jtag2
avrdude: usbdev_open(): Found JTAG ICE, serno: 00A000001C6B
avrdude: usbdev_open(): Found JTAG ICE, serno: 00A000001C3A
avrdude: usbdev_open(): Found JTAG ICE, serno: 00A000001C30
avrdude: usbdev_open(): did not find any (matching) USB device "usb:xxx"

@end cartouche
@end smallexample


@c
@c Node
@c
@node Terminal Mode Operation, Configuration File, Command Line Options, Top
@chapter Terminal Mode Operation

AVRDUDE has an interactive mode called @var{terminal mode} that is
enabled by the @option{-t} option.  This mode allows one to enter
interactive commands to display and modify the various device memories,
perform a chip erase, display the device signature bytes and part
parameters, and to send raw programming commands.  Commands and
parameters may be abbreviated to their shortest unambiguous form.
Terminal mode also supports a command history so that previously entered
commands can be recalled and edited.

@menu
* Terminal Mode Commands::      
* Terminal Mode Examples::      
@end menu

@node Terminal Mode Commands, Terminal Mode Examples, Terminal Mode Operation, Terminal Mode Operation
@cindex Terminal Mode
@section Terminal Mode Commands

In this mode, AVRDUDE only initializes communication with the MCU, and then
awaits user commands on standard input.  Commands and parameters may be
abbreviated to the shortest unambiguous form.  Terminal mode provides a
command history using readline(3), so previously entered command lines can be
recalled and edited.

The @var{addr} and @var{len} parameters of the read, write, and erase
commands can be negative with the same syntax as substring computations in
perl or python. The table below details their meaning with respect to an
example memory of size @code{sz=0x800}.

@multitable {0/negativ}{negativ}{@code{[addr, addr+len-1]}}{End is @code{|len|} bytes below memory size @code{sz}}
@headitem @code{addr}
@tab @code{len}
@tab Memory interval
@tab Comment

@item 0/positive
@tab  positive
@tab  @code{[addr, addr+len-1]}
@tab  Note: @code{len = end-start + 1}

@item 0/positive
@tab  negative
@tab  @code{[addr, sz+len]}
@tab  End is @code{|len|} bytes below memory size @code{sz}

@item negative
@tab  positive
@tab  @code{[sz+addr, @dots{}]}
@tab  Start is @code{|addr|} bytes below memory size

@item negative
@tab  negative
@tab  @code{[sz+addr, sz+len]}
@tab  Combining above two cases

@item any
@tab  zero
@tab  empty set
@tab  No action

@item @verb{|0x700|}
@tab  @verb{|   12|}
@tab @code{[0x700, 0x70b]}
@tab Conventional use

@item @verb{| 1024|}
@tab  @verb{| -257|}
@tab @code{[0x400, 0x6ff]}
@tab Size of memory is @code{2048} or @code{0x800}

@item @verb{| -512|}
@tab  @verb{|  512|}
@tab @code{[0x600, 0x7ff]}
@tab Last 512 bytes

@item @verb{| -256|}
@tab  @verb{|   -1|}
@tab @code{[0x700, 0x7ff]}
@tab Last 256 bytes

@item @verb{|    0|}
@tab  @verb{|   49|}
@tab @code{[0, 48]}
@tab First 49 bytes

@item @verb{|    0|}
@tab  @verb{|  -49|}
@tab @code{[0, 1999]}
@tab All but the last @code{48 = |len+1|} bytes

@item @verb{|    0|}
@tab  @verb{|   -1|}
@tab @code{[0, 0x7ff]}
@tab All memory without knowing its size

@end multitable

@noindent
The following commands are implemented for all programmers:

@table @code

@item dump @var{memtype} @var{addr} @var{len}
Read from the specified memory interval (see above), and display in the usual hexadecimal and
ASCII form.

@item dump @var{memtype} @var{addr}
Read from memory addr as many bytes as the most recent dump memory addr len command with this
very memory had specified (default 256 bytes), and display them.

@item dump @var{memtype}
Continue dumping from the memory and location where the most recent dump command left off; if no
previous dump command has addressed a memory an error message will be shown.

@item dump @var{memtype} @var{addr} @dots{}
Start reading from @var{addr}, all the way to the last memory address (deprecated: use @code{dump @var{memtype} @var{addr} -1}).

@item dump @var{memtype} @dots{}
Read all bytes from the specified memory, and display them (deprecated: use @code{dump @var{memtype} 0 -1}).

@item read
Can be used as an alias for dump.

@item write @var{memtype} @var{addr} @var{data[,]} @{@var{data[,]}@}
Manually program the respective memory cells, starting at address
@var{addr}, using the data items provided. The terminal implements
reading from and writing to flash and EEPROM type memories normally
through a cache and paged access functions. All other memories are
directly written to without use of a cache. Some older parts without paged
access will also have flash and EEPROM directly accessed without cache.

Items @var{data} can have the following formats:

@multitable @columnfractions .3 .4 .3
@item @strong{Type}
@tab @strong{Example}
@tab @strong{Size (bytes)}

@item String
@tab @code{"Hello, world\n"}
@tab varying

@item Character
@tab @code{'A'}
@tab 1

@item Decimal integer
@tab 12345
@tab 1, 2, 4, or 8

@item Octal integer
@tab 012345
@tab 1, 2, 4, or 8

@item Hexadecimal integer
@tab 0x12345
@tab 1, 2, 4, or 8

@item Float
@tab 3.1415926
@tab 4

@item Double
@tab 3.141592653589793D
@tab 8

@end multitable

@var{data}
can be hexadecimal, octal or decimal integers, floating point numbers
or C-style strings and characters. For integers, an optional case-insensitive
suffix specifies the data size as in the table below:
@table @code
@item LL
8 bytes / 64 bits
@item L
4 bytes / 32 bits
@item H or S
2 bytes / 16 bits
@item HH
1 byte / 8 bits
@end table

Suffix @code{D} indicates a 64-bit double, @code{F} a 32-bit float, whilst a
floating point number without suffix defaults to 32-bit float. Hexadecimal
floating point notation is supported. An ambiguous trailing suffix, e.g.,
@code{0x1.8D}, is read as no-suffix float where @code{D} is part of the
mantissa; use a zero exponent @code{0x1.8p0D} to clarify.

An optional @code{U} suffix makes integers unsigned. Ordinary @code{0x} hex
integers are always treated as unsigned. @code{+0x} or @code{-0x} hex
numbers are treated as signed unless they have a @code{U} suffix. Unsigned
integers cannot be larger than 2^64-1. If @var{n} is an unsigned integer then @var{-n}
is also a valid unsigned integer as in C. Signed integers must fall into
the [-2^63, 2^63-1] range or a correspondingly smaller range when a suffix
specifies a smaller type.

Ordinary @code{0x} hex integers with @var{n} hex digits (counting leading
zeros) use the smallest size of one, two, four and eight bytes that can
accommodate any n-digit hex integer. If an integer suffix specifies a size
explicitly the corresponding number of least significant bytes are
written, and a warning shown if the number does not fit into the desired
representation. Otherwise, unsigned integers occupy the smallest of one,
two, four or eight bytes needed. Signed numbers are allowed to fit into
the smallest signed or smallest unsigned representation: For example,
@code{255} is stored as one byte as @code{255U} would fit in one byte,
though as a signed number it would not fit into a one-byte interval [-128,
127]. The number @code{-1} is stored in one byte whilst @code{-1U} needs
eight bytes as it is the same as @code{0xFFFFffffFFFFffffU}.

One trailing comma at the end of data items is ignored to facilitate copy
and paste of lists.

@item write @var{memtype} @var{addr} @var{data}
The start address @code{addr} may be omitted if the size of the memory
being written to is 1 byte in size.

@item write @var{memtype} @var{addr} @var{len} @var{data[,]} @{@var{data[,]}@} @dots{}
The ellipsis @dots{} form writes the data to the entire memory intervall
addressed by @var{addr len} and, if necessary, pads the remaining space by
repeating the last data item. The fill write command does not write beyond
the specified memory area even if more data than needed were given.

@item erase
Perform a chip erase and discard all pending writes to EEPROM and flash.
Note that EEPROM will be preserved if the EESAVE fuse bit is set.

@item erase memory
Erase the entire specified memory.

@item erase memory addr len
Erase a section of the specified memory.

@item flush
Synchronise with the device all pending cached writes to EEPROM or flash.
With some programmer and part combinations, flash (and sometimes EEPROM,
too) looks like a NOR memory, ie, one can only write 0 bits, not 1 bits.
When this is detected, either page erase is deployed (e.g., with parts that
have PDI/UPDI interfaces), or if that is not available, both EEPROM and
flash caches are fully read in, a chip erase command is issued and both
EEPROM and flash are written back to the device. Hence, it can take
minutes to ensure that a single previously cleared bit is set and,
therefore, this command should be used sparingly.

@item abort
Normally, caches are only ever actually written to the device when using
@code{flush}, at the end of the terminal session after typing @code{quit},
or after EOF on input is encountered. The @code{abort} command resets the
cache discarding all previous writes to the flash and EEPROM cache.

@item sig
Display the device signature bytes.

@item part
Display the current part settings and parameters.  Includes chip
specific information including all memory types supported by the
device, read/write timing, etc.

@item verbose [@var{level}]
Change (when @var{level} is provided), or display the verbosity
level.
The initial verbosity level is controlled by the number of @code{-v} options
given on the command line.

@item quell [@var{level}]
Change (when @var{level} is provided), or display the quell
level. 1 is used to suppress progress reports. 2 or higher yields
progressively quieter operations. The initial quell level is controlled
by the number of @code{-q} options given on the command line.

@item ?
@itemx help
Give a short on-line summary of the available commands.

@item quit
Leave terminal mode and thus AVRDUDE.

@item q
Can be used as an alias for @code{quit}.

@end table

@noindent
In addition, the following commands are supported on some programmers:

@table @code

@item pgerase @var{memory} @var{addr}
Erase one page of the memory specified.

@item send @var{b1} @var{b2} @var{b3} @var{b4}
Send raw instruction codes to the AVR device. If you need access to a
feature of an AVR part that is not directly supported by AVRDUDE, this
command allows you to use it, even though AVRDUDE does not implement the
command. When using direct SPI mode, up to 3 bytes
can be omitted.

@item spi
Enter direct SPI mode.  The @emph{pgmled} pin acts as chip select.
@emph{Only supported on parallel bitbang programmers, and partially by USBtiny.}
Chip Select must be externally held low for direct SPI when
using USBtinyISP, and send must be a multiple of four bytes.

@item pgm
Return to programming mode (from direct SPI mode).

@item vtarg @var{voltage}
Set the target's supply voltage to @var{voltage} Volts.

@item varef [@var{channel}] @var{voltage}
Set the adjustable voltage source to @var{voltage} Volts.
This voltage is normally used to drive the target's
@emph{Aref} input on the STK500 and STK600.
The STK600 offers two reference voltages, which can be
selected by the optional parameter @var{channel} (either
0 or 1).

@item fosc @var{freq}[@code{M}|@code{k}]
Set the programming oscillator to @var{freq} Hz.
An optional trailing letter @code{M}
multiplies by 1E6, a trailing letter @code{k} by 1E3.

@item fosc off
Turn the programming oscillator off.

@item sck @var{period}
Set the SCK clock period to @var{period} microseconds.
Note that some official Microchip programmers store the bitclock setting and
will continue to use it until a diferent value is provided. See
@code{-B bitclock} for more information.

@item parms
Display programmer specific parameters.

@end table

@c
@c Node
@c
@node Terminal Mode Examples,  , Terminal Mode Commands, Terminal Mode Operation
@cindex Terminal Mode
@section Terminal Mode Examples

@noindent
Display part parameters, modify eeprom cells, perform a chip erase:

@smallexample
@cartouche
% avrdude -c usbasp -p atmega328p -t

avrdude: AVR device initialized and ready to accept instructions
avrdude: device signature = 0x1e950f (probably m328p)

avrdude> part
AVR Part                      : ATmega328P
Chip Erase delay              : 9000 us
PAGEL                         : PD7
BS2                           : PC2
RESET disposition             : possible i/o
RETRY pulse                   : SCK
Serial program mode           : yes
Parallel program mode         : yes
Timeout                       : 200
StabDelay                     : 100
CmdexeDelay                   : 25
SyncLoops                     : 32
PollIndex                     : 3
PollValue                     : 0x53
Memory Detail                 :

                                  Block Poll               Page                       Polled
  Memory Type Alias    Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack
  ----------- -------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------
  eeprom                 65    20     4    0 no       1024    4      0  3600  3600 0x00 0x00
  flash                  65    10   128    0 yes     32768  128    256  4500  4500 0x00 0x00
  lfuse                   0     0     0    0 no          1    1      0  4500  4500 0x00 0x00
  hfuse                   0     0     0    0 no          1    1      0  4500  4500 0x00 0x00
  efuse                   0     0     0    0 no          1    1      0  4500  4500 0x00 0x00
  lock                    0     0     0    0 no          1    1      0  4500  4500 0x00 0x00
  signature               0     0     0    0 no          3    1      0     0     0 0x00 0x00
  calibration             0     0     0    0 no          1    1      0     0     0 0x00 0x00

avrdude> dump eeprom 0 16
Reading | ################################################## | 100% 0.01 s
0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> write eeprom 0 1 2 3 4 0xcafe "Avrdude"
Caching | ################################################## | 100% 0.00 s

avrdude> dump eeprom 0 16
Reading | ################################################## | 100% 0.00 s
0000  01 02 03 04 fe ca 41 76  72 64 75 64 65 00 ff ff  |......Avrdude...|

avrdude> flush
avrdude: synching cache to device ...
Writing | ################################################## | 100% 0.36 s

avrdude> erase
erasing chip ...

avrdude> dump eeprom 0 16
Reading | ################################################## | 100% 0.00 s
0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> quit

avrdude done.  Thank you.

@end cartouche
@end smallexample


@noindent
Program the fuse bits of an ATmega328P (enable high speed external crystal,
enable brown-out detection). First display the factory defaults, then reprogram:

@smallexample
@cartouche
% avrdude -c usbasp -p atmega328p -t

avrdude: AVR device initialized and ready to accept instructions
avrdude: device signature = 0x1e950f (probably m328p)

avrdude> dump efuse
Reading | ################################################## | 100% 0.00 s
0000  ff                                                |.               |

avrdude> dump hfuse
Reading | ################################################## | 100% 0.00 s
0000  d9                                                |.               |

avrdude> dump lfuse
Reading | ################################################## | 100% 0.00 s
0000  62                                                |b               |

avrdude> write efuse 0xfd
Writing | ################################################## | 100% 0.01 s

avrdude> write hfuse 0xde
Writing | ################################################## | 100% 0.01 s

avrdude> write lfuse 0xf7
Writing | ################################################## | 100% 0.01 s

avrdude> quit

avrdude done.  Thank you.

@end cartouche
@end smallexample

The following example demonstrates negative address and length bytes, and the
second form of the @code{write} command where the last data value provided
is used to fill up the indicated memory range.

@smallexample
@cartouche
% avrdude -c usbasp -p atmega328p -t

avrdude: AVR device initialized and ready to accept instructions
avrdude: device signature = 0x1e950f (probably m328p)

avrdude> dump flash -64 -33
Reading | ################################################## | 100% 0.02 s
7fc0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
7fd0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> dump flash -32 -1
Reading | ################################################## | 100% 0.00 s
7fe0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
7ff0  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|

avrdude> write flash -64 1234567890 'A' 'V' 'R' 2.718282 0xaa 0xbb 0xcc "Hello World!"
Caching | ################################################## | 100% 0.00 s

avrdude> write flash -32 -1 0x01 0x02 0x03 0x04 0x05 ...
Caching | ################################################## | 100% 0.00 s

avrdude> read flash -64 -33
Reading | ################################################## | 100% 0.00 s
7fc0  d2 02 96 49 41 56 52 55  f8 2d 40 aa bb cc 48 65  |...IAVRU.-@@...He|
7fd0  6c 6c 6f 20 57 6f 72 6c  64 21 00 ff ff ff ff ff  |llo World!......|

avrdude> read flash -32 -1
Reading | ################################################## | 100% 0.00 s
7fe0  01 02 03 04 05 05 05 05  05 05 05 05 05 05 05 05  |................|
7ff0  05 05 05 05 05 05 05 05  05 05 05 05 05 05 05 05  |................|

avrdude> flush
avrdude: synching cache to device ...
Writing | ################################################## | 100% 0.05 s

avrdude> quit

avrdude done.  Thank you.

@end cartouche
@end smallexample

@c
@c Node
@c
@node Configuration File, Programmer Specific Information, Terminal Mode Operation, Top
@cindex Configuration File
@cindex @code{avrdude.conf}
@chapter Configuration File

@noindent
AVRDUDE reads a configuration file upon startup which describes all of
the parts and programmers that it knows about.  The advantage of this is
that if you have a chip that is not currently supported by AVRDUDE, you
can add it to the configuration file without waiting for a new release
of AVRDUDE. Likewise, if you have a parallel port programmer that is
not supported, chances are that you can copy an
existing programmer definition and, with only a few changes, make your
programmer work.

AVRDUDE first looks for a system wide configuration file in a platform
dependent location.  On Unix, this is usually
@code{/usr/local/etc/avrdude.conf}, whilst on Windows it is usually in the
same location as the executable file.  The full name of this file can be
specified using the @option{-C} command line option.  After parsing the system wide
configuration file, AVRDUDE looks for a per-user configuration
file to augment or override the system wide defaults.  On Unix, the
per-user file is @code{$@{XDG_CONFIG_HOME@}/avrdude/avrdude.rc}, whereas
if @code{$@{XDG_CONFIG_HOME@}} is either not set or empty,
@code{$@{HOME@}/.config/} is used instead. If that does not exists
@code{.avrduderc} within the user's home directory is used. On Windows,
this file is the @code{avrdude.rc} file located in the same directory as
the executable.

@menu
* AVRDUDE Defaults::            
* Programmer Definitions::      
* Part Definitions::            
* Other Notes::                 
@end menu

@c
@c Node
@c
@node AVRDUDE Defaults, Programmer Definitions, Configuration File, Configuration File
@section AVRDUDE Defaults

@table @code

@item default_parallel = "@var{default-parallel-device}";
Assign the default parallel port device.  Can be overridden using the
@option{-P} option.

@item default_serial = "@var{default-serial-device}";
Assign the default serial port device.  Can be overridden using the
@option{-P} option.

@item default_linuxgpio = "@var{default-linuxgpio-device}";
Assign the default gpiochip for linuxgpio's libgpiod mode,
e.g. "gpiochip0".  Ignored for linuxgpio's sysfs mode.  Can be overridden
using the @option{-P} option.

@item default_programmer = "@var{default-programmer-id}";
Assign the default programmer id.  Can be overridden using the @option{-c}
option.

@item default_bitclock = "@var{default-bitclock}";
Assign the default bitclock value.  Can be overridden using the @option{-B}
option.

@end table


@c
@c Node
@c
@node Programmer Definitions, Part Definitions, AVRDUDE Defaults, Configuration File
@section Programmer Definitions

@noindent
The format of the programmer definition is as follows:

@smallexample
programmer
    parent <id>                               # optional parent
    id       = <id1> [, <id2> ... ] ;         # <idN> are quoted strings
    desc     = <description> ;                # quoted string
    type     = <type>;                        # programmer type, quoted string
                                              # supported types can be listed by "-c ?type"
    prog_modes = PM_<i/f> @{ | PM_<i/f> @}      # interfaces, e.g., PM_SPM|PM_PDI
    connection_type = parallel | serial | usb | spi
    baudrate = <num> ;                        # baudrate for avr910-programmer
    vcc      = <pin1> [, <pin2> ... ] ;       # pin number(s)
    buff     = <pin1> [, <pin2> ... ] ;       # pin number(s)
    reset    = <pin> ;                        # pin number
    sck      = <pin> ;                        # pin number
    sdo      = <pin> ;                        # pin number
    sdi      = <pin> ;                        # pin number
    errled   = <pin> ;                        # pin number
    rdyled   = <pin> ;                        # pin number
    pgmled   = <pin> ;                        # pin number
    vfyled   = <pin> ;                        # pin number
    usbvid   = <hexnum> ;                     # USB VID (Vendor ID)
    usbpid   = <hexnum> [, <hexnum> ...] ;    # USB PID (Product ID)
    usbdev   = <interface> ;                  # USB interface or other device info
    usbvendor = <vendorname> ;                # USB Vendor Name
    usbproduct = <productname> ;              # USB Product Name
    usbsn    = <serialno> ;                   # USB Serial Number
    hvupdi_support = <num> [, <num>, ... ] ;  # UPDI HV Variants Support
;
@end smallexample

@noindent
If a parent is specified, all settings of it (except its ids) are used for the new 
programmer. These values can be changed by new setting them for the new programmer.

@noindent
Known programming modes are
@itemize @bullet
@item @code{PM_SPM}: Bootloaders, self-programming with SPM opcodes or NVM Controllers
@item @code{PM_TPI}: Tiny Programming Interface (t4, t5, t9, t10, t20, t40, t102, t104)
@item @code{PM_ISP}: SPI programming for In-System Programming (almost all classic parts)
@item @code{PM_PDI}: Program and Debug Interface (xmega parts)
@item @code{PM_UPDI}: Unified Program and Debug Interface
@item @code{PM_HVSP}: High Voltage Serial Programming (some classic parts)
@item @code{PM_HVPP}: High Voltage Parallel Programming (most non-HVSP classic parts)
@item @code{PM_debugWIRE}: Simpler alternative to JTAG (a subset of HVPP/HVSP parts)
@item @code{PM_JTAG}: Joint Test Action Group standard (some classic parts)
@item @code{PM_JTAGmkI}: Subset of @code{PM_JTAG}, older parts, Atmel ICE mkI
@item @code{PM_XMEGAJTAG}: JTAG, some XMEGA parts
@item @code{PM_AVR32JTAG}: JTAG for 32-bit AVRs
@item @code{PM_aWire}: AVR32 parts
@end itemize

@noindent
To invert a bit in the pin definitions, use @code{= ~ <num>}. To invert a pin list
(all pins get inverted) use @code{~ ( <num1> [, <num2> ... ] )}.

@noindent
Not all programmer types can handle a list of USB PIDs.

@noindent
The following programmer types are currently implemented:

@multitable @columnfractions .25 .6
@include programmer_types.texi
@end multitable

@c
@c Node
@c
@node Part Definitions, Other Notes, Programmer Definitions, Configuration File
@section Part Definitions

@smallexample
part
    desc             = <description> ;        # quoted string, the long part name, eg, "ATmega328p"
    id               = <id> ;                 # quoted string, normally an abbreviated part name
    variants         = <str1> [, <str2> ...]; # quoted strings, each starts so "<alt-name>: ..."
    family_id        = <id> ;                 # quoted string, e.g., "megaAVR" or "tinyAVR"
    prog_modes       = PM_<i/f> @{| PM_<i/f>@}  # interfaces, e.g., PM_SPM|PM_ISP|PM_HVPP|PM_debugWIRE
    mcuid            = <num>;                 # unique id in 0..2039 for 8-bit AVRs
    n_interrupts     = <num>;                 # number of interrupts, used for vector bootloaders
    n_page_erase     = <num>;                 # if set, number of pages erased during SPM erase
    n_boot_sections  = <num>;                 # Number of boot sections
    boot_section_size = <num>;                # Size of (smallest) boot section, if any
    hvupdi_variant   = <num> ;                # numeric -1 (n/a) or 0..2
    devicecode       = <num> ;                # deprecated, use stk500_devcode
    stk500_devcode   = <num> ;                # numeric
    avr910_devcode   = <num> ;                # numeric
    has_jtag         = <yes/no> ;             # part has JTAG i/f (deprecated, use prog_modes)
    has_debugwire    = <yes/no> ;             # part has debugWire i/f (deprecated, use prog_modes)
    has_pdi          = <yes/no> ;             # part has PDI i/f (deprecated, use prog_modes)
    has_updi         = <yes/no> ;             # part has UPDI i/f (deprecated, use prog_modes)
    has_tpi          = <yes/no> ;             # part has TPI i/f (deprecated, use prog_modes)
    is_avr32         = <yes/no> ;             # AVR32 part (deprecated, use prog_modes)
    is_at90s1200     = <yes/no> ;             # AT90S1200 part
    signature        = <num> <num> <num> ;    # signature bytes
    usbpid           = <num> ;                # DFU USB PID
    chip_erase_delay = <num> ;                # microseconds
    reset            = dedicated | io ;
    retry_pulse      = reset | sck ;
    # STK500 parameters (parallel programming IO lines)
    pagel            = <num> ;                # page load pin name in hex, e.g., 0xD7
    bs2              = <num> ;                # byte select 2 pin name in hex, e.g., 0xA0
    serial           = <yes/no> ;             # can use serial downloading
    parallel         = <yes/no/pseudo> ;      # can use parallel programming
    # STK500v2 parameters, to be taken from Atmel's ATDF files
    timeout          = <num> ;
    stabdelay        = <num> ;
    cmdexedelay      = <num> ;
    synchloops       = <num> ;
    bytedelay        = <num> ;
    pollvalue        = <num> ;
    pollindex        = <num> ;
    predelay         = <num> ;
    postdelay        = <num> ;
    pollmethod       = <num> ;
    hvspcmdexedelay  = <num> ;
    # STK500v2 HV programming parameters, from ATDFs
    pp_controlstack  = <num>, <num>, ... ;    # PP only
    hvsp_controlstack = <num>, <num>, ... ;   # HVSP only
    flash_instr      = <num>, <num>, <num> ;
    eeprom_instr     = <num>, <num>, ... ;
    hventerstabdelay = <num> ;
    progmodedelay    = <num> ;                # PP only
    latchcycles      = <num> ;
    togglevtg        = <num> ;
    poweroffdelay    = <num> ;
    resetdelayms     = <num> ;
    resetdelayus     = <num> ;
    hvleavestabdelay = <num> ;
    resetdelay       = <num> ;
    synchcycles      = <num> ;                # HVSP only
    chiperasepulsewidth = <num> ;             # PP only
    chiperasepolltimeout = <num> ;
    chiperasetime    = <num> ;                # HVSP only
    programfusepulsewidth = <num> ;           # PP only
    programfusepolltimeout = <num> ;
    programlockpulsewidth = <num> ;           # PP only
    programlockpolltimeout = <num> ;
    # debugWIRE and/or JTAG ICE mkII parameters, also from ATDF files
    allowfullpagebitstream = <yes/no> ;
    enablepageprogramming = <yes/no> ;
    idr              = <num> ;                # IO addr of IDR (OCD) reg
    rampz            = <num> ;                # IO addr of RAMPZ reg
    spmcr            = <num> ;                # mem addr of SPMC[S]R reg
    eecr             = <num> ;                # mem addr of EECR reg
    eind             = <num> ;                # mem addr of EIND reg
    mcu_base         = <num> ;                # MCU control block in ATxmega devices
    nvm_base         = <num> ;                # NVM controller in ATxmega devices
    ocd_base         = <num> ;                # OCD module in AVR8X/UPDI devices
    ocdrev           = <num> ;                # JTAGICE3 parameter from ATDF files
    pgm_enable       = <instruction format> ;
    chip_erase       = <instruction format> ;
    # parameters for bootloaders
    autobaud_sync    = <num> ;                # autobaud detection byte, default 0x30

    memory <memtype>
        paged           = <yes/no> ;          # yes/no (flash only, do not use for EEPROM)
        offset          = <num> ;             # memory offset
        size            = <num> ;             # bytes
        page_size       = <num> ;             # bytes
        num_pages       = <num> ;             # numeric
        initval         = <num> ;             # factory setting of fuses and lockbits
        n_word_writes   = <num> ;             # TPI only: if set, number of words to write
        min_write_delay = <num> ;             # micro-seconds
        max_write_delay = <num> ;             # micro-seconds
        readback        = <num> <num> ;       # pair of byte values
        readback_p1     = <num> ;             # byte value (first component)
        readback_p2     = <num> ;             # byte value (second component)
        pwroff_after_write = <yes/no> ;       # yes/no
        mode            = <num> ;             # STK500 v2 file parameter from ATDF files
        delay           = <num> ;             #   "
        blocksize       = <num> ;             #   "
        readsize        = <num> ;             #   "
        read            = <instruction format> ;
        write           = <instruction format> ;
        read_lo         = <instruction format> ;
        read_hi         = <instruction format> ;
        write_lo        = <instruction format> ;
        write_hi        = <instruction format> ;
        loadpage_lo     = <instruction format> ;
        loadpage_hi     = <instruction format> ;
        writepage       = <instruction format> ;
    ;
;
@end smallexample

@noindent
If any of the above parameters are not specified, the default value of 0
is used for numerics (except for @code{mcuid}, @code{hvupdi_variant} and
@code{ocdrev}, where the default value is -1, and for @code{autobaud_sync}
which defaults to 0x30) or the empty string @code{""} for string values.
If a required parameter is left empty, AVRDUDE will complain. Almost all
occurrences of numbers (with the exception of pin numbers and where they
are separated by space, e.g., in signature and readback) can also be given
as simple expressions involving arithemtic and bitwise operators.

@menu
* Parent Part::
* Instruction Format::
@end menu

@c
@c Node
@c
@node Parent Part, Instruction Format, Part Definitions, Part Definitions
@subsection Parent Part

@noindent
Parts can also inherit parameters from previously defined parts using
the following syntax. In this case specified integer and  string values
override parameter values from the parent part. New  memory definitions
are added to the definitions inherited from the  parent. If, however, a
new memory definition refers to an existing one of the same name for
that part then, from v7.1, the existing memory definition is extended,
and components overwritten with new values. Assigning @code{NULL}
removes an inherited SPI instruction format, memory definition, control
stack, eeprom or flash instruction, e.g., as in @code{memory "efuse" =
NULL;}. The @code{variants} parameter is never inherited as it almost
always would be a mistake to do so: @code{variants} defines a string
list detailing variant names of the  part followed by an optional
colon, the package code and some absolute maximum ratings.

@noindent
Example format for part inheritance:

@smallexample
   part parent <id>                              # String identifying parent
       id               = <id> ;                 # Id string for new part
       <any set of other parameters from the list above>
     ;
@end smallexample

@c
@c Node
@c
@node Instruction Format,  , Parent Part, Part Definitions
@subsection Instruction Format

@noindent
Instruction formats are specified as a comma separated list of string
values containing information (bit specifiers) about each of the 32 bits
of the instruction.  Bit specifiers may be one of the following formats:

@table @code

@item 1
The bit is always set on input as well as output

@item 0
the bit is always clear on input as well as output

@item x
the bit is ignored on input and output

@item a
the bit is an address bit, the bit-number matches this bit specifier's
position within the current instruction byte

@item a@var{N}
the bit is the @var{N}th address bit, bit-number = N, i.e., @code{a12}
is address bit 12 on input, @code{a0} is address bit 0.

@item i
the bit is an input data bit

@item o
the bit is an output data bit

@end table

Each instruction must be composed of 32 bit specifiers.  The instruction
specification closely follows the instruction data provided in Atmel's
data sheets for their parts.  For example, the EEPROM read and write
instruction for an AT90S2313 AVR part could be encoded as:

@smallexample

read  = "1  0  1  0   0  0  0  0   x x x x  x x x x",
        "x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o";

write = "1  1  0  0   0  0  0  0   x x x x  x x x x",
        "x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i";

@end smallexample

As the address bit numbers in the SPI opcodes are highly systematic, they
don't really need to be specified. A compact version of the format
specification neither uses bit-numbers for address lines nor spaces. If such
a string is longer than 7 characters, then the characters @code{0}, @code{1},
@code{x}, @code{a}, @code{i} and @code{o} will be recognised as the
corresponding bit, whilst any of the characters @code{.}, @code{-}, @code{_}
or @code{/} can act as arbitrary visual separators, which are ignored.
Examples:

@smallexample

  loadpage_lo = "0100.0000--000x.xxxx--xxaa.aaaa--iiii.iiii";

  loadpage_lo = "0100.0000", "000x.xxxx", "xxaa.aaaa", "iiii.iiii";

@end smallexample

@c
@c Node
@c
@node Other Notes,  , Part Definitions, Configuration File
@section Other Notes


@itemize @bullet
@item
The @code{devicecode} parameter is the device code used by the STK500
and is obtained from the software section (@code{avr061.zip}) of
Atmel's AVR061 application note available from
@url{http://www.atmel.com/dyn/resources/prod_documents/doc2525.pdf}.

@item
Not all memory types will implement all instructions.

@item
AVR Fuse bits and Lock bits are implemented as a type of memory.

@item
Example memory types are: @code{flash}, @code{eeprom}, @code{fuse},
@code{lfuse} (low fuse), @code{hfuse} (high fuse), @code{efuse}
(extended fuse), @code{signature}, @code{calibration}, @code{lock}.

@item
The memory type specified on the AVRDUDE command line must match one of
the memory types defined for the specified chip.

@item
The @code{pwroff_after_write} flag causes AVRDUDE to attempt to power
the device off and back on after an unsuccessful write to the affected
memory area if VCC programmer pins are defined.  If VCC pins are not
defined for the programmer, a message indicating that the device needs a
power-cycle is printed out.  This flag was added to work around a
problem with the at90s4433/2333's; see the at90s4433 errata at:

         @url{http://www.atmel.com/dyn/resources/prod_documents/doc1280.pdf}

@item
The boot loader from application note AVR109 (and thus also the AVR
Butterfly) does not support writing of fuse bits.  Writing lock bits
is supported, but is restricted to the boot lock bits (BLBxx).  These
are restrictions imposed by the underlying SPM instruction that is used
to program the device from inside the boot loader.  Note that programming
the boot lock bits can result in a ``shoot-into-your-foot'' scenario as
the only way to unprogram these bits is a chip erase, which will also
erase the boot loader code.

The boot loader implements the ``chip erase'' function by erasing the
flash pages of the application section.

Reading fuse and lock bits is fully supported.

@end itemize

@c
@c Node
@c
@node Programmer Specific Information, Platform Dependent Information, Configuration File, Top
@chapter Programmer Specific Information

@menu
* Atmel STK600::
* Atmel DFU bootloader using FLIP version 1::
* SerialUPDI programmer::
@end menu

@c
@c Node
@c
@node Atmel STK600, Atmel DFU bootloader using FLIP version 1, Programmer Specific Information, Programmer Specific Information
@cindex STK600
@section Atmel STK600

@c
@c Update the table below by running the tools/get-stk600-devices.xsl
@c XSLT transformation on targetboard.xml as shipped by the latest
@c release of AVR Studio.
@c
The following devices are supported by the respective STK600 routing
and socket card:

@multitable @columnfractions .25 .25 .5
@headitem Routing card @tab Socket card @tab Devices
@item @code{} @tab @code{STK600-ATTINY10} @tab ATtiny4 ATtiny5 ATtiny9 ATtiny10
@item @code{STK600-RC008T-2} @tab @code{STK600-DIP} @tab ATtiny11 ATtiny12 ATtiny13 ATtiny13A ATtiny25 ATtiny45 ATtiny85
@item @code{STK600-RC008T-7} @tab @code{STK600-DIP} @tab ATtiny15
@item @code{STK600-RC014T-42} @tab @code{STK600-SOIC} @tab ATtiny20
@item @code{STK600-RC020T-1} @tab @code{STK600-DIP} @tab ATtiny2313 ATtiny2313A ATtiny4313
@item @code{} @tab @code{STK600-TinyX3U} @tab ATtiny43U
@item @code{STK600-RC014T-12} @tab @code{STK600-DIP} @tab ATtiny24 ATtiny44 ATtiny84 ATtiny24A ATtiny44A
@item @code{STK600-RC020T-8} @tab @code{STK600-DIP} @tab ATtiny26 ATtiny261 ATtiny261A ATtiny461 ATtiny861 ATtiny861A
@item @code{STK600-RC020T-43} @tab @code{STK600-SOIC} @tab ATtiny261 ATtiny261A ATtiny461 ATtiny461A ATtiny861 ATtiny861A
@item @code{STK600-RC020T-23} @tab @code{STK600-SOIC} @tab ATtiny87 ATtiny167
@item @code{STK600-RC028T-3} @tab @code{STK600-DIP} @tab ATtiny28
@item @code{STK600-RC028M-6} @tab @code{STK600-DIP} @tab ATtiny48 ATtiny88 ATmega8 ATmega8A ATmega48 ATmega88 ATmega168 ATmega48P ATmega48PA ATmega88P ATmega88PA ATmega168P ATmega168PA ATmega328P
@item @code{} @tab @code{QT600-ATTINY88-QT8} @tab ATtiny88
@item @code{STK600-RC040M-4} @tab @code{STK600-DIP} @tab ATmega8515 ATmega162
@item @code{STK600-RC044M-30} @tab @code{STK600-TQFP44} @tab ATmega8515 ATmega162
@item @code{STK600-RC040M-5} @tab @code{STK600-DIP} @tab ATmega8535 ATmega16 ATmega16A ATmega32 ATmega32A ATmega164P ATmega164PA ATmega324P ATmega324PA ATmega644 ATmega644P ATmega644PA ATmega1284P
@item @code{STK600-RC044M-31} @tab @code{STK600-TQFP44} @tab ATmega8535 ATmega16 ATmega16A ATmega32 ATmega32A ATmega164P ATmega164PA ATmega324P ATmega324PA ATmega644 ATmega644P ATmega644PA ATmega1284P
@item @code{} @tab @code{QT600-ATMEGA324-QM64} @tab ATmega324PA
@item @code{STK600-RC032M-29} @tab @code{STK600-TQFP32} @tab ATmega8 ATmega8A ATmega48 ATmega88 ATmega168 ATmega48P ATmega48PA ATmega88P ATmega88PA ATmega168P ATmega168PA ATmega328P
@item @code{STK600-RC064M-9} @tab @code{STK600-TQFP64} @tab ATmega64 ATmega64A ATmega128 ATmega128A ATmega1281 ATmega2561 AT90CAN32 AT90CAN64 AT90CAN128
@item @code{STK600-RC064M-10} @tab @code{STK600-TQFP64} @tab ATmega165 ATmega165P ATmega169 ATmega169P ATmega169PA ATmega325 ATmega325P ATmega329 ATmega329P ATmega645 ATmega649 ATmega649P
@item @code{STK600-RC100M-11} @tab @code{STK600-TQFP100} @tab ATmega640 ATmega1280 ATmega2560
@item @code{} @tab @code{STK600-ATMEGA2560} @tab ATmega2560
@item @code{STK600-RC100M-18} @tab @code{STK600-TQFP100} @tab ATmega3250 ATmega3250P ATmega3290 ATmega3290P ATmega6450 ATmega6490
@item @code{STK600-RC032U-20} @tab @code{STK600-TQFP32} @tab AT90USB82 AT90USB162 ATmega8U2 ATmega16U2 ATmega32U2 
@item @code{STK600-RC044U-25} @tab @code{STK600-TQFP44} @tab ATmega16U4 ATmega32U4
@item @code{STK600-RC064U-17} @tab @code{STK600-TQFP64} @tab ATmega32U6 AT90USB646 AT90USB1286 AT90USB647 AT90USB1287
@item @code{STK600-RCPWM-22} @tab @code{STK600-TQFP32} @tab ATmega32C1 ATmega64C1 ATmega16M1 ATmega32M1 ATmega64M1
@item @code{STK600-RCPWM-19} @tab @code{STK600-SOIC} @tab AT90PWM2 AT90PWM3 AT90PWM2B AT90PWM3B AT90PWM216 AT90PWM316
@item @code{STK600-RCPWM-26} @tab @code{STK600-SOIC} @tab AT90PWM81
@item @code{STK600-RC044M-24} @tab @code{STK600-TSSOP44} @tab ATmega16HVB ATmega32HVB
@item @code{} @tab @code{STK600-HVE2} @tab ATmega64HVE
@item @code{} @tab @code{STK600-ATMEGA128RFA1} @tab ATmega128RFA1
@item @code{STK600-RC100X-13} @tab @code{STK600-TQFP100} @tab ATxmega64A1 ATxmega128A1 ATxmega128A1_revD ATxmega128A1U
@item @code{} @tab @code{STK600-ATXMEGA1281A1} @tab ATxmega128A1
@item @code{} @tab @code{QT600-ATXMEGA128A1-QT16} @tab ATxmega128A1
@item @code{STK600-RC064X-14} @tab @code{STK600-TQFP64} @tab ATxmega64A3 ATxmega128A3 ATxmega256A3 ATxmega64D3 ATxmega128D3 ATxmega192D3 ATxmega256D3
@item @code{STK600-RC064X-14} @tab @code{STK600-MLF64} @tab ATxmega256A3B
@item @code{STK600-RC044X-15} @tab @code{STK600-TQFP44} @tab ATxmega32A4 ATxmega16A4 ATxmega16D4 ATxmega32D4
@item @code{} @tab @code{STK600-ATXMEGAT0} @tab ATxmega32T0
@item @code{} @tab @code{STK600-uC3-144} @tab AT32UC3A0512 AT32UC3A0256 AT32UC3A0128
@item @code{STK600-RCUC3A144-33} @tab @code{STK600-TQFP144} @tab AT32UC3A0512 AT32UC3A0256 AT32UC3A0128
@item @code{STK600-RCuC3A100-28} @tab @code{STK600-TQFP100} @tab AT32UC3A1512 AT32UC3A1256 AT32UC3A1128
@item @code{STK600-RCuC3B0-21} @tab @code{STK600-TQFP64-2} @tab AT32UC3B0256 AT32UC3B0512RevC AT32UC3B0512 AT32UC3B0128 AT32UC3B064 AT32UC3D1128
@item @code{STK600-RCuC3B48-27} @tab @code{STK600-TQFP48} @tab AT32UC3B1256 AT32UC3B164
@item @code{STK600-RCUC3A144-32} @tab @code{STK600-TQFP144} @tab AT32UC3A3512 AT32UC3A3256 AT32UC3A3128 AT32UC3A364 AT32UC3A3256S AT32UC3A3128S AT32UC3A364S
@item @code{STK600-RCUC3C0-36} @tab @code{STK600-TQFP144} @tab AT32UC3C0512 AT32UC3C0256 AT32UC3C0128 AT32UC3C064
@item @code{STK600-RCUC3C1-38} @tab @code{STK600-TQFP100} @tab AT32UC3C1512 AT32UC3C1256 AT32UC3C1128 AT32UC3C164
@item @code{STK600-RCUC3C2-40} @tab @code{STK600-TQFP64-2} @tab AT32UC3C2512 AT32UC3C2256 AT32UC3C2128 AT32UC3C264
@item @code{STK600-RCUC3C0-37} @tab @code{STK600-TQFP144} @tab AT32UC3C0512 AT32UC3C0256 AT32UC3C0128 AT32UC3C064
@item @code{STK600-RCUC3C1-39} @tab @code{STK600-TQFP100} @tab AT32UC3C1512 AT32UC3C1256 AT32UC3C1128 AT32UC3C164
@item @code{STK600-RCUC3C2-41} @tab @code{STK600-TQFP64-2} @tab AT32UC3C2512 AT32UC3C2256 AT32UC3C2128 AT32UC3C264
@item @code{STK600-RCUC3L0-34} @tab @code{STK600-TQFP48} @tab AT32UC3L064 AT32UC3L032 AT32UC3L016
@item @code{} @tab @code{QT600-AT32UC3L-QM64} @tab AT32UC3L064
@end multitable

Ensure the correct socket and routing card are mounted @emph{before}
powering on the STK600.  While the STK600 firmware ensures the socket
and routing card mounted match each other (using a table stored
internally in nonvolatile memory), it cannot handle the case where a
wrong routing card is used, e. g. the routing card
@code{STK600-RC040M-5} (which is meant for 40-pin DIP AVRs that have
an ADC, with the power supply pins in the center of the package) was
used but an ATmega8515 inserted (which uses the ``industry standard''
pinout with Vcc and GND at opposite corners).

Note that for devices that use the routing card @code{STK600-RC008T-2},
in order to use ISP mode, the jumper for @code{AREF0} must be removed
as it would otherwise block one of the ISP signals.  High-voltage
serial programming can be used even with that jumper installed.

The ISP system of the STK600 contains a detection against shortcuts
and other wiring errors.  AVRDUDE initiates a connection check before
trying to enter ISP programming mode, and display the result if the
target is not found ready to be ISP programmed.

High-voltage programming requires the target voltage to be set to at
least 4.5 V in order to work.  This can be done using
@emph{Terminal Mode}, see @ref{Terminal Mode Operation}.

@c
@c Node
@c
@node Atmel DFU bootloader using FLIP version 1, SerialUPDI programmer , Atmel STK600, Programmer Specific Information
@cindex DFU bootloader
@section Atmel DFU bootloader using FLIP version 1

Bootloaders using the FLIP protocol version 1 experience some very
specific behaviour.

These bootloaders have no option to access memory areas other than
Flash and EEPROM.

When the bootloader is started, it enters a @emph{security mode} where
the only acceptable access is to query the device configuration
parameters (which are used for the signature on AVR devices).  The
only way to leave this mode is a @emph{chip erase}.  As a chip erase
is normally implied by the @option{-U} option when reprogramming the
flash, this peculiarity might not be very obvious immediately.

Sometimes, a bootloader with security mode already disabled seems to
no longer respond with sensible configuration data, but only 0xFF for
all queries.  As these queries are used to obtain the equivalent of a
signature, AVRDUDE can only continue in that situation by forcing the
signature check to be overridden with the @option{-F} option.

A @emph{chip erase} might leave the EEPROM unerased, at least on some
versions of the bootloader.

@c
@c Node
@c
@node SerialUPDI programmer, , Atmel DFU bootloader using FLIP version 1, Programmer Specific Information
@cindex SerialUPDI
@section SerialUPDI programmer

SerialUPDI programmer can be used for programming UPDI-only devices
using very simple serial connection.
You can read more about the details here 
@url{https://github.com/SpenceKonde/AVR-Guidance/blob/master/UPDI/jtag2updi.md}

SerialUPDI programmer has been tested using FT232RL USB->UART interface
with the following connection layout (copied from Spence Kohde's page linked
above):

@example
--------------------                                 To Target device
                DTR|                                  __________________
                Rx |--------------,------------------| UPDI---\/\/---------->
  Tx---/\/\/\---Tx |-------|<|---'          .--------| Gnd    470 ohm 
    resistor    Vcc|---------------------------------| Vcc
        1k      CTS|                     .`          |__________________
                Gnd|--------------------' 
--------------------
@end example

There are several limitations in current SerialUPDI/AVRDUDE integration,
listed below.

At the end of each run there are fuse values being presented to the user.
For most of the UPDI-enabled devices these definitions (low fuse, high
fuse, extended fuse) have no meaning whatsoever, as they have been 
simply replaced by array of fuses: fuse0..9. Therefore you can simply
ignore this particular line of AVRDUDE output.

Currently available devices support only UPDI NVM programming model 0 
and 2, but there is also experimental implementation of model 3 - not
yet tested.

One of the core AVRDUDE features is verification of the connection by
reading device signature prior to any operation, but this operation
is not possible on UPDI locked devices. Therefore, to be able to 
connect to such a device, you have to provide @option{-F} to override
this check.

Please note: using @option{-F} during write operation to locked device 
will force chip erase. Use carefully.

Another issue you might notice is slow performance of EEPROM writing
using SerialUPDI for AVR Dx devices. This can be addressed by changing
@emph{avrdude.conf} section for this device - changing EEPROM page 
size to 0x20 (instead of default 1), like so:

@example
#------------------------------------------------------------
# AVR128DB28
#------------------------------------------------------------

part parent    ".avrdx"
    id        = "avr128db28";
    desc      = "AVR128DB28";
    signature = 0x1E 0x97 0x0E;

    memory "flash"
        size      = 0x20000;
        offset    = 0x800000;
        page_size = 0x200;
        readsize  = 0x100;
    ;

    memory "eeprom"
        size      = 0x200;
        offset    = 0x1400;
        page_size = 0x1;
        readsize  = 0x100;
    ;
;
@end example

USERROW memory has not been defined for new devices except for 
experimental addition for AVR128DB28. The point of USERROW is to 
provide ability to write configuration details to already locked
device and currently SerialUPDI interface supports this feature,
but it hasn't been tested on wide variety of chips. Treat this as
something experimental at this point. Please note: on locked devices
it's not possible to read back USERROW contents when written, so
the automatic verification will most likely fail and to prevent
error messages, use @option{-V}.

Please note that SerialUPDI interface is pretty new and some
issues are to be expected. In case you run into them, please
make sure to run the intended command with debug output enabled
(@option{-v -v -v}) and provide this verbose output with your
bug report. You can also try to perform the same action using
@emph{pymcuprog} (@url{https://github.com/microchip-pic-avr-tools/pymcuprog})
utility with @option{-v debug} and provide its output too.
You will notice that both outputs are pretty similar, and this
was implemented like that on purpose - it was supposed to make
analysis of UPDI protocol quirks easier.

@c
@c Node
@c
@node Platform Dependent Information, Troubleshooting, Programmer Specific Information, Top
@appendix Platform Dependent Information

@menu
* Unix::
* Windows::
@end menu

@c
@c Node
@c
@node Unix, Windows, Platform Dependent Information, Platform Dependent Information
@section Unix

@menu
* Unix Installation::           
* Unix Configuration Files::    
* Unix Port Names::             
* Unix Documentation::          
@end menu

@c
@c Node
@c
@node Unix Installation, Unix Configuration Files, Unix, Unix
@subsection Unix Installation

@noindent
To build and install from the source tarball on Unix like systems:

@example
$ gunzip -c avrdude-@value{VERSION}.tar.gz | tar xf -
$ cd avrdude-@value{VERSION}
$ ./configure
$ make
$ su root -c 'make install'
@end example

The default location of the install is into @code{/usr/local} so you
will need to be sure that @code{/usr/local/bin} is in your @code{PATH}
environment variable.

If you do not have root access to your system, you can do the
following instead:

@example
$ gunzip -c avrdude-@value{VERSION}.tar.gz | tar xf -
$ cd avrdude-@value{VERSION}
$ ./configure --prefix=$HOME/local
$ make
$ make install
@end example

@menu
* FreeBSD Installation::        
* Linux Installation::          
@end menu

@c
@c Node
@c
@node FreeBSD Installation, Linux Installation, Unix Installation, Unix Installation
@subsubsection FreeBSD Installation

@noindent
AVRDUDE is installed via the FreeBSD Ports Tree as follows:

@example
% su - root
# cd /usr/ports/devel/avrdude
# make install
@end example

If you wish to install from a pre-built package instead of the source,
you can use the following instead:

@example
% su - root
# pkg_add -r avrdude
@end example

Of course, you must be connected to the Internet for these methods to
work, since that is where the source as well as the pre-built package is
obtained.

@c
@c Node
@c
@node Linux Installation,  , FreeBSD Installation, Unix Installation
@subsubsection Linux Installation

@noindent
On rpm based Linux systems (such as RedHat, SUSE, Mandrake, etc.), you
can build and install the rpm binaries directly from the tarball:

@example
$ su - root
# rpmbuild -tb avrdude-@value{VERSION}.tar.gz
# rpm -Uvh /usr/src/redhat/RPMS/i386/avrdude-@value{VERSION}-1.i386.rpm
@end example

Note that the path to the resulting rpm package, differs from system
to system. The above example is specific to RedHat.

@c
@c Node
@c
@node Unix Configuration Files, Unix Port Names, Unix Installation, Unix
@subsection Unix Configuration Files

@noindent
When AVRDUDE is build using the default @option{--prefix} configure
option, the default configuration file for a Unix system is located at
@code{/usr/local/etc/avrdude.conf}.  This can be overridden by using the
@option{-C} command line option.  Additionally, the user's home directory
is searched for a file named @code{.avrduderc}, and if found, is used to
augment the system default configuration file.

@menu
* FreeBSD Configuration Files::  
* Linux Configuration Files::   
@end menu

@c
@c Node
@c
@node FreeBSD Configuration Files, Linux Configuration Files, Unix Configuration Files, Unix Configuration Files
@subsubsection FreeBSD Configuration Files

@noindent
When AVRDUDE is installed using the FreeBSD ports system, the system
configuration file is always @code{/usr/local/etc/avrdude.conf}.

@c
@c Node
@c
@node Linux Configuration Files,  , FreeBSD Configuration Files, Unix Configuration Files
@subsubsection Linux Configuration Files

@noindent
When AVRDUDE is installed using from an rpm package, the system
configuration file will be always be @code{/etc/avrdude.conf}.

@c
@c Node
@c
@node Unix Port Names, Unix Documentation, Unix Configuration Files, Unix
@subsection Unix Port Names

@noindent
The parallel and serial port device file names are system specific.
MacOS has no default serial or parallel port names, but available 
ports can be found under @code{/dev/cu.*}.
The following table lists the default names for a given system.

@multitable @columnfractions .30 .30 .30
@item @strong{System}
  @tab @strong{Default Parallel Port}
  @tab @strong{Default Serial Port}
@item FreeBSD
  @tab @code{/dev/ppi0}
  @tab @code{/dev/cuad0}
@item Linux
  @tab @code{/dev/parport0}
  @tab @code{/dev/ttyS0}
@item Solaris
  @tab @code{/dev/printers/0}
  @tab @code{/dev/term/a}
@end multitable

On FreeBSD systems, AVRDUDE uses the ppi(4) interface for
accessing the parallel port and the sio(4) driver for serial port
access.

On Linux systems, AVRDUDE uses the ppdev interface for
accessing the parallel port and the tty driver for serial port
access.

On Solaris systems, AVRDUDE uses the ecpp(7D) driver for
accessing the parallel port and the asy(7D) driver for serial port
access.

@c
@c Node
@c
@node Unix Documentation,  , Unix Port Names, Unix
@subsection Unix Documentation

@noindent
AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
@code{/usr/local/man/man1} area, while the HTML and PDF documentation
is installed in @code{/usr/local/share/doc/avrdude} directory.  The
info manual is installed in @code{/usr/local/info/avrdude.info}.

Note that these locations can be altered by various configure options
such as @option{--prefix}.

@c
@c Node
@c
@node Windows,  , Unix, Platform Dependent Information
@section Windows

@menu
* Windows Installation::        
* Windows Configuration Files::  
* Windows Port Names::          
* Documentation::               
@end menu

@c
@c Node
@c
@node Windows Installation, Windows Configuration Files, Windows, Windows
@subsection Installation

@noindent
A Windows executable of avrdude is included in WinAVR which can be found at
@url{http://sourceforge.net/projects/winavr}. WinAVR is a suite of executable, 
open source software development tools for the AVR for the Windows platform.

There are two options to build avrdude from source under Windows.
The first one is to use Cygwin (@url{http://www.cygwin.com/}).

To build and install from the source tarball for Windows (using Cygwin):

@example
$ set PREFIX=<your install directory path>
$ export PREFIX
$ gunzip -c avrdude-@value{VERSION}.tar.gz | tar xf -
$ cd avrdude-@value{VERSION}
$ ./configure LDFLAGS="-static" --prefix=$PREFIX --datadir=$PREFIX 
--sysconfdir=$PREFIX/bin --enable-versioned-doc=no
$ make
$ make install
@end example

Note that recent versions of Cygwin (starting with 1.7) removed the
MinGW support from the compiler that is needed in order to build a
native Win32 API binary that does not require to install the Cygwin
library @code{cygwin1.dll} at run-time.  Either try using an older
compiler version that still supports MinGW builds, or use MinGW
(@url{http://www.mingw.org/}) directly.

@c
@c XXX Please add more detailed instructions here.
@c


@c
@c Node
@c
@node Windows Configuration Files, Windows Port Names, Windows Installation, Windows
@subsection Configuration Files

@menu
* Configuration file names::    
* How AVRDUDE finds the configuration files.::  
@end menu

@c
@c Node
@c
@node Configuration file names, How AVRDUDE finds the configuration files., Windows Configuration Files, Windows Configuration Files
@subsubsection Configuration file names

@noindent
AVRDUDE on Windows looks for a system configuration file name of
@code{avrdude.conf} and looks for a user override configuration file of
@code{avrdude.rc}.

@c
@c Node
@c
@node How AVRDUDE finds the configuration files.,  , Configuration file names, Windows Configuration Files
@subsubsection How AVRDUDE finds the configuration files.
 
@noindent
AVRDUDE on Windows has a different way of searching for the system and
user configuration files. Below is the search method for locating the
configuration files:

@enumerate

@item
Only for the system configuration file:
@code{<directory from which application loaded>/../etc/avrdude.conf}

@item
The directory from which the application loaded.

@item
The current directory.

@item
The Windows system directory. On Windows NT, the name of this directory
is @code{SYSTEM32}.

@item
Windows NT: The 16-bit Windows system directory. The name of this
directory is @code{SYSTEM}.

@item
The Windows directory.

@item
The directories that are listed in the PATH environment variable.

@end enumerate


@c
@c Node
@c
@node Windows Port Names, Windows Configuration Files, Windows
@subsection Port Names

@menu
* Serial Ports::                
* Parallel Ports::              
@end menu

@c
@c Node
@c
@node Serial Ports, Parallel Ports, Windows Port Names, Windows Port Names
@subsubsection Serial Ports
 
@noindent
When you select a serial port (i.e. when using an STK500) use the
Windows serial port device names such as: com1, com2, etc.
 
@c
@c Node
@c
@node Parallel Ports,  , Serial Ports, Windows Port Names
@subsubsection Parallel Ports

@noindent
AVRDUDE will accept 3 Windows parallel port names: lpt1, lpt2, or
lpt3.  Each of these names corresponds to a fixed parallel port base
address:

@table @code
@item lpt1
0x378

@item lpt2
0x278

@item lpt3
0x3BC

@end table

On your desktop PC, lpt1 will be the most common choice. If you are
using a laptop, you might have to use lpt3 instead of lpt1. Select the
name of the port the corresponds to the base address of the parallel
port that you want.

If the parallel port can be accessed through a different
address, this address can be specified directly, using the common C
language notation (i. e., hexadecimal values are prefixed by @code{0x}).

@c
@c Node
@c
@node Documentation, Windows
@subsection Documentation

@noindent
AVRDUDE installs a manual page as well as info, HTML and PDF
documentation.  The manual page is installed in
@code{/usr/local/man/man1} area, while the HTML and PDF documentation
is installed in @code{/usr/local/share/doc/avrdude} directory.  The
info manual is installed in @code{/usr/local/info/avrdude.info}.

Note that these locations can be altered by various configure options
such as @option{--prefix} and @option{--datadir}.


@c
@c Node
@c
@node Troubleshooting,Index ,Platform Dependent Information ,Top
@appendix Troubleshooting

@noindent
In general, please report any bugs encountered via
@*
@url{https://github.com/avrdudes/avrdude/issues}.


@itemize @bullet

@item
Problem: I'm using a serial programmer under Windows and get the following
error:

@code{avrdude: serial_open(): can't set attributes for device "com1"},

Solution: This problem seems to appear with certain versions of Cygwin. Specifying
@code{"/dev/com1"} instead of @code{"com1"} should help.


@item
Problem: I'm using Linux and my AVR910 programmer is really slow.

Solution (short): @code{setserial @var{port} low_latency}

Solution (long):
There are two problems here. First, the system may wait some time before it
passes data from the serial port to the program. Under Linux the following
command works around this (you may need root privileges for this).

@code{setserial @var{port} low_latency}

Secondly, the serial interface chip may delay the interrupt for some time.
This behaviour can be changed by setting the FIFO-threshold to one. Under Linux this
can only be done by changing the kernel source in @code{drivers/char/serial.c}.
Search the file for @code{UART_FCR_TRIGGER_8} and replace it with @code{UART_FCR_TRIGGER_1}. Note that overall performance might suffer if there
is high throughput on serial lines. Also note that you are modifying the kernel at
your own risk.


@item
Problem: I'm not using Linux and my AVR910 programmer is really slow.

Solutions: The reasons for this are the same as above.
If you know how to work around this on your OS, please let us know.

@item
Problem: Updating the flash ROM from terminal mode does not work with the
JTAG ICEs.

Solution: None at this time.  Currently, the JTAG ICE code cannot
write to the flash ROM one byte at a time.

@item
Problem: Page-mode programming the EEPROM (using the -U option) does
not erase EEPROM cells before writing, and thus cannot overwrite any
previous value != 0xff.

Solution: None.  This is an inherent feature of the way JTAG EEPROM
programming works, and is documented that way in the Atmel AVR
datasheets.
In order to successfully program the EEPROM that way, a prior chip
erase (with the EESAVE fuse unprogrammed) is required.
This also applies to the STK500 and STK600 in high-voltage programming mode.

@item
Problem: How do I turn off the @var{DWEN} fuse?

Solution: If the @var{DWEN} (debugWire enable) fuse is activated,
the @var{/RESET} pin is not functional anymore, so normal ISP
communication cannot be established.
There are two options to deactivate that fuse again: high-voltage
programming, or getting the JTAG ICE mkII talk debugWire, and
prepare the target AVR to accept normal ISP communication again.

The first option requires a programmer that is capable of high-voltage
programming (either serial or parallel, depending on the AVR device),
for example the STK500.  In high-voltage programming mode, the
@var{/RESET} pin is activated initially using a 12 V pulse (thus the
name @emph{high voltage}), so the target AVR can subsequently be
reprogrammed, and the @var{DWEN} fuse can be cleared.  Typically, this
operation cannot be performed while the AVR is located in the target
circuit though.

The second option requires a JTAG ICE mkII that can talk the debugWire
protocol.  The ICE needs to be connected to the target using the
JTAG-to-ISP adapter, so the JTAG ICE mkII can be used as a debugWire
initiator as well as an ISP programmer.  AVRDUDE will then be activated
using the @var{jtag2isp} programmer type.  The initial ISP
communication attempt will fail, but AVRDUDE then tries to initiate a
debugWire reset.  When successful, this will leave the target AVR in a
state where it can accept standard ISP communication.  The ICE is then
signed off (which will make it signing off from the USB as well), so
AVRDUDE has to be called again afterwards.  This time, standard ISP
communication can work, so the @var{DWEN} fuse can be cleared.

The pin mapping for the JTAG-to-ISP adapter is:

@multitable @columnfractions .2 .2
@item @strong{JTAG pin} @tab @strong{ISP pin}
@item 1 @tab 3
@item 2 @tab 6
@item 3 @tab 1
@item 4 @tab 2
@item 6 @tab 5
@item 9 @tab 4
@end multitable

@item
Problem: Multiple USBasp or USBtinyISP programmers connected simultaneously are not
found.

Solution: The USBtinyISP code supports distinguishing multiple
programmers based on their bus:device connection tuple that describes
their place in the USB hierarchy on a specific host.  This tuple can
be added to the @var{-P usb} option, similar to adding a serial number
on other USB-based programmers.

The actual naming convention for the bus and device names is
operating-system dependent; AVRDUDE will print out what it found
on the bus when running it with (at least) one @var{-v} option.
By specifying a string that cannot match any existing device
(for example, @var{-P usb:xxx}), the scan will list all possible
candidate devices found on the bus.

Examples:
@example
avrdude -c usbtiny -p atmega8 -P usb:003:025 (Linux)
avrdude -c usbtiny -p atmega8 -P usb:/dev/usb:/dev/ugen1.3 (FreeBSD 8+)
avrdude -c usbtiny -p atmega8 \
  -P usb:bus-0:\\.\libusb0-0001--0x1781-0x0c9f (Windows)
@end example

@item
Problem: I cannot do @dots{} when the target is in debugWire mode.

Solution: debugWire mode imposes several limitations.

The debugWire protocol is Atmel's proprietary one-wire (plus ground)
protocol to allow an in-circuit emulation of the smaller AVR devices,
using the @var{/RESET} line.
DebugWire mode is initiated by activating the @var{DWEN}
fuse, and then power-cycling the target.
While this mode is mainly intended for debugging/emulation, it
also offers limited programming capabilities.
Effectively, the only memory areas that can be read or programmed
in this mode are flash ROM and EEPROM.
It is also possible to read out the signature.
All other memory areas cannot be accessed.
There is no
@emph{chip erase}
functionality in debugWire mode; instead, while reprogramming the
flash ROM, each flash ROM page is erased right before updating it.
This is done transparently by the JTAG ICE mkII (or AVR Dragon).
The only way back from debugWire mode is to initiate a special
sequence of commands to the JTAG ICE mkII (or AVR Dragon), so the
debugWire mode will be temporarily disabled, and the target can
be accessed using normal ISP programming.
This sequence is automatically initiated by using the JTAG ICE mkII
or AVR Dragon in ISP mode, when they detect that ISP mode cannot be
entered.

@item
Problem: I want to use my JTAG ICE mkII to program an
Xmega device through PDI.  The documentation tells me to use the
@emph{XMEGA PDI adapter for JTAGICE mkII} that is supposed to ship
with the kit, yet I don't have it.

Solution: Use the following pin mapping:

@multitable @columnfractions .2 .2 .2 .2
@item @strong{JTAGICE} @tab @strong{Target} @tab @strong{Squid cab-} @tab @strong{PDI}
@item @strong{mkII probe} @tab @strong{pins} @tab @strong{le colors} @tab @strong{header}
@item 1 (TCK)   @tab         @tab Black  @tab
@item 2 (GND)   @tab GND     @tab White  @tab 6
@item 3 (TDO)   @tab         @tab Grey   @tab
@item 4 (VTref) @tab VTref   @tab Purple @tab 2
@item 5 (TMS)   @tab         @tab Blue   @tab
@item 6 (nSRST) @tab PDI_CLK @tab Green  @tab 5
@item 7 (N.C.)  @tab         @tab Yellow @tab
@item 8 (nTRST) @tab         @tab Orange @tab
@item 9 (TDI)   @tab PDI_DATA @tab Red   @tab 1
@item 10 (GND)  @tab         @tab Brown  @tab
@end multitable

@item
Problem: I want to use my AVR Dragon to program an
Xmega device through PDI.  

Solution: Use the 6 pin ISP header on the Dragon and the following pin mapping:

@multitable @columnfractions .2 .2
@item @strong{Dragon} @tab @strong{Target}
@item @strong{ISP Header} @tab @strong{pins}
@item 1 (SDI)   @tab PDI_DATA
@item 2 (VCC)   @tab VCC
@item 3 (SCK)   @tab 
@item 4 (SDO)   @tab
@item 5 (RESET) @tab PDI_CLK / RST
@item 6 (GND)   @tab GND
@end multitable

@item
Problem: I want to use my AVRISP mkII to program an
ATtiny4/5/9/10 device through TPI.  How to connect the pins?

Solution: Use the following pin mapping:

@multitable @columnfractions .2 .2 .2
@item @strong{AVRISP} @tab @strong{Target} @tab @strong{ATtiny}
@item @strong{connector} @tab @strong{pins} @tab @strong{pin #}
@item 1 (SDI)   @tab TPIDATA  @tab 1
@item 2 (VTref) @tab Vcc      @tab 5
@item 3 (SCK)   @tab TPICLK   @tab 3
@item 4 (SDO)   @tab          @tab
@item 5 (RESET) @tab /RESET   @tab 6
@item 6 (GND)   @tab GND      @tab 2
@end multitable

@item
Problem: I want to program an ATtiny4/5/9/10 device using a serial/parallel 
bitbang programmer.  How to connect the pins?

Solution: Since TPI has only 1 pin for bi-directional data transfer, both 
@var{SDI} and @var{SDO} pins should be connected to the @var{TPIDATA} pin
on the ATtiny device.
However, a 1K resistor should be placed between the @var{SDO} and @var{TPIDATA}.
The @var{SDI} pin connects to @var{TPIDATA} directly.
The @var{SCK} pin is connected to @var{TPICLK}.

In addition, the @var{Vcc}, @var{/RESET} and @var{GND} pins should 
be connected to their respective ports on the ATtiny device.

@item
Problem: How can I use a FTDI FT232R USB-to-Serial device for bitbang programming?

Solution: When connecting the FT232 directly to the pins of the target Atmel device, 
the polarity of the pins defined in the @code{programmer} definition should be 
inverted by prefixing a tilde. For example, the @var{dasa} programmer would 
look like this when connected via a FT232R device (notice the tildes in 
front of pins 7, 4, 3 and 8):

@example
programmer
  id    = "dasa_ftdi";
  desc  = "serial port banging, reset=rts sck=dtr sdo=txd sdi=cts";
  type  = serbb;
  reset = ~7;
  sck   = ~4;
  sdo   = ~3;
  sdi   = ~8;
;
@end example

Note that this uses the FT232 device as a normal serial port, not using the 
FTDI drivers in the special bitbang mode.

@item
Problem: My ATtiny4/5/9/10 reads out fine, but any attempt to program
it (through TPI) fails.  Instead, the memory retains the old contents.

Solution: Mind the limited programming supply voltage range of these
devices.

In-circuit programming through TPI is only guaranteed by the datasheet
at Vcc = 5 V.

@item
Problem: My ATxmega@dots{}A1/A2/A3 cannot be programmed through PDI with
my AVR Dragon.  Programming through a JTAG ICE mkII works though, as does
programming through JTAG.

Solution: None by this time (2010 Q1).

It is said that the AVR Dragon can only program devices from the A4
Xmega sub-family.

@item
Problem: when programming with an AVRISPmkII or STK600, AVRDUDE hangs
when programming files of a certain size (e.g. 246 bytes).  Other
(larger or smaller) sizes work though.

Solution: This is a bug caused by an incorrect handling of zero-length
packets (ZLPs) in some versions of the libusb 0.1 API wrapper that ships
with libusb 1.x in certain Linux distributions.  All Linux systems with
kernel versions < 2.6.31 and libusb >= 1.0.0 < 1.0.3 are reported to be
affected by this.

See also: @url{http://www.libusb.org/ticket/6}

@item
Problem: after flashing a firmware that reduces the target's clock
speed (e.g. through the @code{CLKPR} register), further ISP connection
attempts fail.  Or a programmer cannot initialize communication with
a brand new chip.

Solution: Even though ISP starts with pulling @var{/RESET} low, the
target continues to run at the internal clock speed either as defined by
the firmware running before or as set by the factory.  Therefore, the
ISP clock speed must be reduced appropriately (to less than 1/4 of the
internal clock speed) using the -B option before the ISP initialization
sequence will succeed.

As that slows down the entire subsequent ISP session, it might make
sense to just issue a @emph{chip erase} using the slow ISP clock
(option @code{-e}), and then start a new session at higher speed.
Option @code{-D} might be used there, to prevent another unneeded
erase cycle.

@end itemize

@node Index, , Troubleshooting, Top

@unnumbered Concept Index

@printindex cp

@bye

